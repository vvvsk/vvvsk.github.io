<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第88场周赛</title>
    <url>/archives/5122a47f.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-88/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="848-字母移位"><a href="#848-字母移位" class="headerlink" title="848. 字母移位"></a><a href="https://leetcode-cn.com/problems/shifting-letters/" target="_blank" rel="noopener">848. 字母移位</a></h4><p><strong>题解</strong>：根据描述，第一反应模拟这个过程，超时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shiftingLetters</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; shifts)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;shifts.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            S = shiftStr(S,shifts[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shiftStr</span><span class="params">(<span class="built_in">string</span> &amp;s,<span class="keyword">int</span> shift,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        shift%=<span class="number">26</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()&amp;&amp;i&lt;=<span class="built_in">end</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] =<span class="string">'a'</span> + (s[i]-<span class="string">'a'</span>+shift)%<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第二反应：根据上述这个模拟超时过程，想一优化，shifts数组后面开始，逐个偏移，根据描述，后面的偏移会加到前面。于是有了后缀和这一说法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shiftingLetters</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; shifts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=shifts.<span class="built_in">size</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            shifts[i]%=<span class="number">26</span>;</span><br><span class="line">            shifts[i]+=shifts[i+<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//计算后缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            S[i] =<span class="string">'a'</span> + (S[i]-<span class="string">'a'</span>+shifts[i])%<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="849-到最近的人的最大距离"><a href="#849-到最近的人的最大距离" class="headerlink" title="849. 到最近的人的最大距离"></a><a href="https://leetcode-cn.com/problems/maximize-distance-to-closest-person/" target="_blank" rel="noopener">849. 到最近的人的最大距离</a></h4><p><strong>题解</strong>：根据描述，本题可转换为最长连续0的长度。分三种情况，一开始就连续的0（左边无1），在中间连续的0（指0的左右都有1），在末尾连续的0（右边无1）.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDistToClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; seats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = seats.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> K = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        &#123;<span class="comment">//统计中间0的长度，</span></span><br><span class="line">            <span class="keyword">if</span> (seats[i] == <span class="number">1</span>)</span><br><span class="line">                K = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                K++;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, (K + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        &#123;<span class="comment">//统计第一种情况</span></span><br><span class="line">            <span class="keyword">if</span> (seats[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;<span class="comment">//统计第三中情况</span></span><br><span class="line">            <span class="keyword">if</span> (seats[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, N - <span class="number">1</span> - i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="851-喧闹和富有"><a href="#851-喧闹和富有" class="headerlink" title="851. 喧闹和富有"></a><a href="https://leetcode-cn.com/problems/loud-and-rich/" target="_blank" rel="noopener">851. 喧闹和富有</a></h4><p><strong>题解</strong>：根据描述，好像描述有点复杂，上图。</p>
<p><img src="/archives/5122a47f/1.png" alt></p>
<p>依据谁比谁更穷（比如0号选手比1号选手穷）这样的关系，构建了一个有向图。旁边红字对应的是每位选手的安静值。题目的意思就是把每位选手的安静值更新为所有比他富有的选手的安静值中，最小值对应的选手，怎么办？模拟图的深搜过程，假设DFS(i)表示所有比i号选手富有的选手的最小安静值对应的选手。那么,写成代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;answer;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;graph;</span><br><span class="line">   <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">loudAndRich</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; richer, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quiet)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> N = quiet.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> node=<span class="number">0</span>;node&lt;N;++node)</span><br><span class="line">       &#123;<span class="comment">//邻接表初始化</span></span><br><span class="line">           <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">           graph.push_back(v);</span><br><span class="line">           answer.push_back(<span class="number">-1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> i:richer)</span><br><span class="line">           graph[i[<span class="number">1</span>]].push_back(i[<span class="number">0</span>]);</span><br><span class="line">       <span class="comment">//邻接表赋值</span></span><br><span class="line">   </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> node=<span class="number">0</span>;node&lt;N;node++)</span><br><span class="line">           dfs(node,quiet);</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">return</span> answer;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;quiet)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (answer[node] == <span class="number">-1</span>) </span><br><span class="line">       &#123;</span><br><span class="line">           answer[node] = node;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> child: graph[node])</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">int</span> cand = dfs(child,quiet);</span><br><span class="line">               <span class="keyword">if</span> (quiet[cand] &lt; quiet[answer[node]])</span><br><span class="line">                   answer[node] = cand;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> answer[node];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="850-矩形面积-II"><a href="#850-矩形面积-II" class="headerlink" title="850. 矩形面积 II"></a><a href="https://leetcode-cn.com/problems/rectangle-area-ii/" target="_blank" rel="noopener">850. 矩形面积 II</a></h4><p>不会，待填坑，开始复习简历上的内容了。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第87场周赛</title>
    <url>/archives/a029fff2.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-87/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a><a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener">844. 比较含退格的字符串</a></h4><p><strong>题解</strong>：日常水题，根据描述，按照描述来干了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s_tmp = enterStr(S);</span><br><span class="line">        <span class="built_in">string</span> t_tmp = enterStr(T);</span><br><span class="line">        <span class="keyword">return</span> s_tmp== t_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">enterStr</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'#'</span>&amp;&amp;(ret.length()&gt;<span class="number">0</span>)) ret.erase(ret.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'#'</span>&amp;&amp;(ret.length()==<span class="number">0</span>))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> ret+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="845-数组中的最长山脉"><a href="#845-数组中的最长山脉" class="headerlink" title="845. 数组中的最长山脉"></a><a href="https://leetcode-cn.com/problems/longest-mountain-in-array/" target="_blank" rel="noopener">845. 数组中的最长山脉</a></h4><p><strong>题解</strong>：超喜欢这类写的工工整整的题目。根据描述，只要我们遍历数组，找到符合山脉条件（中间的山要高于两侧）的位置，然后以该位置为中心，向左右拓展。（改一下写代码习惯，括号另起一行书写）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.<span class="built_in">size</span>()&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;A[i<span class="number">-1</span>]&amp;&amp;A[i]&gt;A[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">int</span> left = i<span class="number">-1</span>;</span><br><span class="line">               	<span class="keyword">while</span>(left&gt;<span class="number">0</span> &amp;&amp;A[left]&gt;A[left<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp++;</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> right = i+<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">while</span>(right&lt;A.<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;A[right]&gt;A[right+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp++;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret=<span class="built_in">max</span>(ret,tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="846-一手顺子"><a href="#846-一手顺子" class="headerlink" title="846. 一手顺子"></a><a href="https://leetcode-cn.com/problems/hand-of-straights/" target="_blank" rel="noopener">846. 一手顺子</a></h4><p><strong>题解</strong>：根据描述，只需要对手上所有的牌建立一个map，每三张连续的牌的val-1，一直检测，若不能检测到连续的牌，return false。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNStraightHand</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; hand, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = hand.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n % W != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : hand) mp[i]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>();it != mp.<span class="built_in">end</span>();)&#123;</span><br><span class="line">            <span class="keyword">while</span>(it!=mp.<span class="built_in">end</span>() &amp;&amp; it-&gt;second &lt;= <span class="number">0</span>) it++;</span><br><span class="line">            <span class="keyword">if</span>(iter == mp.<span class="built_in">end</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> cm = it-&gt;first,cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(cnt = <span class="number">0</span>;cnt &lt; W;++cnt) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[cm] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    mp[cm]--;</span><br><span class="line">                    cm++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="847-访问所有节点的最短路径"><a href="#847-访问所有节点的最短路径" class="headerlink" title="847. 访问所有节点的最短路径"></a><a href="https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/" target="_blank" rel="noopener">847. 访问所有节点的最短路径</a></h4>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第86场周赛</title>
    <url>/archives/4feb94cc.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-86/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="840-矩阵中的幻方"><a href="#840-矩阵中的幻方" class="headerlink" title="840. 矩阵中的幻方"></a><a href="https://leetcode-cn.com/problems/magic-squares-in-grid/" target="_blank" rel="noopener">840. 矩阵中的幻方</a></h4><p><strong>题解</strong>：根据描述，第一反应，由数据范围，满足题意的3×3的矩阵，从3×3矩阵的中间元素暴力枚举。</p>
<p>如何判断一个3×3矩阵是幻方的？首先这9个数均不相同，其次这9个数范围为1-9。最后每一行每一列，和对角线元素和均为15，最中间元素为5。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numMagicSquaresInside</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;++j)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(judgeSquares(grid,i,j)) ret++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s = &#123;grid[i<span class="number">-1</span>][j<span class="number">-1</span>],grid[i<span class="number">-1</span>][j],grid[i<span class="number">-1</span>][j+<span class="number">1</span>],</span><br><span class="line">                    grid[i][j<span class="number">-1</span>],grid[i][j],grid[i][j+<span class="number">1</span>],</span><br><span class="line">                    grid[i+<span class="number">1</span>][j<span class="number">-1</span>],grid[i+<span class="number">1</span>][j],grid[i+<span class="number">1</span>][j+<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()!=<span class="number">9</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=<span class="number">0</span>||i&gt;<span class="number">10</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (grid[i][j]==<span class="number">5</span>&amp;&amp;(grid[i<span class="number">-1</span>][j<span class="number">-1</span>]+grid[i<span class="number">-1</span>][j]+grid[i<span class="number">-1</span>][j+<span class="number">1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i][j<span class="number">-1</span>]+grid[i][j]+grid[i][j+<span class="number">1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i+<span class="number">1</span>][j<span class="number">-1</span>]+grid[i+<span class="number">1</span>][j]+grid[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i<span class="number">-1</span>][j<span class="number">-1</span>]+grid[i][j]+grid[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i<span class="number">-1</span>][j+<span class="number">1</span>]+grid[i][j]+grid[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i<span class="number">-1</span>][j<span class="number">-1</span>]+grid[i][j<span class="number">-1</span>]+grid[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i<span class="number">-1</span>][j]+grid[i][j]+grid[i+<span class="number">1</span>][j]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i<span class="number">-1</span>][j+<span class="number">1</span>]+grid[i][j+<span class="number">1</span>]+grid[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">15</span>)</span><br><span class="line">                        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="841-钥匙和房间"><a href="#841-钥匙和房间" class="headerlink" title="841. 钥匙和房间"></a><a href="https://leetcode-cn.com/problems/keys-and-rooms/" target="_blank" rel="noopener">841. 钥匙和房间</a></h4><p><strong>题解</strong>：根据描述，第一反应，我们只需要按照他的描述，进一个房间，拿钥匙，再进另一个房间。自然转换成深度优先搜索了。</p>
<p>第二反应，其实就是遍历一遍，看哪些房间不可到达。可用BFS</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = rooms.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;visit(len,<span class="number">0</span>);</span><br><span class="line">        dfs(rooms,<span class="number">0</span>,visit);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:visit)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms,<span class="keyword">int</span> i,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;visit)</span></span>&#123;</span><br><span class="line">        visit[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> room:rooms[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[room]) dfs(rooms,room,visit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="842-将数组拆分成斐波那契序列"><a href="#842-将数组拆分成斐波那契序列" class="headerlink" title="842. 将数组拆分成斐波那契序列"></a><a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/" target="_blank" rel="noopener">842. 将数组拆分成斐波那契序列</a></h4><h4 id="843-猜猜这个单词"><a href="#843-猜猜这个单词" class="headerlink" title="843. 猜猜这个单词"></a><a href="https://leetcode-cn.com/problems/guess-the-word/" target="_blank" rel="noopener">843. 猜猜这个单词</a></h4>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第85场周赛</title>
    <url>/archives/a4dc2fcf.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-85/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="836-矩形重叠"><a href="#836-矩形重叠" class="headerlink" title="836. 矩形重叠"></a><a href="https://leetcode-cn.com/problems/rectangle-overlap/" target="_blank" rel="noopener">836. 矩形重叠</a></h4><p><strong>题解</strong>：根据描述，我们需要找到什么时候才是重合的规律。如图所示，</p>
<p><img src="/archives/a4dc2fcf/1.png" alt></p>
<p>可以看到规律了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rec2[<span class="number">0</span>]&lt;rec1[<span class="number">2</span>] &amp;&amp; rec2[<span class="number">1</span>]&lt;rec1[<span class="number">3</span>] &amp;&amp; rec2[<span class="number">2</span>]&gt;rec1[<span class="number">0</span>] &amp;&amp; rec2[<span class="number">3</span>]&gt;rec1[<span class="number">1</span>] )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="838-推多米诺"><a href="#838-推多米诺" class="headerlink" title="838. 推多米诺"></a><a href="https://leetcode-cn.com/problems/push-dominoes/" target="_blank" rel="noopener">838. 推多米诺</a></h4><p><strong>题解</strong>：根据描述，第一反应时模拟这个过程，把每经过一秒后的状态表示出来，再用这个新状态去更新这个过程。当状态没有更新，结束这个模拟过程。有如下code，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">pushDominoes</span><span class="params">(<span class="built_in">string</span> dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = dominoes.length();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> dominoes;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">int</span> flag;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            ret = <span class="string">""</span>;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(dominoes[<span class="number">0</span>]==<span class="string">'.'</span>&amp;&amp;dominoes[<span class="number">1</span>]==<span class="string">'L'</span>)&#123;</span><br><span class="line">                ret+=<span class="string">"L"</span>;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ret+=dominoes[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len<span class="number">-1</span>;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;i&lt;len<span class="number">-1</span>&amp;&amp;dominoes[i]==<span class="string">'.'</span>&amp;&amp;dominoes[i+<span class="number">1</span>]==<span class="string">'L'</span>&amp;&amp;dominoes[i<span class="number">-1</span>]!=<span class="string">'R'</span>)&#123;</span><br><span class="line">                    ret+=<span class="string">"LL"</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;i&lt;len<span class="number">-1</span>&amp;&amp;dominoes[i]==<span class="string">'.'</span>&amp;&amp;dominoes[i<span class="number">-1</span>]==<span class="string">'R'</span>&amp;&amp;dominoes[i+<span class="number">1</span>]!=<span class="string">'L'</span>)&#123;</span><br><span class="line">                    ret+=<span class="string">"R"</span>;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ret+=dominoes[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dominoes[len<span class="number">-2</span>]==<span class="string">'R'</span>&amp;&amp;dominoes[len<span class="number">-1</span>]==<span class="string">'.'</span>)&#123;</span><br><span class="line">                ret+=<span class="string">"R"</span>;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ret+=dominoes[len<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        dominoes = ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第二反应：上面这个过程复杂了。每次都要针对原有状态遍历一遍，产生新的状态，很是繁琐。</p>
<p>从左到右遍历一遍字符串，分一下几种情况（记下第一个LR的位置，然后在下一个字符型LR的时候处理这一段的字符）<br>L—–L 里面‘.’全部填充L；<br>L—–R 里面左边一半填充L，右边一半填充R（注意这里要分类，中间可能会有一个‘.’或者没有）<br>R—–R 里面‘.’全部填充R；<br>R—–L 不用处理；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//从a-b位置的全部变成指定的lr符号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trans</span><span class="params">(<span class="built_in">string</span>&amp; temp,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">char</span> lr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=a;i&lt;=b;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp[i]=lr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">pushDominoes</span><span class="params">(<span class="built_in">string</span> dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> temp=dominoes;<span class="comment">//用于存储结果</span></span><br><span class="line">        <span class="keyword">char</span> temp1=<span class="string">'N'</span>;<span class="comment">//上一个识别的字符是L还是R</span></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">-1</span>;<span class="comment">//上一个识别的字符是位置标号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dominoes.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断此时的字符串是L</span></span><br><span class="line">            <span class="keyword">if</span>(dominoes[i]==<span class="string">'L'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//左侧符号位为N的时候，左侧全部填充L</span></span><br><span class="line">                 <span class="keyword">if</span>(temp1==<span class="string">'N'</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     trans(temp,<span class="number">0</span>,i<span class="number">-1</span>,<span class="string">'L'</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">                <span class="comment">//左侧符号位为L的时候，左侧全部填充L</span></span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span>(temp1==<span class="string">'L'</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     trans(temp,index+<span class="number">1</span>,i<span class="number">-1</span>,<span class="string">'L'</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">                <span class="comment">//左侧符号位为R的时候，靠近左侧填充R，右侧填充L（填充个数为m=(i-index-1)/2）</span></span><br><span class="line">                 <span class="keyword">else</span> </span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">int</span> m=(i-index<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                     trans(temp,index+<span class="number">1</span>,index+m,<span class="string">'R'</span>);</span><br><span class="line">                     trans(temp,i-m,i<span class="number">-1</span>,<span class="string">'L'</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">                 temp1=<span class="string">'L'</span>;</span><br><span class="line">                 index=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时的符号位R</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dominoes[i]==<span class="string">'R'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//上一个符号为R,则填充R，其他情况不用考虑</span></span><br><span class="line">                <span class="keyword">if</span>(temp1==<span class="string">'R'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=index+<span class="number">1</span>)</span><br><span class="line">                        trans(temp,index+<span class="number">1</span>,i<span class="number">-1</span>,<span class="string">'R'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                 temp1=<span class="string">'R'</span>;</span><br><span class="line">                 index=i;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左侧是R到字符串结尾没有处理 需要全部变成R</span></span><br><span class="line">        <span class="keyword">if</span>(temp1==<span class="string">'R'</span>)</span><br><span class="line">            trans(temp,index+<span class="number">1</span>,temp.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="string">'R'</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：brother_of_brother</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/push-dominoes/solution/cxiang-xi-ti-jie-by-brother_of_brother/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h4 id="837-新21点"><a href="#837-新21点" class="headerlink" title="837. 新21点"></a><a href="https://leetcode-cn.com/problems/new-21-game/" target="_blank" rel="noopener">837. 新21点</a></h4><p><strong>题解</strong>：</p>
<h4 id="839-相似字符串组"><a href="#839-相似字符串组" class="headerlink" title="839. 相似字符串组"></a><a href="https://leetcode-cn.com/problems/similar-string-groups/" target="_blank" rel="noopener">839. 相似字符串组</a></h4>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第84场周赛</title>
    <url>/archives/4b1e44f1.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-84/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="832-翻转图像"><a href="#832-翻转图像" class="headerlink" title="832. 翻转图像"></a><a href="https://leetcode-cn.com/problems/flipping-an-image/" target="_blank" rel="noopener">832. 翻转图像</a></h4><p><strong>题解</strong>：根据描述，我们按照描述一步一步来就行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flipAndInvertImage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;A[i].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                A[i][j] =(!A[i][j]); </span><br><span class="line">            &#125;</span><br><span class="line">            reverse(A[i].<span class="built_in">begin</span>(),A[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="833-字符串中的查找与替换"><a href="#833-字符串中的查找与替换" class="headerlink" title="833. 字符串中的查找与替换"></a><a href="https://leetcode-cn.com/problems/find-and-replace-in-string/" target="_blank" rel="noopener">833. 字符串中的查找与替换</a></h4><p>题解：根据描述，有如下想法，对于测试点1，只要找到首个匹配字符位置，末尾字符匹配位置，使用replace函数替换即可。在下轮替换的时候，开始找的位置应为由于插入而带来的字符串长度改变的偏置。</p>
<p>根据这一想法，可以通过前8个测试点。后面的替换位置并不是有序的，因此我们需要把替换位置sort一下。重写一下输入的数据结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp</span>&#123;</span></span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            <span class="built_in">string</span> source;</span><br><span class="line">            <span class="built_in">string</span> target;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(struct tmp a,struct tmp b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a.index&lt;b.index;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findReplaceString</span><span class="params">(<span class="built_in">string</span> &amp;S, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indexes, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; sources, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; targets)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;struct tmp&gt;v(indexes.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;indexes.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            v[i].index = indexes[i];</span><br><span class="line">            v[i].source = sources[i];</span><br><span class="line">            v[i].target = targets[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">int</span> bisa=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;indexes.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="number">0</span>,j,start=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i=<span class="number">0</span>)j = v[i].index;</span><br><span class="line">            <span class="keyword">else</span> j = v[i].index+bisa;</span><br><span class="line">            start=j;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;S.length();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(S[j]!=v[i].source[k])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k==v[i].source.length())&#123;</span><br><span class="line">                S.replace(S.<span class="built_in">begin</span>()+start,S.<span class="built_in">begin</span>()+start+v[i].source.length(),v[i].target);</span><br><span class="line">                <span class="comment">//每次替换带来了偏置</span></span><br><span class="line">                 bisa += v[i].target.length()-v[i].source.length();</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="835-图像重叠"><a href="#835-图像重叠" class="headerlink" title="835. 图像重叠"></a><a href="https://leetcode-cn.com/problems/image-overlap/" target="_blank" rel="noopener">835. 图像重叠</a></h4><p>题解：根据描述，数据量在$0-30$范围内，使用蛮力算法即可。<br>枚举A中出现的1，对于B中出现的1，有相同偏置的位置在记录数组中加一。比如</p>
<table>
<thead>
<tr>
<th align="center">index A</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">index B</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>对于矩阵A(0,0)处的1，B中所有的1(分别位于[(1,1)(1,2),(2,2)]处)，相对于A(0,0)处的偏置分别为[(1,1)(1,2),(2,2)] <strong>下标相减即可</strong></p>
<p>对于矩阵A(0,1)处的1，B中所有的1(分别位于[(1,1)(1,2),(2,2)]处)，相对于A(0,0)处的偏置分别为[(1,0),(1,1),(2,1)]</p>
<p>对于矩阵A(1,1)处的1，B中所有的1(分别位于[(1,1)(1,2),(2,2)]处)，相对于A(0,0)处的偏置分别为[(0,0),(0,1),(1,1)]</p>
<p>对于矩阵A(2,1)处的1，B中所有的1(分别位于[(1,1)(1,2),(2,2)]处)，相对于A(0,0)处的偏置分别为[(-1,0),(-1,1),(0,2)]</p>
<p>统计偏置数组[(1,1)(1,2),(2,2)]，[(1,0)(1,1),(2,1)]，[(0,0),(0,1),(1,1)]，[(-1,0),(-1,1),(0,2)]，可发现(1,1)出现最多，是为3次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">2</span>*N][<span class="number">2</span>*N];</span><br><span class="line">        <span class="built_in">memset</span>(count,<span class="number">0</span>,<span class="keyword">sizeof</span>(count));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">0</span>; i2 &lt; N; ++i2)</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j2 = <span class="number">0</span>; j2 &lt; N; ++j2)</span><br><span class="line">                            <span class="keyword">if</span> (B[i2][j2] == <span class="number">1</span>)</span><br><span class="line">                                count[i-i2 +N][j-j2 +N] += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*N;++j)&#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret,count[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="834-树中距离之和"><a href="#834-树中距离之和" class="headerlink" title="834. 树中距离之和"></a><a href="https://leetcode-cn.com/problems/sum-of-distances-in-tree/" target="_blank" rel="noopener">834. 树中距离之和</a></h4>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第83场周赛</title>
    <url>/archives/a9c25f88.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-83/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="830-较大分组的位置"><a href="#830-较大分组的位置" class="headerlink" title="830. 较大分组的位置"></a><a href="https://leetcode-cn.com/problems/positions-of-large-groups/" target="_blank" rel="noopener">830. 较大分组的位置</a></h4><p><strong>题解</strong>：根据描述，只要设置两个指针$i$，$j$。初始$i$指向第一次出现的字母，$j$指向$i$的后面一个位置，不断增加$j$，使得$i$与$j$之间的字母相同，当$j$指向字母与$i$不同时且$ij$之间的距离大于等于3保存结果，小于3则更新$i$至位置$j$，$j$向后移动一位。</p>
<p>注意如字符串$“aaa”$，上述原则失效，可以在$“aaa”$后增加一个哨兵(一个隐藏的字符)。也可以在最后增加一个判断。当上述循环结束时，$ij$距离大于2即可。以下是个人code。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">largeGroupPositions</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;ret;</span><br><span class="line">        <span class="keyword">if</span>(!S.length()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>,j = <span class="number">1</span>;i&lt;S.length()&amp;&amp;j&lt;S.length();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==S[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>((j-i)&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                    ret.emplace_back(&#123;i,j<span class="number">-1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                i = j;</span><br><span class="line">                j = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((j-i)&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            ret.emplace_back(&#123;i,j<span class="number">-1</span>&#125;);&#125;</span><br><span class="line">        <span class="keyword">return</span> ret;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="831-隐藏个人信息"><a href="#831-隐藏个人信息" class="headerlink" title="831. 隐藏个人信息"></a><a href="https://leetcode-cn.com/problems/masking-personal-information/" target="_blank" rel="noopener">831. 隐藏个人信息</a></h4><p><strong>题解</strong>：根据描述，我们只需要根据是否有@符号，设计两个函数maskMail与maskPhone。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">maskPII</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;    	</span><br><span class="line">    transform(S.<span class="built_in">begin</span>(),S.<span class="built_in">end</span>(),S.<span class="built_in">begin</span>(),::<span class="built_in">tolower</span>);</span><br><span class="line">    <span class="comment">//转换所有字符变为小写</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:S)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="string">'@'</span>)&#123;</span><br><span class="line">                <span class="comment">//当有@符号，用maskMail</span></span><br><span class="line">                <span class="built_in">string</span> ret = maskMail(S);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//没有@符号，用maskPhone</span></span><br><span class="line">        <span class="built_in">string</span> ret = maskPhone(S);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">maskMail</span><span class="params">(<span class="built_in">string</span> S)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;S.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[j]==<span class="string">'@'</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> star = <span class="string">"*****"</span>;</span><br><span class="line">        star.insert(star.<span class="built_in">begin</span>(),S[<span class="number">0</span>]);</span><br><span class="line">        star.insert(star.<span class="built_in">end</span>(),S[j<span class="number">-1</span>]);</span><br><span class="line">        <span class="built_in">string</span> ret=star+S.substr(j,S.length()-j);</span><br><span class="line">        <span class="keyword">return</span> ret;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">maskPhone</span><span class="params">(<span class="built_in">string</span> &amp;S)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:S)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="string">'0'</span>&amp;&amp;i&lt;=<span class="string">'9'</span>) tmp.emplace_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        由于电话号码的数字只有10-13位，根据数字长度，</span></span><br><span class="line"><span class="comment">        加上不同的前缀即可。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">size</span>()==<span class="number">10</span>)&#123;</span><br><span class="line">            ret+=<span class="string">"***-***-"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">6</span>;i&lt;<span class="number">10</span>;i++) ret+=tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">size</span>()==<span class="number">11</span>)&#123;</span><br><span class="line">            ret+=<span class="string">"+*-***-***-"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&lt;<span class="number">11</span>;i++) ret+=tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">size</span>()==<span class="number">12</span>)&#123;</span><br><span class="line">            ret+=<span class="string">"+**-***-***-"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">8</span>;i&lt;<span class="number">12</span>;i++) ret+=tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">size</span>()==<span class="number">13</span>)&#123;</span><br><span class="line">            ret+=<span class="string">"+***-***-***-"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">9</span>;i&lt;<span class="number">13</span>;i++) ret+=tmp[i];</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="829-连续整数求和"><a href="#829-连续整数求和" class="headerlink" title="829. 连续整数求和"></a><a href="https://leetcode-cn.com/problems/consecutive-numbers-sum/" target="_blank" rel="noopener">829. 连续整数求和</a></h4><p>题解：根据题意，</p>
<p>第一反应：蛮力遍历求和，看是否有满足连续的整数和。<br>第二反应：使用等差数列求和公式，设求和为$N$，求和起点为$x$，一共有$k$个数参与求和，那么有<br>$$N = (x+1)+(x+2)+…+(x+k)=\frac{(2x+k+1)k}{2}$$</p>
<p>解得$$x = \frac{1}{2}(\frac{2N}{k} - k - 1)$$，至此，只要枚举$k(k&gt;=1)$，并且使得$x$为整数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">consecutiveNumbersSum</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2N = k(2x + k + 1)</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>*N; ++k)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * N % k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = <span class="number">2</span> * N / k - k - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (y % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span>)</span><br><span class="line">                    ret++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三反应：减小$k$的枚举范围。<br>$$N = (x+1)+(x+2)+…+(x+k)=\frac{(2x+k+1)k}{2}$$<br>在该式中，明显可观察到$k&lt;2x+k+1$，由此我们可用小学二年级学过的放缩大致确定$k&lt;\sqrt{2n}$。</p>
<p>第四反应:</p>
<p><img src="/archives/a9c25f88/1.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">consecutiveNumbersSum</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; N &gt; <span class="number">0</span>; N-=i, i++)</span><br><span class="line">        ans += (N % i == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第四种解法可以看作另一种形式的枚举吧，优美且简洁。</span></span><br><span class="line">作者：pris_bupt</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/consecutive-numbers-sum/solution/c-ji-jian-by-pris_bupt/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h4 id="828-统计子串中的唯一字符"><a href="#828-统计子串中的唯一字符" class="headerlink" title="828. 统计子串中的唯一字符"></a><a href="https://leetcode-cn.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/" target="_blank" rel="noopener">828. 统计子串中的唯一字符</a></h4><p>题解：待填坑（我不会，哭唧唧）</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第184场周赛</title>
    <url>/archives/c4e3d004.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-184/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="5380-数组中的字符串匹配"><a href="#5380-数组中的字符串匹配" class="headerlink" title="5380. 数组中的字符串匹配"></a><a href="https://leetcode-cn.com/problems/string-matching-in-an-array/" target="_blank" rel="noopener">5380. 数组中的字符串匹配</a></h4><p><strong>题解</strong>：根据描述，加上简单题，以及数据规模很小，不妨有按照题目描述解法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.length()&lt;b.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">stringMatching</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sort(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;words.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> <span class="built_in">begin</span>=<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>((<span class="built_in">begin</span>=words[j].<span class="built_in">find</span>(words[i],<span class="built_in">begin</span>+<span class="number">1</span>))!=<span class="built_in">string</span>::npos)</span><br><span class="line">                &#123;<span class="comment">//此句为字符串匹配</span></span><br><span class="line">                    ret.push_back(words[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5381-查询带键的排列"><a href="#5381-查询带键的排列" class="headerlink" title="5381. 查询带键的排列"></a><a href="https://leetcode-cn.com/problems/queries-on-a-permutation-with-key/" target="_blank" rel="noopener">5381. 查询带键的排列</a></h4><p><strong>题解</strong>：根据描述，有了啊，有了啥？有了答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">processQueries</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;p;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)p.push_back(i);<span class="comment">//根据描述生成数组p</span></span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ret;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queries.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">           <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(),queries[i]);</span><br><span class="line">           <span class="keyword">int</span> tmp = *it;<span class="comment">//1.保存移动的值</span></span><br><span class="line">           p.erase(it);<span class="comment">//2. 删掉</span></span><br><span class="line">           ret.push_back(it-p.<span class="built_in">begin</span>());<span class="comment">//3. 插到最前面</span></span><br><span class="line">           p.insert(p.<span class="built_in">begin</span>(),tmp);<span class="comment">//</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1410-HTML-实体解析器"><a href="#1410-HTML-实体解析器" class="headerlink" title="1410. HTML 实体解析器"></a><a href="https://leetcode-cn.com/problems/html-entity-parser/" target="_blank" rel="noopener">1410. HTML 实体解析器</a></h4><p><strong>题解</strong>：本次周赛前三题都是模拟题呢？没有啥子变通，根据题意模拟就行啦，自己的代码功底（API）熟悉程度不行啊，哭唧唧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">entityParser</span><span class="params">(<span class="built_in">string</span> <span class="built_in">text</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">char</span>&gt;m = &#123;&#123;<span class="string">"&amp;gt"</span>,<span class="string">'&gt;'</span>&#125;,&#123;<span class="string">"&amp;lt"</span>,<span class="string">'&lt;'</span>&#125;,&#123;<span class="string">"&amp;amp"</span>,<span class="string">'&amp;'</span>&#125;,&#123;<span class="string">"&amp;quot"</span>,<span class="string">'"'</span>&#125;,&#123;<span class="string">"&amp;apos"</span>,<span class="string">'\''</span>&#125;,&#123;<span class="string">"&amp;frasl"</span>,<span class="string">'/'</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">text</span>.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">text</span>[i]!=<span class="string">'&amp;'</span>) ret+=<span class="built_in">text</span>[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">string</span> sub = <span class="built_in">text</span>.substr(i,<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j:m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sub==j.first)&#123;</span><br><span class="line">                        flag = <span class="number">1</span>;</span><br><span class="line">                        ret+=j.second;</span><br><span class="line">                        i+=<span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                sub = <span class="built_in">text</span>.substr(i,<span class="number">4</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j:m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sub==j.first)&#123;</span><br><span class="line">                        flag=<span class="number">1</span>;</span><br><span class="line">                        ret+=j.second;</span><br><span class="line">                        i+=<span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                sub = <span class="built_in">text</span>.substr(i,<span class="number">5</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j:m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sub==j.first)&#123;</span><br><span class="line">                        flag=<span class="number">1</span>;</span><br><span class="line">                        ret+=j.second;</span><br><span class="line">                        i+=<span class="number">5</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sub = <span class="built_in">text</span>.substr(i,<span class="number">6</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j:m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sub==j.first)&#123;</span><br><span class="line">                        flag =<span class="number">1</span>;</span><br><span class="line">                        ret+=j.second;</span><br><span class="line">                        i+=<span class="number">6</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag ==<span class="number">0</span>) ret+=<span class="string">'&amp;'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5383-给-N-x-3-网格图涂色的方案数"><a href="#5383-给-N-x-3-网格图涂色的方案数" class="headerlink" title="5383. 给 N x 3 网格图涂色的方案数"></a><a href="https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid/" target="_blank" rel="noopener">5383. 给 N x 3 网格图涂色的方案数</a></h4><p>题解：先看图</p>
<p><img src="/archives/c4e3d004/1.png" alt></p>
<p>根据上图，可以将排列情况分为两种，ABA，ABC，前者颜色有重复，后者无，在这两种下面再添加元素有这么12种选择</p>
<p>ABC  ACB BAC BCA  CAB CBA  ABA ACA BAB BCB CAC CBC</p>
<p>可分别加入到下面的如表格所示</p>
<table>
<thead>
<tr>
<th align="center">ABA</th>
<th align="center">ABC</th>
</tr>
</thead>
<tbody><tr>
<td align="center">unrepeat：BAC</td>
<td align="center">unrepeat：BCA</td>
</tr>
<tr>
<td align="center">unrepeat：CAB</td>
<td align="center">unrepeat：CAB</td>
</tr>
<tr>
<td align="center">unrepeat：BAB</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">repeat：BCB</td>
<td align="center">repeat：BAB</td>
</tr>
<tr>
<td align="center">repeat：CAC</td>
<td align="center">repeat：BCB</td>
</tr>
</tbody></table>
<p>在形如ABA这样的下面只能由3种unrepeat填充，2种repeat填充</p>
<p>在形如ABC这样的下面只能由2种unrepeat填充，2种repeat填充</p>
<p>每次填充依赖选择，当前可填充数目为</p>
<p>$$ repeat_n=3×unrepeat_{n-1}+2×repeat_{n-1}$$</p>
<p>$$ unrepeat_n=2×unrepeat_{n-1}+2×repeat_{n-1}$$</p>
<p>总结好规律后有下面代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numOfWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">long</span> m = <span class="number">6</span>,k = <span class="number">6</span>;<span class="comment">//k，m表示上一层repeat，unrepeat</span></span><br><span class="line">        <span class="keyword">long</span> repeat,unrepeat;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            repeat = (<span class="number">2</span>*(k+m))%<span class="number">1000000007</span>;</span><br><span class="line">            unrepeat = (<span class="number">3</span>*m+<span class="number">2</span>*k)%<span class="number">1000000007</span>;</span><br><span class="line">            m = unrepeat;</span><br><span class="line">            k = repeat;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (unrepeat+repeat)%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>VM下使用Kali及其后续</title>
    <url>/archives/54abd342.html</url>
    <content><![CDATA[<h3 id="VM下kali的安装"><a href="#VM下kali的安装" class="headerlink" title="VM下kali的安装"></a>VM下kali的安装</h3><p>直接去kali官网下载对应VM文件即可<a href="https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/" target="_blank" rel="noopener">传送门</a>，下载完成以后，直接解压到某个文件夹，用VM打开即可。</p>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><a id="more"></a>

<p>成功打开以后，全是英文界面，我不是很喜欢。把他弄成中文界面。</p>
<ol>
<li><p>打开kali的浏览器，输入一些关键字搜索，会发现不能显示中文，于是去解决乱码问题。</p>
</li>
<li><p>新建一个root用户，输入如下：sudo passwd root ,之后按照英文提示输入，切到root</p>
</li>
<li><p>更新源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/apt/sources.list</span><br><span class="line"><span class="comment"># 编辑源文件</span></span><br><span class="line"><span class="comment"># 这里使用的是vi编辑器，打开后按键盘字母i一下，变成insert模式，可编辑模式，</span></span><br><span class="line"><span class="comment">#deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span></span><br><span class="line"><span class="comment">#deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span></span><br><span class="line"><span class="comment">#将这两行加入到文件末尾，然后按esc键一次，输入（:wq）保存并退出。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新源，并更新软件依赖，安装中文字体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get clean</span><br><span class="line"><span class="comment">#更新源并更新软件。</span></span><br><span class="line">dpkg-reconfigure locales</span><br><span class="line"><span class="comment">#进入图形界面，选中en_US.UTF-8 UTF-8和zh_CN.UTF-8 UTF-8（空格是选择，tab是切换，*是选中）并将en_US.UTF-8选为默认。</span></span><br><span class="line">apt-get install xfonts-intl-chinese</span><br><span class="line">apt-get install ttf-wqy-microhei</span><br><span class="line"><span class="comment"># 安装中文字体</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>完成以后重启，在终端输入reboot好像没啥用，手动在虚拟机里面重启。</p>
</li>
</ol>
<h3 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update <span class="comment">#更新系统 </span></span><br><span class="line">apt-get dist-upgrade <span class="comment">#升级系统 </span></span><br><span class="line">apt-get install fcitx fcitx-googlepinyin <span class="comment">#google拼音</span></span><br></pre></td></tr></table></figure>

<p>执行完毕后，搜索fcitx configuration，添加谷歌拼音即可。</p>
<h3 id="安装新的软件"><a href="#安装新的软件" class="headerlink" title="安装新的软件"></a>安装新的软件</h3><p>apt-get install xxxx，即可安装</p>
<p>apt-get remove xxxx，即可卸载</p>
<p>一般完成以后是打不开的，因此需要修改一些东西。</p>
<p>去/usr/share/applications/下找到xxxx.desktop文件，用文本编辑器打开编辑，在Exex后修改为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Exec=/usr/bin/xxxx %U --no-sandbox</span><br></pre></td></tr></table></figure>

<h3 id="window10-加kali双系统"><a href="#window10-加kali双系统" class="headerlink" title="window10 加kali双系统"></a>window10 加kali双系统</h3><p>正常安装，分区再安装。没错误最好</p>
<p>遇到未安装启动引导器，其原因可能是您选择了不安装或者您的特殊硬件体系尚不支持启动引导器，您需要手动启动/dev/sda3分区上的/vmlinuz内核，并且以root=/dev/sda3作为内核参数，记住这个出错。</p>
<p><img src="/archives/54abd342/1.jpg" alt></p>
<p>解决办法：进入到boot界面，找一下add boot options</p>
<p><img src="/archives/54abd342/2.jpg" alt></p>
<p>之后找到一个grubx64.efi文件，加入</p>
<p><img src="/archives/54abd342/3.jpg" alt></p>
<p>之后重启进入kali，就可看到黑框grub命令行界面了。输入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">linux /boot/vmlinuz-xxx-xxx root=/dev/sda3 nouveau.modeset=<span class="number">0</span></span><br><span class="line"><span class="comment">//解释，vmlinuz后面一串字符，输入/boot/vmlinuz后按tab自动填充即可</span></span><br><span class="line"><span class="comment">//root=/dev/sda3是当初出错的时候提醒你的</span></span><br><span class="line">initrd /boot/initrd.img-xxx-xxxx</span><br><span class="line"><span class="comment">//这个xxxx也是按tab填充</span></span><br><span class="line">boot</span><br><span class="line"><span class="comment">//重启会进入到kali了，美滋滋</span></span><br><span class="line"><span class="comment">//之后还有呢</span></span><br><span class="line">update-grub</span><br><span class="line"><span class="comment">//上面update-grub自动修复引导</span></span><br><span class="line"><span class="comment">//错误是因为独立显卡的问题，还需要修改一个文件</span></span><br><span class="line">vi /boot/grub/grub.cfg</span><br><span class="line"><span class="comment">//找到禁用N卡的参数，修改 quiet flash 为quiet nouveau.modeset=0</span></span><br><span class="line"><span class="comment">//大功告成。</span></span><br></pre></td></tr></table></figure>

<p><img src="/archives/54abd342/4.jpg" alt></p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title>cv</title>
    <url>/archives/b66ffe92.html</url>
    <content><![CDATA[<h1 id="爬取QQ空间3000万用户，玩玩大数据分析"><a href="#爬取QQ空间3000万用户，玩玩大数据分析" class="headerlink" title="爬取QQ空间3000万用户，玩玩大数据分析"></a>爬取QQ空间3000万用户，玩玩大数据分析</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>现在21世纪，有人称之为大数据时代，谁有数据量大的数据，谁能够从海量数据中提取到有用信息，并能够将其转换为资本，谁就取得了互联网的地位。</p>
<a id="more"></a>

<p>互联网数据是由生活在网络上的每一个用户所产生的，用户在互联网上的活动会被记录下来，这就是数据，海量用户，有着海量数据。这些数据被利用，分析，与各种各样的广告联系在一起，进而把这些广告推送给用户，这些推送的广告都是用户的网络行为分析出的结果。</p>
<p>QQ上活跃这大量的用户，QQ空间里面记录了许多人的日常，这些就是数据。在日常使用QQ空间的时候，会偶尔点击给我们好友点赞的朋友，之后我们就能看到我们好友的好友的空间，依次类推，我们可以看到海量信息。</p>
<h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><p>软件：python3，redis，MongoDB</p>
<p>python库：requests、BeautifulSoup、multiprocessing、selenium、itertools、BitVector、pymongo</p>
<p>MongoDB安装及配置：</p>
<pre><code>1. 去[官网](https://www.mongodb.com/download-center/community)下载
 2. 下载好.msi文件，安装</code></pre><p><img src="/archives/b66ffe92/1.png" alt></p>
<p><img src="/archives/b66ffe92/2.png" alt></p>
<p><img src="/archives/b66ffe92/3.png" alt></p>
<p><img src="/archives/b66ffe92/4.png" alt></p>
<p><img src="/archives/b66ffe92/5.png" alt></p>
<ol start="4">
<li>软件安装在D:\MongoDB这个目录下，需要在D盘符新建一个D:\data\db这样目录，之后在D:\MongoDB\Server\4.2\bin这目录下cmd运行mongodb.exe即可</li>
<li>可视化mongoDB，用自带的MongoDB Compass Community这个可视化工具，连接以后，</li>
</ol>
<p><img src="/archives/b66ffe92/6.png" alt></p>
<p>成功连接。</p>
<p>redis 安装及配置</p>
<ol>
<li><p>下载安装<a href="https://github.com/dmajkic/redis/downloads" target="_blank" rel="noopener">redis</a>。把下载好的redis的zip文件解压到D:\redis-2.4.5-win32-win64\</p>
</li>
<li><p>在D:\redis-2.4.5-win32-win64\64bit这目录下，cmd命令运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server.exe redis.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>再在上面目录下，cmd命令执行 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli.exe -h 127.0.0.1 -p 6379 -a 123456</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>无界面浏览器配置</p>
]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习</title>
    <url>/archives/83b461a0.html</url>
    <content><![CDATA[<h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><p>string的初始化</p>
<table>
<thead>
<tr>
<th>初始化方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>string s1</td>
<td>默认初始化，s1为一空串</td>
</tr>
<tr>
<td>string s2(s1)</td>
<td>s2是s1的一个副本，直接初始化</td>
</tr>
<tr>
<td>string s2=s1</td>
<td>等价s2(s1)，拷贝初始化</td>
</tr>
<tr>
<td>string s3(“value”)</td>
<td>s3是字面值”value”的副本，不包括最后的空字符</td>
</tr>
<tr>
<td>string s3 = “value”</td>
<td>等价于s3(“value”)</td>
</tr>
<tr>
<td>string s4(n,’c’)</td>
<td>用连续n个字符初始化字符串s4，直接初始化</td>
</tr>
</tbody></table>
<p>string 类对象上的操作</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>os&lt;&lt;s</td>
<td>将s写到输出流os当中，返回os</td>
</tr>
<tr>
<td>is&gt;&gt;s</td>
<td>从is中读取字符串赋给s,字符串以空白分隔，返回is</td>
</tr>
<tr>
<td>getlin(is,s)</td>
<td>从is中读取一行赋给S，返回is</td>
</tr>
<tr>
<td>s.empty()</td>
<td>s为空返回true,否则返回false</td>
</tr>
<tr>
<td>s.size()</td>
<td>返回s中字符的个数，返回的类型为string::size_type</td>
</tr>
<tr>
<td>s[n]</td>
<td>返回s中第n个字符，位置n从0计起</td>
</tr>
<tr>
<td>s1+s2</td>
<td>返回s1和s2连接后的结果</td>
</tr>
<tr>
<td>s1=s2</td>
<td>用s2的副本代替si中原来的字符</td>
</tr>
<tr>
<td>s1!=s2</td>
<td>判断s1和s2中所含的字符是否一样</td>
</tr>
<tr>
<td>s1==s2</td>
<td>同上</td>
</tr>
<tr>
<td>s1(&lt;,&lt;=,&gt;,&gt;=)</td>
<td>字典序比较</td>
</tr>
</tbody></table>
<h2 id="模板vector"><a href="#模板vector" class="headerlink" title="模板vector"></a>模板vector</h2><p>vector&lt;的初始化&gt;</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>vector<T> v1</T></td>
<td>v1为空，默认初始化</td>
</tr>
<tr>
<td>vector<T> v2(v1)</T></td>
<td>v2包含v1的所有元素</td>
</tr>
<tr>
<td>vector<T>v2 = v1</T></td>
<td>等价于vector<T>v2(v1)</T></td>
</tr>
<tr>
<td>vector<T>v3(n,val)</T></td>
<td>初始化了含n个val的vector</td>
</tr>
<tr>
<td>vector<T>v4(n)</T></td>
<td>vector大小为n，可存n个T</td>
</tr>
<tr>
<td>vector<T>v5{a,b,c,…}</T></td>
<td>按a,b,c,…初始化，并且值也确定</td>
</tr>
<tr>
<td>vector<T>v6 = {a,b,c,…}</T></td>
<td>等价于vector<T>{a,b,c,…}</T></td>
</tr>
<tr>
<td>vector<T>v7 = {10,T}</T></td>
<td>初始化了10个T</td>
</tr>
</tbody></table>
<p>vector上的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>v.push_back(T)</td>
<td>向v的末尾添加元素T</td>
</tr>
<tr>
<td>v.size()</td>
<td>v中所含元素个数</td>
</tr>
<tr>
<td>v.empty()</td>
<td>v是否为空</td>
</tr>
<tr>
<td>支持类似数组操作按秩访问</td>
<td></td>
</tr>
</tbody></table>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>stack的初始化</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>stack<int> stack1;</int></td>
<td>初始化一个栈，默认为双端队列</td>
</tr>
<tr>
<td>stack&lt;int,vector<int>&gt;stack2;</int></td>
<td>变成向量</td>
</tr>
<tr>
<td>stack&lt;int,list<int>&gt; stack3</int></td>
<td>链表</td>
</tr>
</tbody></table>
<p>stack上常用操作</p>
<table>
<thead>
<tr>
<th>返回值 操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>bool empty()</td>
<td>判断栈是否为空</td>
</tr>
<tr>
<td>void pop()</td>
<td>弹出栈顶元素，</td>
</tr>
<tr>
<td>void push(const T&amp; el)</td>
<td>将元素el压入栈顶，constT&amp;表示类型</td>
</tr>
<tr>
<td>size_type size()</td>
<td>栈中元素数目</td>
</tr>
<tr>
<td>T&amp; top()</td>
<td>栈顶元素</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>hello-world</title>
    <url>/archives/b1d4025b.html</url>
    <content><![CDATA[<h1 id="长恨歌"><a href="#长恨歌" class="headerlink" title="长恨歌"></a>长恨歌</h1><h2 id="唐代：白居易"><a href="#唐代：白居易" class="headerlink" title="唐代：白居易"></a>唐代：白居易</h2><p>汉皇重色思倾国，御宇多年求不得。<br>杨家有女初长成，养在深闺人未识。<br>天生丽质难自弃，一朝选在君王侧。<br>回眸一笑百媚生，六宫粉黛无颜色。<br>春寒赐浴华清池，温泉水滑洗凝脂。<br>侍儿扶起娇无力，始是新承恩泽时。<br>云鬓花颜金步摇，芙蓉帐暖度春宵。<br>春宵苦短日高起，从此君王不早朝。</p>
<a id="more"></a>

<p>承欢侍宴无闲暇，春从春游夜专夜。<br>后宫佳丽三千人，三千宠爱在一身。<br>金屋妆成娇侍夜，玉楼宴罢醉和春。<br>姊妹弟兄皆列土，可怜光彩生门户。<br>遂令天下父母心，不重生男重生女。<br>骊宫高处入青云，仙乐风飘处处闻。<br>缓歌慢舞凝丝竹，尽日君王看不足。<br>渔阳鼙鼓动地来，惊破霓裳羽衣曲。</p>
<p>九重城阙烟尘生，千乘万骑西南行。<br>翠华摇摇行复止，西出都门百余里。<br>六军不发无奈何，宛转蛾眉马前死。<br>花钿委地无人收，翠翘金雀玉搔头。<br>君王掩面救不得，回看血泪相和流。<br>黄埃散漫风萧索，云栈萦纡登剑阁。<br>峨嵋山下少人行，旌旗无光日色薄。<br>蜀江水碧蜀山青，圣主朝朝暮暮情。</p>
<p>行宫见月伤心色，夜雨闻铃肠断声。<br>天旋地转回龙驭，到此踌躇不能去。<br>马嵬坡下泥土中，不见玉颜空死处。<br>君臣相顾尽沾衣，东望都门信马归。<br>归来池苑皆依旧，太液芙蓉未央柳。<br>芙蓉如面柳如眉，对此如何不泪垂。<br>春风桃李花开日，秋雨梧桐叶落时。<br>西宫南内多秋草，落叶满阶红不扫。(花开日 一作：花开夜；南内 一作：南苑)</p>
<p>梨园弟子白发新，椒房阿监青娥老。<br>夕殿萤飞思悄然，孤灯挑尽未成眠。<br>迟迟钟鼓初长夜，耿耿星河欲曙天。<br>鸳鸯瓦冷霜华重，翡翠衾寒谁与共。<br>悠悠生死别经年，魂魄不曾来入梦。<br>临邛道士鸿都客，能以精诚致魂魄。<br>为感君王辗转思，遂教方士殷勤觅。<br>排空驭气奔如电，升天入地求之遍。</p>
<p>上穷碧落下黄泉，两处茫茫皆不见。<br>忽闻海上有仙山，山在虚无缥渺间。<br>楼阁玲珑五云起，其中绰约多仙子。<br>中有一人字太真，雪肤花貌参差是。<br>金阙西厢叩玉扃，转教小玉报双成。<br>闻道汉家天子使，九华帐里梦魂惊。<br>揽衣推枕起徘徊，珠箔银屏迤逦开。<br>云鬓半偏新睡觉，花冠不整下堂来。</p>
<p>风吹仙袂飘飖举，犹似霓裳羽衣舞。<br>玉容寂寞泪阑干，梨花一枝春带雨。(阑 通：栏)<br>含情凝睇谢君王，一别音容两渺茫。<br>昭阳殿里恩爱绝，蓬莱宫中日月长。<br>回头下望人寰处，不见长安见尘雾。<br>惟将旧物表深情，钿合金钗寄将去。<br>钗留一股合一扇，钗擘黄金合分钿。<br>但教心似金钿坚，天上人间会相见。</p>
<p>临别殷勤重寄词，词中有誓两心知。<br>七月七日长生殿，夜半无人私语时。<br>在天愿作比翼鸟，在地愿为连理枝。<br>天长地久有时尽，此恨绵绵无绝期。</p>
]]></content>
  </entry>
</search>
