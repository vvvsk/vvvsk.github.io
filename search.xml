<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Crawl Dy</title>
    <url>/archives/ffc3f523.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>抖音是一个很好的平台，森罗万象，大到央视新闻，小到普通老百姓日常。上面的活跃用户的粉丝数量，有如恒河沙数，也有如寥若晨星。</p>
<p>抖音的推荐算法会逐渐决定你将要看什么，滑稽吧？你的观看选择，从这个角度看，居然是他人决定，而不是自己去寻找🤣。自己去寻找的不好吗？人懒了吗？</p>
<p>本文建立抖音推荐算法的基础上，爬取一些自己喜欢的东西，当然是小姐姐了。一开口👨就知道是老色批了，又在ghs，👨‍✈️拷走。👨这边前期刷抖音的时候，在一下小姐姐视频上停留时间过长，抖音app会自动判定你喜欢这类视频，或者在刷到漂亮小姐姐，点个like，后面还是会推送这类视频。于是不需要使用人脸判定接口了，麻烦。</p>
<p>先上结果图：</p>
<a id="more"></a>

<p><img src="/archives/ffc3f523/17.png" alt></p>
<p><img src="/archives/ffc3f523/16.png" alt></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>一款安卓模拟器，我用的是<a href="https://www.yeshen.com/" target="_blank" rel="noopener">夜神模拟器</a></li>
<li>抓包工具 <a href="https://www.telerik.com/download/fiddler" target="_blank" rel="noopener">fiddle</a></li>
<li>python代码编辑器</li>
</ol>
<h2 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h2><ol>
<li><p>配置fiddle</p>
<p>打开fiddle，在option里设置如下</p>
<p><img src="/archives/ffc3f523/1.png" alt></p>
<p><img src="/archives/ffc3f523/2.png" alt></p>
<p>重启fiddler。</p>
</li>
<li><p>配置模拟器</p>
<p>配置网络，查看本机ip，为192.168.0.106</p>
<p><img src="/archives/ffc3f523/3.png" alt></p>
<p>配置模拟器，保存。</p>
<p><img src="/archives/ffc3f523/4.png" alt></p>
<p>配置证书:在浏览器中输入设置的ip:端口，我的是192.168.0.106:8888，就会打开fiddler的页面。然后点击fiddlerRoot certificate，安装证书。如果没有下面，重启一下fiddle。</p>
<p><img src="/archives/ffc3f523/5.png" alt></p>
<p>点击以后开始下载，在任务栏点击安装，设置名称，设置锁屏手势。</p>
<p><img src="/archives/ffc3f523/6.png" alt></p>
</li>
<li><p>打开抖音，如图所示，fiddle有些花眼。红框是需要抓取的进程数据。</p>
<p><img src="/archives/ffc3f523/7.png" alt></p>
</li>
<li><p>于是定义显示规则，只显示这个process，不显示其他进程，在其他进程上右键，filter now ，hide’XXXXX’</p>
<p><img src="/archives/ffc3f523/8.png" alt></p>
</li>
<li><p>分析抓包数据，我们需要找到json数据。在滑动抖音后，fiddle里面就一个json 包，还非常小，点开后啥数据也没有。</p>
<p><img src="/archives/ffc3f523/9.png" alt></p>
<p>经过我百般探索，在模拟器抖音点击用户头像，就会有较大body 的json出现。</p>
<p><img src="/archives/ffc3f523/10.png" alt></p>
<p>这个json数据包很大吧，打开分析吧。</p>
</li>
<li><p>打开后，仔细比较，这就是用户所有数据了。</p>
<p><img src="/archives/ffc3f523/11.png" alt></p>
<p>仔细找找，在video里就能找到视频，把url_list里链接复制到浏览器就能够播放。</p>
<p><img src="/archives/ffc3f523/12.png" alt></p>
</li>
<li><p>已经完成一大半了，接下来就是批量获取json数据，然后解析json数据中的video链接，下载到本地。</p>
<p>批量获取json数据，在fiddle定义script rule。如图所示，然后点击 save script。</p>
<p><img src="/archives/ffc3f523/13.png" alt></p>
<p>下面是代码，fielname变量指向的目录<code>D:/抖音/raw_data</code>手动生成。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">OnBeforeResponse</span>(<span class="params">oSession: Session</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Hide304s &amp;&amp; oSession.responseCode == <span class="number">304</span>) &#123;</span><br><span class="line">            oSession[<span class="string">"ui-hide"</span>] = <span class="string">"true"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (oSession.uriContains(<span class="string">"https://aweme.snssdk.com/aweme/v1/aweme/post/"</span>)||oSession.uriContains(<span class="string">"https://api3-core-c-lf.amemv.com/aweme/v1/aweme/post/"</span>))&#123;</span><br><span class="line">            <span class="keyword">var</span> strBody=oSession.GetResponseBodyAsString();</span><br><span class="line">            <span class="keyword">var</span> sps = oSession.PathAndQuery.slice(<span class="number">-58</span>,);</span><br><span class="line">            <span class="keyword">var</span> filename = <span class="string">"D:/抖音/raw_data"</span> + <span class="string">"/"</span> + sps + <span class="string">".json"</span>;  <span class="comment">//目录需要手动去生成。</span></span><br><span class="line">            <span class="keyword">var</span> curDate = <span class="keyword">new</span> <span class="built_in">Date</span>();   </span><br><span class="line">            <span class="keyword">var</span> sw : System.IO.StreamWriter;  </span><br><span class="line">            <span class="keyword">if</span> (System.IO.File.Exists(filename))&#123;  </span><br><span class="line">                sw = System.IO.File.AppendText(filename);  </span><br><span class="line">                sw.Write(strBody);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>&#123;  </span><br><span class="line">                sw = System.IO.File.CreateText(filename);  </span><br><span class="line">                sw.Write(strBody);  </span><br><span class="line">            &#125;  	</span><br><span class="line">            sw.Close();  </span><br><span class="line">            sw.Dispose();  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来，只需要在模拟器里滑动，点击用户，就可以看到在定义的目录里有很多json文件。</p>
<p><img src="/archives/ffc3f523/14.png" alt></p>
<ol start="8">
<li><p>手动划肯定不得行，于是就需要像按键精灵一样的东西，于是乎，就可以用夜神模拟器里面的操作录制。需要注意的是，有的用户头像上会有直播，点进去会跳到用户直播界面，我也没得办法，可以点击左下方的@user按钮，但按钮位置不太固定。也不好用。</p>
<p>我的解决办法是深夜进行这个操作录制，那时没得人在直播。正常模拟点击即可。</p>
<p><img src="/archives/ffc3f523/15.png" alt></p>
</li>
<li><p>解析json. 在<code>D:/抖音/</code>下新建crawl.py。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,json,requests</span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36'</span>&#125;</span><br><span class="line"></span><br><span class="line">videos_list = os.listdir(<span class="string">'D:/抖音/raw_data/'</span>)</span><br><span class="line">count = <span class="number">0</span> <span class="comment"># 统计下载视频数量</span></span><br><span class="line"><span class="keyword">for</span> videos <span class="keyword">in</span> videos_list:</span><br><span class="line">    json_data = open(<span class="string">'./raw_data/&#123;&#125;'</span>.format(videos),encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        content = json.load(json_data)[<span class="string">'aweme_list'</span>]</span><br><span class="line">        title = content[<span class="number">0</span>][<span class="string">'author'</span>][<span class="string">'nickname'</span>] <span class="comment">#小姐姐名称</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">r'#\/:*\@#?"&lt;&gt;|/'</span>:</span><br><span class="line">            title = title.replace(c,<span class="string">''</span>)</span><br><span class="line">        print(title,<span class="string">":可爱又美丽的我正在去往您的硬盘里\n"</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'./VIDEO/'</span>+title):</span><br><span class="line">            os.makedirs(<span class="string">'./VIDEO/'</span>+title,) <span class="comment"># 建立以小姐姐名称的文件夹</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> video <span class="keyword">in</span> content: </span><br><span class="line">            video_name = video[<span class="string">'desc'</span>]</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">r'#\/:*\@#?"&lt;&gt;|/'</span>:</span><br><span class="line">                video_name = video_name.replace(c,<span class="string">''</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                video_url = video[<span class="string">'video'</span>][<span class="string">'play_addr'</span>][<span class="string">'url_list'</span>][<span class="number">0</span>]</span><br><span class="line">                print(video_name)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                videoMp4 =  requests.request(<span class="string">'get'</span>,video_url,headers=headers).content </span><br><span class="line">                <span class="keyword">with</span> open(<span class="string">'./VIDEO/&#123;&#125;/&#123;&#125;.mp4'</span>.format(title,video_name),<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(videoMp4)</span><br><span class="line">                    print(<span class="string">"可爱又美丽的我已经在硬盘了"</span>)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">         <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">'--------------------------------'</span>)</span><br><span class="line">print(<span class="string">"一共&#123;&#125;有个在您的硬盘里呢"</span>.format(count))</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这些小姐姐们，都是以自己美颜后的模样呈现在视频前，在视频前摆几个动作而已，没看到有啥子与众不同的才艺，或者说闪光点。又或者说，这才是我们大众喜欢的女性，不然怎么一个个的好几万like。人均校花🤠。</p>
<p>小姐姐们确实挺好看的，不过不太符合我的审美观。萝卜青菜，各有所爱。👨希望每个人的另一半都是自己眼里最美的啦。</p>
<p>👨后面打算，基于这些小姐姐，做视频帧数切割，以及😃切割。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>cv</category>
      </categories>
      <tags>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>AC GAN</title>
    <url>/archives/d8960418.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li>在输入数据是分辨率较低的图片时，原有的gan能够生成和原始数据极为接近的结果，但对于高分辨率图片，就不太行。</li>
<li>在gan中的数据种类越多，生成就越困难。</li>
</ol>
<a id="more"></a>

<p>AC gan全称为Auxiliary Classifier GANs，翻译成中文就叫辅助分类器生成对抗网络。从名字可以看出，AC gan是对原有gan model修改后的一种model。</p>
<p>AC gan 在原有的基础上，增加了一个辅助分类器，用来限制label，并且使用了特定的损失函数。</p>
<p>下面是acgan的图形解释</p>
<p><img src="/archives/d8960418/1.png" alt></p>
<h2 id="AC-gan的数学表达"><a href="#AC-gan的数学表达" class="headerlink" title="AC gan的数学表达"></a>AC gan的数学表达</h2><p>原有的gan model中生成的假数据结果，定义为$X = G(z)$，$z$是输入噪音，$X$是输出结果。现在的AC gan引入了辅助分类器，故在原的$X$生成中引入了新的变量，现在将其定义为$X=G(c,z)$。</p>
<p>假设$D(X)$为输入数据$X$被鉴别为真的概率，其中$X$的输入，可以为真数据，也可以是生成的假数据。</p>
<p>假设用$P(S|X = D(x)$表示输入为数据后，判别数据得到的概率。</p>
<p>假设用$P(C|X = D(x))$表示输入数据后，判别label class得到的的概率。</p>
<p>那么对于输入数据有$L_S = E[logP(S=real|X_{real})]+E[logP(S=fake|X_{fake})]$</p>
<p>第一项：当输入数据是真数据，判定为真的结果的期望。<br>第二项：当输入数据是假数据，判定为假的结果的期望。</p>
<p>对于输入标签有：</p>
<p>$L_C = E[logP(C=c|X_{real})]+E[logP(C=c|X_{fake})]$</p>
<p>第一项：当输入真数据的label被判定确切属于某类c的期望。<br>第二项：当输入假数据的label被判定确切属于某类c的期望。</p>
<p>对于鉴别器(Discriminator D)而言，它的任务是尽可能的判定真的数据为真，假的数据为假，真的数据的label确切属于某类C，假的数据label确切属于某类c。故它的目标可以写成</p>
<p>$$max L_S+L_C$$</p>
<p>对于生成器(Generator G)而言，它的任务是尽可能的让真的数据被判定为真，让假的数据被判定为真，真的数据的label确切属于某类C，假的数据label确切不属于某类c。故它的目标可以写成（我感觉解释不通。待改）</p>
<p>$$max L_C-L_S$$</p>
]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>GAN Model</title>
    <url>/archives/f2925084.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>gan，全名Generative Adversarial Nets，翻译成中文，生成对抗网络。顾名思义，有生成过程，有对抗过程的一种net model。</p>
<p>这种模型大致工作流程：</p>
<p>有一生产者，也可以称其为造假者，他的工作是生成类似于源数据的数据，比如与古董真假难辨的伪造古董。生产者在这里就扮演了伪造古董的“工艺大师”。</p>
<a id="more"></a>

<p>有一对抗者，形象一点称其为鉴别者，他的工作就是判断某一数据是否来源于源数据，比如说，判断某一可能是古董的工艺品是不是真的古董。对抗者在这里就充当了“鉴宝大师”。</p>
<p>“工艺大师”和“鉴宝大师”相互竞争（对抗），驱使着他们各自变得更加优秀（前者生成真假难辨的古董，后者对再怎么真假难辨的古董也能分辨出来）。</p>
<p><strong>gan的目的</strong>就是让这个“工艺大师”能够生成无限接近于（相似于）源数据的数据。对于工艺大师，就是生成“古董”。</p>
<h2 id="gan数学表达"><a href="#gan数学表达" class="headerlink" title="gan数学表达"></a>gan数学表达</h2><p>假设源数据集(古董数据)分布：$p_{data}$</p>
<p>假设生成的数据集(伪造的古董)分布：$p_{g}(x_i,\theta_g)$，定义一个先验噪声$p_z(z)$,经过多层感知机处理，噪声经过$G(z,\theta_g)$处理得到$x$，即$x = G(z,\theta_g)$.</p>
<p>假设$D(x)$表示$x$来自源数据集$p_{data}$被鉴别为真（古董）的概率，那么$D(G(z))$则可以表示为$x = G(z,\theta_g)$来自于$p_g$而被鉴别为真（古董的概率）。</p>
<ol>
<li>对于鉴宝大师，他的目标是尽可能的使$D(x)$趋于1，使$D(G(z))$趋于0。因此可以这样表达：<br>$$\mathop{max}\limits_{D} E_{x\sim p_{data}}[logD(X)]+E_{z\sim p_z}[log(1-D(G(z)))]$$</li>
<li>对于工艺大师，他的目标是尽可能的使$D(G(x))$趋于1，产生误判。因此可以这样表达：<br>$$\mathop{min}\limits_{G}E_{z\sim p_z}[log(1-D(G(z)))]$$</li>
<li>结合以上两者，可以归纳为一个公式<br>$$\mathop{min}\limits_{G}\mathop{max}\limits_{D} E_{x\sim p_{data}}[logD(X)]+E_{z\sim p_z}[log(1-D(G(z)))]$$</li>
</ol>
<h2 id="gan数学表达的全局最优解"><a href="#gan数学表达的全局最优解" class="headerlink" title="gan数学表达的全局最优解"></a>gan数学表达的全局最优解</h2><p>将上式记为$$\mathop{min}\limits_{G}\mathop{max}\limits_{D} V(G,D) = \mathop{min}\limits_{G}\mathop{max}\limits_{D} E_{x\sim p_{data}}[logD(X)]+E_{z\sim p_z}[log(1-D(G(z)))]$$</p>
<p>$$\mathop{=====}\limits^{将期望用积分表达}\int_xp_{data}(x)log(D(x))dx+\int_zp(z)log(1-D(G(z)))dz$$</p>
<p>$$\mathop{===}\limits^{将z换成x}\int_x[p_{data}(x)log(D(x))+p_glog(1-D(x)]dx$$</p>
<p>求其全局最优解，将G固定，求此时的$\mathop{max}\limits_{D}V(D)$</p>
<p>$$\mathop{max}\limits_{D}V(D)=\mathop{max} \int_x[p_{data}(x)log(D(x))+p_glog(1-D(x)]dx$$</p>
<p>对上式中的$D$求偏微分，使其偏微分为0，于是有</p>
<p>$$\frac{\partial}{\partial D}[V(D)]=\int_x\frac{\partial}{\partial D}[p_{data}(x)log(D(x))+p_glog(1-D(x)]dx$$</p>
<p>$$=\int_x\frac{\partial}{\partial D}[p_{data}\frac{1}{D(x)}+p_g\frac{1}{1-D(x)}]dx=0$$</p>
<p>解得有：$D_G^* = \frac{p_{data}}{p_{data}+p_g}$</p>
<p>再将$D_G^* = \frac{p_{data}}{p_{data}+p_g}$代回$\mathop{min}\limits_{G}\mathop{max}\limits_{D} V(G,D) $，此时有</p>
<p>$$\mathop{min}\limits_{G}V(G,D)=E_{x\sim p_{data}}[log\frac{p_{data}}{p_{data}+p_g}]+E_{x\sim p_g}[log(1-\frac{p_{data}}{p_{data}+p_g})]$$       </p>
<p>关于求解上式，有一个叫KL散度的东西，相对熵，衡量两个概率$P(x),Q(x)$分布的距离：如下</p>
<p>$$D_{KL}(P||Q) = \sum\limits_{i=1}logP(x)\frac{P(x)}{Q(X)}=E_{P(x)}[log\frac{P(x)}{Q(x)}]$$<br>其中$P(x),Q(x)$均为$0-1$的概率值。</p>
<p>在本式中，除以2处理</p>
<p>$$\mathop{min}\limits_{G}V(G,D)=\mathop{min}\limits_{G}E_{x\sim p_{data}}[log\frac{p_{data}/2}{(p_{data}+p_g)/2}]+E_{x\sim p_g}[log(\frac{p_g/2}{(p_{data}+p_g)/2})]$$   </p>
<p>$$=\mathop{min}\limits_{G}E_{x\sim p_{data}}[log\frac{p_{data}}{(p_{data}+p_g)/2}]+E_{x\sim p_g}[log(\frac{p_g}{(p_{data}+p_g)/2})]-log4$$  </p>
<p>$$=\mathop{min}\limits_{G} KL(p_{data}||\frac{p_{data}+p_g{}}{2})+KL(p_g||\frac{p_{data}+p_g{}}{2})-log4\geq -log4$$</p>
<p>当$p_g==p_{data}$时，取全局最优最小值。</p>
<h2 id="论文中实现生成对抗伪算法"><a href="#论文中实现生成对抗伪算法" class="headerlink" title="论文中实现生成对抗伪算法"></a>论文中实现生成对抗伪算法</h2><p><img src="/archives/f2925084/1.png" alt="algorithm"></p>
<blockquote>
<p><a href="https://arxiv.org/abs/1406.2661" target="_blank" rel="noopener">gan论文</a></p>
<p><a href="https://www.bilibili.com/video/BV1eE411g7xc" target="_blank" rel="noopener">视频讲解</a></p>
</blockquote>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>略。</p>
]]></content>
      <categories>
        <category>cv</category>
      </categories>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>风格迁移</title>
    <url>/archives/163371af.html</url>
    <content><![CDATA[<h2 id="先看一下迁移后的图片"><a href="#先看一下迁移后的图片" class="headerlink" title="先看一下迁移后的图片"></a>先看一下迁移后的图片</h2><a id="more"></a>

<p><a href="https://github.com/cysmith/neural-style-tf" target="_blank" rel="noopener">传送门</a></p>
<h2 id="VGG19"><a href="#VGG19" class="headerlink" title="VGG19"></a>VGG19</h2><p><img src="/archives/163371af/1.jpg" alt="Vgg19网络结构图"></p>
<p><img src="/archives/163371af/2.jpg" alt="上图进一步分离"></p>
<p>一些是运行中打印出的网络结构代码，与上图完全对应。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LAYER GROUP <span class="number">1</span> <span class="comment">#卷积层组1</span></span><br><span class="line"><span class="comment"># 下面有两个卷积层，一个池化层，relu为线性整流层，每次卷积后，都relu一下</span></span><br><span class="line">--conv1_1 | shape=(<span class="number">1</span>, <span class="number">663</span>, <span class="number">1000</span>, <span class="number">64</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">64</span>)</span><br><span class="line">--relu1_1 | shape=(<span class="number">1</span>, <span class="number">663</span>, <span class="number">1000</span>, <span class="number">64</span>) | bias_shape=(<span class="number">64</span>,)</span><br><span class="line">--conv1_2 | shape=(<span class="number">1</span>, <span class="number">663</span>, <span class="number">1000</span>, <span class="number">64</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line">--relu1_2 | shape=(<span class="number">1</span>, <span class="number">663</span>, <span class="number">1000</span>, <span class="number">64</span>) | bias_shape=(<span class="number">64</span>,)</span><br><span class="line">--pool1   | shape=(<span class="number">1</span>, <span class="number">332</span>, <span class="number">500</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">LAYER GROUP <span class="number">2</span> <span class="comment">#卷积层组2</span></span><br><span class="line"><span class="comment"># 下面有两个卷积层，一个池化层</span></span><br><span class="line">--conv2_1 | shape=(<span class="number">1</span>, <span class="number">332</span>, <span class="number">500</span>, <span class="number">128</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">128</span>)</span><br><span class="line">--relu2_1 | shape=(<span class="number">1</span>, <span class="number">332</span>, <span class="number">500</span>, <span class="number">128</span>) | bias_shape=(<span class="number">128</span>,)</span><br><span class="line">--conv2_2 | shape=(<span class="number">1</span>, <span class="number">332</span>, <span class="number">500</span>, <span class="number">128</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line">--relu2_2 | shape=(<span class="number">1</span>, <span class="number">332</span>, <span class="number">500</span>, <span class="number">128</span>) | bias_shape=(<span class="number">128</span>,)</span><br><span class="line">--pool2   | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">LAYER GROUP <span class="number">3</span> <span class="comment"># 卷积层组3</span></span><br><span class="line"><span class="comment"># 下面有四个卷积层，一个池化层</span></span><br><span class="line">--conv3_1 | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">256</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">128</span>, <span class="number">256</span>)</span><br><span class="line">--relu3_1 | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">256</span>) | bias_shape=(<span class="number">256</span>,)</span><br><span class="line">--conv3_2 | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">256</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">--relu3_2 | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">256</span>) | bias_shape=(<span class="number">256</span>,)</span><br><span class="line">--conv3_3 | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">256</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">--relu3_3 | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">256</span>) | bias_shape=(<span class="number">256</span>,)</span><br><span class="line">--conv3_4 | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">256</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">--relu3_4 | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">256</span>) | bias_shape=(<span class="number">256</span>,)</span><br><span class="line">--pool3   | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">LAYER GROUP <span class="number">4</span> <span class="comment"># 卷积层组4</span></span><br><span class="line"><span class="comment"># 下面有四个卷积层，一个池化层</span></span><br><span class="line">--conv4_1 | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">512</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>, <span class="number">512</span>)</span><br><span class="line">--relu4_1 | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">512</span>) | bias_shape=(<span class="number">512</span>,)</span><br><span class="line">--conv4_2 | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">512</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">--relu4_2 | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">512</span>) | bias_shape=(<span class="number">512</span>,)</span><br><span class="line">--conv4_3 | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">512</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">--relu4_3 | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">512</span>) | bias_shape=(<span class="number">512</span>,)</span><br><span class="line">--conv4_4 | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">512</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">--relu4_4 | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">512</span>) | bias_shape=(<span class="number">512</span>,)</span><br><span class="line">--pool4   | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">LAYER GROUP <span class="number">5</span> <span class="comment"># 卷积层组5</span></span><br><span class="line"><span class="comment"># 下面有四个卷积层，一个池化层</span></span><br><span class="line">--conv5_1 | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">--relu5_1 | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>) | bias_shape=(<span class="number">512</span>,)</span><br><span class="line">--conv5_2 | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">--relu5_2 | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>) | bias_shape=(<span class="number">512</span>,)</span><br><span class="line">--conv5_3 | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">--relu5_3 | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>) | bias_shape=(<span class="number">512</span>,)</span><br><span class="line">--conv5_4 | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">--relu5_4 | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>) | bias_shape=(<span class="number">512</span>,)</span><br><span class="line">--pool5   | shape=(<span class="number">1</span>, <span class="number">21</span>, <span class="number">32</span>, <span class="number">512</span>)</span><br></pre></td></tr></table></figure>

<p>vgg 本身还是一个<a href="[https://blog.csdn.net/qq_25762497/article/details/51052861#%E5%8D%B7%E7%A7%AF%E5%B1%82convolutional-layer](https://blog.csdn.net/qq_25762497/article/details/51052861#卷积层convolutional-layer)">卷积神经网络（CNN）(详细介绍)</a>，卷积神经网络由输入层、卷积层、激活函数、池化层、全连接层组成，即INPUT（输入层）-CONV（卷积层）-RELU（激活函数）-POOL（池化层）-FC（全连接层）。</p>
<p>vgg19在卷积☛池化部分做了扩充修改。</p>
<p>由图及code，可以观察到，vgg19一共有五个卷积层组（conv layer），卷积层使用的卷积核均为3×3卷积核，三个全连接层（FC layer）。</p>
<p>共计一共19个隐藏层，其中16个卷积层，1个池化层。</p>
<ol>
<li><p>VGG优点:<br> VGGNet的结构非常简洁，整个网络都使用了同样大小的卷积核尺寸（3x3）和池化尺寸（2x2）。<br> 几个小滤波器（3x3）卷积层的组合比一个大滤波器（5x5或7x7）卷积层好：验证了通过不断加深网络结构可以提升性能。</p>
</li>
<li><p>VGG缺点:<br> VGG耗费更多计算资源，并且使用了更多的参数（这里不是3x3卷积的锅），导致更多的内存占用。</p>
</li>
</ol>
<p>其中绝大多数的参数都是来自于第一个全连接层。VGG可是有3个全连接层</p>
<h2 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a><a href="ww.cv-foundation.org/openaccess/content_cvpr_2016/papers/Gatys_Image_Style_Transfer_CVPR_2016_paper.pdf">论文阅读</a></h2><ol>
<li>原始content图像，用$\vec{p}$表示，即最开始输入图像内容。</li>
<li>生成图像，用$\vec{x}$表示，即迁移学习过程中生成的图像。</li>
<li>原始style图像，用$\vec{a}$表示，即输入风格图像。</li>
<li>$N_l$：在第$l$个网络层中的feature map数</li>
<li>$M_l$：在第$l$个网络层中的feature map大小，即feature map的长宽乘积。</li>
<li>$F^l$：图像在第$l$个网络层的所有特征图组成的矩阵。</li>
<li>$F^l_{ij}$：原content图像在第$l$个网络层的$F^l$在第$i$个filter，位置$j$处的激活。</li>
<li>$A^l_{ij}$：原style图像在第$l$个网络层的$A^l$在第$i$个filter，位置$j$处的激活。</li>
<li>$P^l_{ij}$：同$F^l_{ij}$，$P$表示生成过程中图像。</li>
<li>定义误差损失函数$L_{content}(\vec{p},\vec{x},l) = \frac{1}{2}\sum\limits_{i,j}(F_{ij}^l-P_{ij}^l)^2$</li>
<li>$G_{il}^l = \sum\limits_{k}F_{ik}^lF_{kj}^l$，表示在第$l$层，feature map <code>i</code>与feature map <code>j</code>的内积。</li>
<li>$E_l=\frac{1}{4N_l^2M_l^2}\sum\limits_{i,j}(G_{ij}^l-A_{ij}^l)^2$，生成图像与原始style图像在第$l$层的均方损失。</li>
<li>$L_{style}(\vec{a},\vec{x})=\sum\limits_{l=0}^Lw_lE_l$，每一层生成的图像$\vec{x}$与原始style图像的总损失。</li>
<li>$L_{total} = {\alpha}L_{content}(\vec{p},\vec{x})+{\beta}L_{style}(\vec{a},\vec{x})$</li>
</ol>
<p>未写其反向传播过程，不太理解他那张图。待填坑。</p>
]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>第88场周赛</title>
    <url>/archives/5122a47f.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-88/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="848-字母移位"><a href="#848-字母移位" class="headerlink" title="848. 字母移位"></a><a href="https://leetcode-cn.com/problems/shifting-letters/" target="_blank" rel="noopener">848. 字母移位</a></h4><p><strong>题解</strong>：根据描述，第一反应模拟这个过程，超时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shiftingLetters</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; shifts)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;shifts.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            S = shiftStr(S,shifts[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shiftStr</span><span class="params">(<span class="built_in">string</span> &amp;s,<span class="keyword">int</span> shift,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        shift%=<span class="number">26</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()&amp;&amp;i&lt;=<span class="built_in">end</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] =<span class="string">'a'</span> + (s[i]-<span class="string">'a'</span>+shift)%<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第二反应：根据上述这个模拟超时过程，想一优化，shifts数组后面开始，逐个偏移，根据描述，后面的偏移会加到前面。于是有了后缀和这一说法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shiftingLetters</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; shifts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=shifts.<span class="built_in">size</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            shifts[i]%=<span class="number">26</span>;</span><br><span class="line">            shifts[i]+=shifts[i+<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//计算后缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            S[i] =<span class="string">'a'</span> + (S[i]-<span class="string">'a'</span>+shifts[i])%<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="849-到最近的人的最大距离"><a href="#849-到最近的人的最大距离" class="headerlink" title="849. 到最近的人的最大距离"></a><a href="https://leetcode-cn.com/problems/maximize-distance-to-closest-person/" target="_blank" rel="noopener">849. 到最近的人的最大距离</a></h4><p><strong>题解</strong>：根据描述，本题可转换为最长连续0的长度。分三种情况，一开始就连续的0（左边无1），在中间连续的0（指0的左右都有1），在末尾连续的0（右边无1）.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDistToClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; seats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = seats.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> K = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        &#123;<span class="comment">//统计中间0的长度，</span></span><br><span class="line">            <span class="keyword">if</span> (seats[i] == <span class="number">1</span>)</span><br><span class="line">                K = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                K++;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, (K + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        &#123;<span class="comment">//统计第一种情况</span></span><br><span class="line">            <span class="keyword">if</span> (seats[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;<span class="comment">//统计第三中情况</span></span><br><span class="line">            <span class="keyword">if</span> (seats[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, N - <span class="number">1</span> - i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="851-喧闹和富有"><a href="#851-喧闹和富有" class="headerlink" title="851. 喧闹和富有"></a><a href="https://leetcode-cn.com/problems/loud-and-rich/" target="_blank" rel="noopener">851. 喧闹和富有</a></h4><p><strong>题解</strong>：根据描述，好像描述有点复杂，上图。</p>
<p><img src="/archives/5122a47f/1.png" alt></p>
<p>依据谁比谁更穷（比如0号选手比1号选手穷）这样的关系，构建了一个有向图。旁边红字对应的是每位选手的安静值。题目的意思就是把每位选手的安静值更新为所有比他富有的选手的安静值中，最小值对应的选手，怎么办？模拟图的深搜过程，假设DFS(i)表示所有比i号选手富有的选手的最小安静值对应的选手。那么,写成代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;answer;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;graph;</span><br><span class="line">   <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">loudAndRich</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; richer, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quiet)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> N = quiet.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> node=<span class="number">0</span>;node&lt;N;++node)</span><br><span class="line">       &#123;<span class="comment">//邻接表初始化</span></span><br><span class="line">           <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">           graph.push_back(v);</span><br><span class="line">           answer.push_back(<span class="number">-1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> i:richer)</span><br><span class="line">           graph[i[<span class="number">1</span>]].push_back(i[<span class="number">0</span>]);</span><br><span class="line">       <span class="comment">//邻接表赋值</span></span><br><span class="line">   </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> node=<span class="number">0</span>;node&lt;N;node++)</span><br><span class="line">           dfs(node,quiet);</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">return</span> answer;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;quiet)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (answer[node] == <span class="number">-1</span>) </span><br><span class="line">       &#123;</span><br><span class="line">           answer[node] = node;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> child: graph[node])</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">int</span> cand = dfs(child,quiet);</span><br><span class="line">               <span class="keyword">if</span> (quiet[cand] &lt; quiet[answer[node]])</span><br><span class="line">                   answer[node] = cand;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> answer[node];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="850-矩形面积-II"><a href="#850-矩形面积-II" class="headerlink" title="850. 矩形面积 II"></a><a href="https://leetcode-cn.com/problems/rectangle-area-ii/" target="_blank" rel="noopener">850. 矩形面积 II</a></h4><p>不会，待填坑，开始复习简历上的内容了。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第87场周赛</title>
    <url>/archives/a029fff2.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-87/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a><a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener">844. 比较含退格的字符串</a></h4><p><strong>题解</strong>：日常水题，根据描述，按照描述来干了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s_tmp = enterStr(S);</span><br><span class="line">        <span class="built_in">string</span> t_tmp = enterStr(T);</span><br><span class="line">        <span class="keyword">return</span> s_tmp== t_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">enterStr</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'#'</span>&amp;&amp;(ret.length()&gt;<span class="number">0</span>)) ret.erase(ret.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'#'</span>&amp;&amp;(ret.length()==<span class="number">0</span>))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> ret+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="845-数组中的最长山脉"><a href="#845-数组中的最长山脉" class="headerlink" title="845. 数组中的最长山脉"></a><a href="https://leetcode-cn.com/problems/longest-mountain-in-array/" target="_blank" rel="noopener">845. 数组中的最长山脉</a></h4><p><strong>题解</strong>：超喜欢这类写的工工整整的题目。根据描述，只要我们遍历数组，找到符合山脉条件（中间的山要高于两侧）的位置，然后以该位置为中心，向左右拓展。（改一下写代码习惯，括号另起一行书写）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.<span class="built_in">size</span>()&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;A[i<span class="number">-1</span>]&amp;&amp;A[i]&gt;A[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">int</span> left = i<span class="number">-1</span>;</span><br><span class="line">               	<span class="keyword">while</span>(left&gt;<span class="number">0</span> &amp;&amp;A[left]&gt;A[left<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp++;</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> right = i+<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">while</span>(right&lt;A.<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;A[right]&gt;A[right+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp++;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret=<span class="built_in">max</span>(ret,tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="846-一手顺子"><a href="#846-一手顺子" class="headerlink" title="846. 一手顺子"></a><a href="https://leetcode-cn.com/problems/hand-of-straights/" target="_blank" rel="noopener">846. 一手顺子</a></h4><p><strong>题解</strong>：根据描述，只需要对手上所有的牌建立一个map，每三张连续的牌的val-1，一直检测，若不能检测到连续的牌，return false。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNStraightHand</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; hand, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = hand.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n % W != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : hand) mp[i]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>();it != mp.<span class="built_in">end</span>();)&#123;</span><br><span class="line">            <span class="keyword">while</span>(it!=mp.<span class="built_in">end</span>() &amp;&amp; it-&gt;second &lt;= <span class="number">0</span>) it++;</span><br><span class="line">            <span class="keyword">if</span>(iter == mp.<span class="built_in">end</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> cm = it-&gt;first,cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(cnt = <span class="number">0</span>;cnt &lt; W;++cnt) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[cm] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    mp[cm]--;</span><br><span class="line">                    cm++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="847-访问所有节点的最短路径"><a href="#847-访问所有节点的最短路径" class="headerlink" title="847. 访问所有节点的最短路径"></a><a href="https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/" target="_blank" rel="noopener">847. 访问所有节点的最短路径</a></h4>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第86场周赛</title>
    <url>/archives/4feb94cc.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-86/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="840-矩阵中的幻方"><a href="#840-矩阵中的幻方" class="headerlink" title="840. 矩阵中的幻方"></a><a href="https://leetcode-cn.com/problems/magic-squares-in-grid/" target="_blank" rel="noopener">840. 矩阵中的幻方</a></h4><p><strong>题解</strong>：根据描述，第一反应，由数据范围，满足题意的3×3的矩阵，从3×3矩阵的中间元素暴力枚举。</p>
<p>如何判断一个3×3矩阵是幻方的？首先这9个数均不相同，其次这9个数范围为1-9。最后每一行每一列，和对角线元素和均为15，最中间元素为5。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numMagicSquaresInside</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;++j)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(judgeSquares(grid,i,j)) ret++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s = &#123;grid[i<span class="number">-1</span>][j<span class="number">-1</span>],grid[i<span class="number">-1</span>][j],grid[i<span class="number">-1</span>][j+<span class="number">1</span>],</span><br><span class="line">                    grid[i][j<span class="number">-1</span>],grid[i][j],grid[i][j+<span class="number">1</span>],</span><br><span class="line">                    grid[i+<span class="number">1</span>][j<span class="number">-1</span>],grid[i+<span class="number">1</span>][j],grid[i+<span class="number">1</span>][j+<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()!=<span class="number">9</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=<span class="number">0</span>||i&gt;<span class="number">10</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (grid[i][j]==<span class="number">5</span>&amp;&amp;(grid[i<span class="number">-1</span>][j<span class="number">-1</span>]+grid[i<span class="number">-1</span>][j]+grid[i<span class="number">-1</span>][j+<span class="number">1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i][j<span class="number">-1</span>]+grid[i][j]+grid[i][j+<span class="number">1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i+<span class="number">1</span>][j<span class="number">-1</span>]+grid[i+<span class="number">1</span>][j]+grid[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i<span class="number">-1</span>][j<span class="number">-1</span>]+grid[i][j]+grid[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i<span class="number">-1</span>][j+<span class="number">1</span>]+grid[i][j]+grid[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i<span class="number">-1</span>][j<span class="number">-1</span>]+grid[i][j<span class="number">-1</span>]+grid[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i<span class="number">-1</span>][j]+grid[i][j]+grid[i+<span class="number">1</span>][j]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i<span class="number">-1</span>][j+<span class="number">1</span>]+grid[i][j+<span class="number">1</span>]+grid[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">15</span>)</span><br><span class="line">                        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="841-钥匙和房间"><a href="#841-钥匙和房间" class="headerlink" title="841. 钥匙和房间"></a><a href="https://leetcode-cn.com/problems/keys-and-rooms/" target="_blank" rel="noopener">841. 钥匙和房间</a></h4><p><strong>题解</strong>：根据描述，第一反应，我们只需要按照他的描述，进一个房间，拿钥匙，再进另一个房间。自然转换成深度优先搜索了。</p>
<p>第二反应，其实就是遍历一遍，看哪些房间不可到达。可用BFS</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = rooms.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;visit(len,<span class="number">0</span>);</span><br><span class="line">        dfs(rooms,<span class="number">0</span>,visit);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:visit)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms,<span class="keyword">int</span> i,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;visit)</span></span>&#123;</span><br><span class="line">        visit[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> room:rooms[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[room]) dfs(rooms,room,visit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="842-将数组拆分成斐波那契序列"><a href="#842-将数组拆分成斐波那契序列" class="headerlink" title="842. 将数组拆分成斐波那契序列"></a><a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/" target="_blank" rel="noopener">842. 将数组拆分成斐波那契序列</a></h4><h4 id="843-猜猜这个单词"><a href="#843-猜猜这个单词" class="headerlink" title="843. 猜猜这个单词"></a><a href="https://leetcode-cn.com/problems/guess-the-word/" target="_blank" rel="noopener">843. 猜猜这个单词</a></h4>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第84场周赛</title>
    <url>/archives/4b1e44f1.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-84/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="832-翻转图像"><a href="#832-翻转图像" class="headerlink" title="832. 翻转图像"></a><a href="https://leetcode-cn.com/problems/flipping-an-image/" target="_blank" rel="noopener">832. 翻转图像</a></h4><p><strong>题解</strong>：根据描述，我们按照描述一步一步来就行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flipAndInvertImage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;A[i].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                A[i][j] =(!A[i][j]); </span><br><span class="line">            &#125;</span><br><span class="line">            reverse(A[i].<span class="built_in">begin</span>(),A[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="833-字符串中的查找与替换"><a href="#833-字符串中的查找与替换" class="headerlink" title="833. 字符串中的查找与替换"></a><a href="https://leetcode-cn.com/problems/find-and-replace-in-string/" target="_blank" rel="noopener">833. 字符串中的查找与替换</a></h4><p>题解：根据描述，有如下想法，对于测试点1，只要找到首个匹配字符位置，末尾字符匹配位置，使用replace函数替换即可。在下轮替换的时候，开始找的位置应为由于插入而带来的字符串长度改变的偏置。</p>
<p>根据这一想法，可以通过前8个测试点。后面的替换位置并不是有序的，因此我们需要把替换位置sort一下。重写一下输入的数据结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp</span>&#123;</span></span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            <span class="built_in">string</span> source;</span><br><span class="line">            <span class="built_in">string</span> target;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(struct tmp a,struct tmp b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a.index&lt;b.index;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findReplaceString</span><span class="params">(<span class="built_in">string</span> &amp;S, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indexes, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; sources, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; targets)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;struct tmp&gt;v(indexes.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;indexes.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            v[i].index = indexes[i];</span><br><span class="line">            v[i].source = sources[i];</span><br><span class="line">            v[i].target = targets[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">int</span> bisa=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;indexes.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="number">0</span>,j,start=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i=<span class="number">0</span>)j = v[i].index;</span><br><span class="line">            <span class="keyword">else</span> j = v[i].index+bisa;</span><br><span class="line">            start=j;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;S.length();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(S[j]!=v[i].source[k])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k==v[i].source.length())&#123;</span><br><span class="line">                S.replace(S.<span class="built_in">begin</span>()+start,S.<span class="built_in">begin</span>()+start+v[i].source.length(),v[i].target);</span><br><span class="line">                <span class="comment">//每次替换带来了偏置</span></span><br><span class="line">                 bisa += v[i].target.length()-v[i].source.length();</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="835-图像重叠"><a href="#835-图像重叠" class="headerlink" title="835. 图像重叠"></a><a href="https://leetcode-cn.com/problems/image-overlap/" target="_blank" rel="noopener">835. 图像重叠</a></h4><p>题解：根据描述，数据量在$0-30$范围内，使用蛮力算法即可。<br>枚举A中出现的1，对于B中出现的1，有相同偏置的位置在记录数组中加一。比如</p>
<table>
<thead>
<tr>
<th align="center">index A</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">index B</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>对于矩阵A(0,0)处的1，B中所有的1(分别位于[(1,1)(1,2),(2,2)]处)，相对于A(0,0)处的偏置分别为[(1,1)(1,2),(2,2)] <strong>下标相减即可</strong></p>
<p>对于矩阵A(0,1)处的1，B中所有的1(分别位于[(1,1)(1,2),(2,2)]处)，相对于A(0,0)处的偏置分别为[(1,0),(1,1),(2,1)]</p>
<p>对于矩阵A(1,1)处的1，B中所有的1(分别位于[(1,1)(1,2),(2,2)]处)，相对于A(0,0)处的偏置分别为[(0,0),(0,1),(1,1)]</p>
<p>对于矩阵A(2,1)处的1，B中所有的1(分别位于[(1,1)(1,2),(2,2)]处)，相对于A(0,0)处的偏置分别为[(-1,0),(-1,1),(0,2)]</p>
<p>统计偏置数组[(1,1)(1,2),(2,2)]，[(1,0)(1,1),(2,1)]，[(0,0),(0,1),(1,1)]，[(-1,0),(-1,1),(0,2)]，可发现(1,1)出现最多，是为3次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">2</span>*N][<span class="number">2</span>*N];</span><br><span class="line">        <span class="built_in">memset</span>(count,<span class="number">0</span>,<span class="keyword">sizeof</span>(count));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">0</span>; i2 &lt; N; ++i2)</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j2 = <span class="number">0</span>; j2 &lt; N; ++j2)</span><br><span class="line">                            <span class="keyword">if</span> (B[i2][j2] == <span class="number">1</span>)</span><br><span class="line">                                count[i-i2 +N][j-j2 +N] += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*N;++j)&#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret,count[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="834-树中距离之和"><a href="#834-树中距离之和" class="headerlink" title="834. 树中距离之和"></a><a href="https://leetcode-cn.com/problems/sum-of-distances-in-tree/" target="_blank" rel="noopener">834. 树中距离之和</a></h4>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第85场周赛</title>
    <url>/archives/a4dc2fcf.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-85/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="836-矩形重叠"><a href="#836-矩形重叠" class="headerlink" title="836. 矩形重叠"></a><a href="https://leetcode-cn.com/problems/rectangle-overlap/" target="_blank" rel="noopener">836. 矩形重叠</a></h4><p><strong>题解</strong>：根据描述，我们需要找到什么时候才是重合的规律。如图所示，</p>
<p><img src="/archives/a4dc2fcf/1.png" alt></p>
<p>可以看到规律了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rec2[<span class="number">0</span>]&lt;rec1[<span class="number">2</span>] &amp;&amp; rec2[<span class="number">1</span>]&lt;rec1[<span class="number">3</span>] &amp;&amp; rec2[<span class="number">2</span>]&gt;rec1[<span class="number">0</span>] &amp;&amp; rec2[<span class="number">3</span>]&gt;rec1[<span class="number">1</span>] )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="838-推多米诺"><a href="#838-推多米诺" class="headerlink" title="838. 推多米诺"></a><a href="https://leetcode-cn.com/problems/push-dominoes/" target="_blank" rel="noopener">838. 推多米诺</a></h4><p><strong>题解</strong>：根据描述，第一反应时模拟这个过程，把每经过一秒后的状态表示出来，再用这个新状态去更新这个过程。当状态没有更新，结束这个模拟过程。有如下code，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">pushDominoes</span><span class="params">(<span class="built_in">string</span> dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = dominoes.length();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> dominoes;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">int</span> flag;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            ret = <span class="string">""</span>;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(dominoes[<span class="number">0</span>]==<span class="string">'.'</span>&amp;&amp;dominoes[<span class="number">1</span>]==<span class="string">'L'</span>)&#123;</span><br><span class="line">                ret+=<span class="string">"L"</span>;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ret+=dominoes[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len<span class="number">-1</span>;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;i&lt;len<span class="number">-1</span>&amp;&amp;dominoes[i]==<span class="string">'.'</span>&amp;&amp;dominoes[i+<span class="number">1</span>]==<span class="string">'L'</span>&amp;&amp;dominoes[i<span class="number">-1</span>]!=<span class="string">'R'</span>)&#123;</span><br><span class="line">                    ret+=<span class="string">"LL"</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;i&lt;len<span class="number">-1</span>&amp;&amp;dominoes[i]==<span class="string">'.'</span>&amp;&amp;dominoes[i<span class="number">-1</span>]==<span class="string">'R'</span>&amp;&amp;dominoes[i+<span class="number">1</span>]!=<span class="string">'L'</span>)&#123;</span><br><span class="line">                    ret+=<span class="string">"R"</span>;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ret+=dominoes[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dominoes[len<span class="number">-2</span>]==<span class="string">'R'</span>&amp;&amp;dominoes[len<span class="number">-1</span>]==<span class="string">'.'</span>)&#123;</span><br><span class="line">                ret+=<span class="string">"R"</span>;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ret+=dominoes[len<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        dominoes = ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第二反应：上面这个过程复杂了。每次都要针对原有状态遍历一遍，产生新的状态，很是繁琐。</p>
<p>从左到右遍历一遍字符串，分一下几种情况（记下第一个LR的位置，然后在下一个字符型LR的时候处理这一段的字符）<br>L—–L 里面‘.’全部填充L；<br>L—–R 里面左边一半填充L，右边一半填充R（注意这里要分类，中间可能会有一个‘.’或者没有）<br>R—–R 里面‘.’全部填充R；<br>R—–L 不用处理；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//从a-b位置的全部变成指定的lr符号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trans</span><span class="params">(<span class="built_in">string</span>&amp; temp,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">char</span> lr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=a;i&lt;=b;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp[i]=lr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">pushDominoes</span><span class="params">(<span class="built_in">string</span> dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> temp=dominoes;<span class="comment">//用于存储结果</span></span><br><span class="line">        <span class="keyword">char</span> temp1=<span class="string">'N'</span>;<span class="comment">//上一个识别的字符是L还是R</span></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">-1</span>;<span class="comment">//上一个识别的字符是位置标号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dominoes.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断此时的字符串是L</span></span><br><span class="line">            <span class="keyword">if</span>(dominoes[i]==<span class="string">'L'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//左侧符号位为N的时候，左侧全部填充L</span></span><br><span class="line">                 <span class="keyword">if</span>(temp1==<span class="string">'N'</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     trans(temp,<span class="number">0</span>,i<span class="number">-1</span>,<span class="string">'L'</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">                <span class="comment">//左侧符号位为L的时候，左侧全部填充L</span></span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span>(temp1==<span class="string">'L'</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     trans(temp,index+<span class="number">1</span>,i<span class="number">-1</span>,<span class="string">'L'</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">                <span class="comment">//左侧符号位为R的时候，靠近左侧填充R，右侧填充L（填充个数为m=(i-index-1)/2）</span></span><br><span class="line">                 <span class="keyword">else</span> </span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">int</span> m=(i-index<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                     trans(temp,index+<span class="number">1</span>,index+m,<span class="string">'R'</span>);</span><br><span class="line">                     trans(temp,i-m,i<span class="number">-1</span>,<span class="string">'L'</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">                 temp1=<span class="string">'L'</span>;</span><br><span class="line">                 index=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时的符号位R</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dominoes[i]==<span class="string">'R'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//上一个符号为R,则填充R，其他情况不用考虑</span></span><br><span class="line">                <span class="keyword">if</span>(temp1==<span class="string">'R'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=index+<span class="number">1</span>)</span><br><span class="line">                        trans(temp,index+<span class="number">1</span>,i<span class="number">-1</span>,<span class="string">'R'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                 temp1=<span class="string">'R'</span>;</span><br><span class="line">                 index=i;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左侧是R到字符串结尾没有处理 需要全部变成R</span></span><br><span class="line">        <span class="keyword">if</span>(temp1==<span class="string">'R'</span>)</span><br><span class="line">            trans(temp,index+<span class="number">1</span>,temp.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="string">'R'</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：brother_of_brother</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/push-dominoes/solution/cxiang-xi-ti-jie-by-brother_of_brother/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h4 id="837-新21点"><a href="#837-新21点" class="headerlink" title="837. 新21点"></a><a href="https://leetcode-cn.com/problems/new-21-game/" target="_blank" rel="noopener">837. 新21点</a></h4><p><strong>题解</strong>：</p>
<h4 id="839-相似字符串组"><a href="#839-相似字符串组" class="headerlink" title="839. 相似字符串组"></a><a href="https://leetcode-cn.com/problems/similar-string-groups/" target="_blank" rel="noopener">839. 相似字符串组</a></h4>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第83场周赛</title>
    <url>/archives/a9c25f88.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-83/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="830-较大分组的位置"><a href="#830-较大分组的位置" class="headerlink" title="830. 较大分组的位置"></a><a href="https://leetcode-cn.com/problems/positions-of-large-groups/" target="_blank" rel="noopener">830. 较大分组的位置</a></h4><p><strong>题解</strong>：根据描述，只要设置两个指针$i$，$j$。初始$i$指向第一次出现的字母，$j$指向$i$的后面一个位置，不断增加$j$，使得$i$与$j$之间的字母相同，当$j$指向字母与$i$不同时且$ij$之间的距离大于等于3保存结果，小于3则更新$i$至位置$j$，$j$向后移动一位。</p>
<p>注意如字符串$“aaa”$，上述原则失效，可以在$“aaa”$后增加一个哨兵(一个隐藏的字符)。也可以在最后增加一个判断。当上述循环结束时，$ij$距离大于2即可。以下是个人code。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">largeGroupPositions</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;ret;</span><br><span class="line">        <span class="keyword">if</span>(!S.length()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>,j = <span class="number">1</span>;i&lt;S.length()&amp;&amp;j&lt;S.length();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==S[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>((j-i)&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                    ret.emplace_back(&#123;i,j<span class="number">-1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                i = j;</span><br><span class="line">                j = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((j-i)&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            ret.emplace_back(&#123;i,j<span class="number">-1</span>&#125;);&#125;</span><br><span class="line">        <span class="keyword">return</span> ret;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="831-隐藏个人信息"><a href="#831-隐藏个人信息" class="headerlink" title="831. 隐藏个人信息"></a><a href="https://leetcode-cn.com/problems/masking-personal-information/" target="_blank" rel="noopener">831. 隐藏个人信息</a></h4><p><strong>题解</strong>：根据描述，我们只需要根据是否有@符号，设计两个函数maskMail与maskPhone。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">maskPII</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;    	</span><br><span class="line">    transform(S.<span class="built_in">begin</span>(),S.<span class="built_in">end</span>(),S.<span class="built_in">begin</span>(),::<span class="built_in">tolower</span>);</span><br><span class="line">    <span class="comment">//转换所有字符变为小写</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:S)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="string">'@'</span>)&#123;</span><br><span class="line">                <span class="comment">//当有@符号，用maskMail</span></span><br><span class="line">                <span class="built_in">string</span> ret = maskMail(S);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//没有@符号，用maskPhone</span></span><br><span class="line">        <span class="built_in">string</span> ret = maskPhone(S);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">maskMail</span><span class="params">(<span class="built_in">string</span> S)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;S.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[j]==<span class="string">'@'</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> star = <span class="string">"*****"</span>;</span><br><span class="line">        star.insert(star.<span class="built_in">begin</span>(),S[<span class="number">0</span>]);</span><br><span class="line">        star.insert(star.<span class="built_in">end</span>(),S[j<span class="number">-1</span>]);</span><br><span class="line">        <span class="built_in">string</span> ret=star+S.substr(j,S.length()-j);</span><br><span class="line">        <span class="keyword">return</span> ret;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">maskPhone</span><span class="params">(<span class="built_in">string</span> &amp;S)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:S)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="string">'0'</span>&amp;&amp;i&lt;=<span class="string">'9'</span>) tmp.emplace_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        由于电话号码的数字只有10-13位，根据数字长度，</span></span><br><span class="line"><span class="comment">        加上不同的前缀即可。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">size</span>()==<span class="number">10</span>)&#123;</span><br><span class="line">            ret+=<span class="string">"***-***-"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">6</span>;i&lt;<span class="number">10</span>;i++) ret+=tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">size</span>()==<span class="number">11</span>)&#123;</span><br><span class="line">            ret+=<span class="string">"+*-***-***-"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&lt;<span class="number">11</span>;i++) ret+=tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">size</span>()==<span class="number">12</span>)&#123;</span><br><span class="line">            ret+=<span class="string">"+**-***-***-"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">8</span>;i&lt;<span class="number">12</span>;i++) ret+=tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">size</span>()==<span class="number">13</span>)&#123;</span><br><span class="line">            ret+=<span class="string">"+***-***-***-"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">9</span>;i&lt;<span class="number">13</span>;i++) ret+=tmp[i];</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="829-连续整数求和"><a href="#829-连续整数求和" class="headerlink" title="829. 连续整数求和"></a><a href="https://leetcode-cn.com/problems/consecutive-numbers-sum/" target="_blank" rel="noopener">829. 连续整数求和</a></h4><p>题解：根据题意，</p>
<p>第一反应：蛮力遍历求和，看是否有满足连续的整数和。<br>第二反应：使用等差数列求和公式，设求和为$N$，求和起点为$x$，一共有$k$个数参与求和，那么有<br>$$N = (x+1)+(x+2)+…+(x+k)=\frac{(2x+k+1)k}{2}$$</p>
<p>解得$$x = \frac{1}{2}(\frac{2N}{k} - k - 1)$$，至此，只要枚举$k(k&gt;=1)$，并且使得$x$为整数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">consecutiveNumbersSum</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2N = k(2x + k + 1)</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>*N; ++k)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * N % k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = <span class="number">2</span> * N / k - k - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (y % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span>)</span><br><span class="line">                    ret++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三反应：减小$k$的枚举范围。<br>$$N = (x+1)+(x+2)+…+(x+k)=\frac{(2x+k+1)k}{2}$$<br>在该式中，明显可观察到$k&lt;2x+k+1$，由此我们可用小学二年级学过的放缩大致确定$k&lt;\sqrt{2n}$。</p>
<p>第四反应:</p>
<p><img src="/archives/a9c25f88/1.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">consecutiveNumbersSum</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; N &gt; <span class="number">0</span>; N-=i, i++)</span><br><span class="line">        ans += (N % i == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第四种解法可以看作另一种形式的枚举吧，优美且简洁。</span></span><br><span class="line">作者：pris_bupt</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/consecutive-numbers-sum/solution/c-ji-jian-by-pris_bupt/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h4 id="828-统计子串中的唯一字符"><a href="#828-统计子串中的唯一字符" class="headerlink" title="828. 统计子串中的唯一字符"></a><a href="https://leetcode-cn.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/" target="_blank" rel="noopener">828. 统计子串中的唯一字符</a></h4><p>题解：待填坑（我不会，哭唧唧）</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第184场周赛</title>
    <url>/archives/c4e3d004.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-184/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="5380-数组中的字符串匹配"><a href="#5380-数组中的字符串匹配" class="headerlink" title="5380. 数组中的字符串匹配"></a><a href="https://leetcode-cn.com/problems/string-matching-in-an-array/" target="_blank" rel="noopener">5380. 数组中的字符串匹配</a></h4><p><strong>题解</strong>：根据描述，加上简单题，以及数据规模很小，不妨有按照题目描述解法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.length()&lt;b.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">stringMatching</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sort(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;words.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> <span class="built_in">begin</span>=<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>((<span class="built_in">begin</span>=words[j].<span class="built_in">find</span>(words[i],<span class="built_in">begin</span>+<span class="number">1</span>))!=<span class="built_in">string</span>::npos)</span><br><span class="line">                &#123;<span class="comment">//此句为字符串匹配</span></span><br><span class="line">                    ret.push_back(words[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5381-查询带键的排列"><a href="#5381-查询带键的排列" class="headerlink" title="5381. 查询带键的排列"></a><a href="https://leetcode-cn.com/problems/queries-on-a-permutation-with-key/" target="_blank" rel="noopener">5381. 查询带键的排列</a></h4><p><strong>题解</strong>：根据描述，有了啊，有了啥？有了答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">processQueries</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;p;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)p.push_back(i);<span class="comment">//根据描述生成数组p</span></span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ret;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queries.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">           <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(),queries[i]);</span><br><span class="line">           <span class="keyword">int</span> tmp = *it;<span class="comment">//1.保存移动的值</span></span><br><span class="line">           p.erase(it);<span class="comment">//2. 删掉</span></span><br><span class="line">           ret.push_back(it-p.<span class="built_in">begin</span>());<span class="comment">//3. 插到最前面</span></span><br><span class="line">           p.insert(p.<span class="built_in">begin</span>(),tmp);<span class="comment">//</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1410-HTML-实体解析器"><a href="#1410-HTML-实体解析器" class="headerlink" title="1410. HTML 实体解析器"></a><a href="https://leetcode-cn.com/problems/html-entity-parser/" target="_blank" rel="noopener">1410. HTML 实体解析器</a></h4><p><strong>题解</strong>：本次周赛前三题都是模拟题呢？没有啥子变通，根据题意模拟就行啦，自己的代码功底（API）熟悉程度不行啊，哭唧唧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">entityParser</span><span class="params">(<span class="built_in">string</span> <span class="built_in">text</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">char</span>&gt;m = &#123;&#123;<span class="string">"&amp;gt"</span>,<span class="string">'&gt;'</span>&#125;,&#123;<span class="string">"&amp;lt"</span>,<span class="string">'&lt;'</span>&#125;,&#123;<span class="string">"&amp;amp"</span>,<span class="string">'&amp;'</span>&#125;,&#123;<span class="string">"&amp;quot"</span>,<span class="string">'"'</span>&#125;,&#123;<span class="string">"&amp;apos"</span>,<span class="string">'\''</span>&#125;,&#123;<span class="string">"&amp;frasl"</span>,<span class="string">'/'</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">text</span>.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">text</span>[i]!=<span class="string">'&amp;'</span>) ret+=<span class="built_in">text</span>[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">string</span> sub = <span class="built_in">text</span>.substr(i,<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j:m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sub==j.first)&#123;</span><br><span class="line">                        flag = <span class="number">1</span>;</span><br><span class="line">                        ret+=j.second;</span><br><span class="line">                        i+=<span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                sub = <span class="built_in">text</span>.substr(i,<span class="number">4</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j:m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sub==j.first)&#123;</span><br><span class="line">                        flag=<span class="number">1</span>;</span><br><span class="line">                        ret+=j.second;</span><br><span class="line">                        i+=<span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                sub = <span class="built_in">text</span>.substr(i,<span class="number">5</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j:m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sub==j.first)&#123;</span><br><span class="line">                        flag=<span class="number">1</span>;</span><br><span class="line">                        ret+=j.second;</span><br><span class="line">                        i+=<span class="number">5</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sub = <span class="built_in">text</span>.substr(i,<span class="number">6</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j:m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sub==j.first)&#123;</span><br><span class="line">                        flag =<span class="number">1</span>;</span><br><span class="line">                        ret+=j.second;</span><br><span class="line">                        i+=<span class="number">6</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag ==<span class="number">0</span>) ret+=<span class="string">'&amp;'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5383-给-N-x-3-网格图涂色的方案数"><a href="#5383-给-N-x-3-网格图涂色的方案数" class="headerlink" title="5383. 给 N x 3 网格图涂色的方案数"></a><a href="https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid/" target="_blank" rel="noopener">5383. 给 N x 3 网格图涂色的方案数</a></h4><p>题解：先看图</p>
<p><img src="/archives/c4e3d004/1.png" alt></p>
<p>根据上图，可以将排列情况分为两种，ABA，ABC，前者颜色有重复，后者无，在这两种下面再添加元素有这么12种选择</p>
<p>ABC  ACB BAC BCA  CAB CBA  ABA ACA BAB BCB CAC CBC</p>
<p>可分别加入到下面的如表格所示</p>
<table>
<thead>
<tr>
<th align="center">ABA</th>
<th align="center">ABC</th>
</tr>
</thead>
<tbody><tr>
<td align="center">unrepeat：BAC</td>
<td align="center">unrepeat：BCA</td>
</tr>
<tr>
<td align="center">unrepeat：CAB</td>
<td align="center">unrepeat：CAB</td>
</tr>
<tr>
<td align="center">unrepeat：BAB</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">repeat：BCB</td>
<td align="center">repeat：BAB</td>
</tr>
<tr>
<td align="center">repeat：CAC</td>
<td align="center">repeat：BCB</td>
</tr>
</tbody></table>
<p>在形如ABA这样的下面只能由3种unrepeat填充，2种repeat填充</p>
<p>在形如ABC这样的下面只能由2种unrepeat填充，2种repeat填充</p>
<p>每次填充依赖选择，当前可填充数目为</p>
<p>$$ repeat_n=3×unrepeat_{n-1}+2×repeat_{n-1}$$</p>
<p>$$ unrepeat_n=2×unrepeat_{n-1}+2×repeat_{n-1}$$</p>
<p>总结好规律后有下面代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numOfWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">long</span> m = <span class="number">6</span>,k = <span class="number">6</span>;<span class="comment">//k，m表示上一层repeat，unrepeat</span></span><br><span class="line">        <span class="keyword">long</span> repeat,unrepeat;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            repeat = (<span class="number">2</span>*(k+m))%<span class="number">1000000007</span>;</span><br><span class="line">            unrepeat = (<span class="number">3</span>*m+<span class="number">2</span>*k)%<span class="number">1000000007</span>;</span><br><span class="line">            m = unrepeat;</span><br><span class="line">            k = repeat;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (unrepeat+repeat)%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>VM下使用Kali及其后续</title>
    <url>/archives/54abd342.html</url>
    <content><![CDATA[<h3 id="VM下kali的安装"><a href="#VM下kali的安装" class="headerlink" title="VM下kali的安装"></a>VM下kali的安装</h3><p>直接去kali官网下载对应VM文件即可<a href="https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/" target="_blank" rel="noopener">传送门</a>，下载完成以后，直接解压到某个文件夹，用VM打开即可。</p>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><a id="more"></a>

<p>成功打开以后，全是英文界面，我不是很喜欢。把他弄成中文界面。</p>
<ol>
<li><p>打开kali的浏览器，输入一些关键字搜索，会发现不能显示中文，于是去解决乱码问题。</p>
</li>
<li><p>新建一个root用户，输入如下：sudo passwd root ,之后按照英文提示输入，切到root</p>
</li>
<li><p>更新源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/apt/sources.list</span><br><span class="line"><span class="comment"># 编辑源文件</span></span><br><span class="line"><span class="comment"># 这里使用的是vi编辑器，打开后按键盘字母i一下，变成insert模式，可编辑模式，</span></span><br><span class="line"><span class="comment">#deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span></span><br><span class="line"><span class="comment">#deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span></span><br><span class="line"><span class="comment">#将这两行加入到文件末尾，然后按esc键一次，输入（:wq）保存并退出。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新源，并更新软件依赖，安装中文字体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get clean</span><br><span class="line"><span class="comment">#更新源并更新软件。</span></span><br><span class="line">dpkg-reconfigure locales</span><br><span class="line"><span class="comment">#进入图形界面，选中en_US.UTF-8 UTF-8和zh_CN.UTF-8 UTF-8（空格是选择，tab是切换，*是选中）并将en_US.UTF-8选为默认。</span></span><br><span class="line">apt-get install xfonts-intl-chinese</span><br><span class="line">apt-get install ttf-wqy-microhei</span><br><span class="line"><span class="comment"># 安装中文字体</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>完成以后重启，在终端输入reboot好像没啥用，手动在虚拟机里面重启。</p>
</li>
</ol>
<h3 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update <span class="comment">#更新系统 </span></span><br><span class="line">apt-get dist-upgrade <span class="comment">#升级系统 </span></span><br><span class="line">apt-get install fcitx fcitx-googlepinyin <span class="comment">#google拼音</span></span><br></pre></td></tr></table></figure>

<p>执行完毕后，搜索fcitx configuration，添加谷歌拼音即可。</p>
<h3 id="安装新的软件"><a href="#安装新的软件" class="headerlink" title="安装新的软件"></a>安装新的软件</h3><p>apt-get install xxxx，即可安装</p>
<p>apt-get remove xxxx，即可卸载</p>
<p>一般完成以后是打不开的，因此需要修改一些东西。</p>
<p>去/usr/share/applications/下找到xxxx.desktop文件，用文本编辑器打开编辑，在Exex后修改为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Exec=/usr/bin/xxxx %U --no-sandbox</span><br></pre></td></tr></table></figure>

<h3 id="window10-加kali双系统"><a href="#window10-加kali双系统" class="headerlink" title="window10 加kali双系统"></a>window10 加kali双系统</h3><p>正常安装，分区再安装。没错误最好</p>
<p>遇到未安装启动引导器，其原因可能是您选择了不安装或者您的特殊硬件体系尚不支持启动引导器，您需要手动启动/dev/sda3分区上的/vmlinuz内核，并且以root=/dev/sda3作为内核参数，记住这个出错。</p>
<p><img src="/archives/54abd342/1.jpg" alt></p>
<p>解决办法：进入到boot界面，找一下add boot options</p>
<p><img src="/archives/54abd342/2.jpg" alt></p>
<p>之后找到一个grubx64.efi文件，加入</p>
<p><img src="/archives/54abd342/3.jpg" alt></p>
<p>之后重启进入kali，就可看到黑框grub命令行界面了。输入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">linux /boot/vmlinuz-xxx-xxx root=/dev/sda3 nouveau.modeset=<span class="number">0</span></span><br><span class="line"><span class="comment">//解释，vmlinuz后面一串字符，输入/boot/vmlinuz后按tab自动填充即可</span></span><br><span class="line"><span class="comment">//root=/dev/sda3是当初出错的时候提醒你的</span></span><br><span class="line">initrd /boot/initrd.img-xxx-xxxx</span><br><span class="line"><span class="comment">//这个xxxx也是按tab填充</span></span><br><span class="line">boot</span><br><span class="line"><span class="comment">//重启会进入到kali了，美滋滋</span></span><br><span class="line"><span class="comment">//之后还有呢</span></span><br><span class="line">update-grub</span><br><span class="line"><span class="comment">//上面update-grub自动修复引导</span></span><br><span class="line"><span class="comment">//错误是因为独立显卡的问题，还需要修改一个文件</span></span><br><span class="line">vi /boot/grub/grub.cfg</span><br><span class="line"><span class="comment">//找到禁用N卡的参数，修改 quiet flash 为quiet nouveau.modeset=0</span></span><br><span class="line"><span class="comment">//大功告成。</span></span><br></pre></td></tr></table></figure>

<p><img src="/archives/54abd342/4.jpg" alt></p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title>QQ空间</title>
    <url>/archives/b66ffe92.html</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>现在21世纪，有人称之为大数据时代，谁有数据量大的数据，谁能够从海量数据中提取到有用信息，并能够将其转换为资本，谁就取得了互联网的地位。</p>
<a id="more"></a>

<p>互联网数据是由生活在网络上的每一个用户所产生的，用户在互联网上的活动会被记录下来，这就是数据，海量用户，有着海量数据。这些数据被利用，分析，与各种各样的广告联系在一起，进而把这些广告推送给用户，这些推送的广告都是用户的网络行为分析出的结果。</p>
<p>QQ上活跃这大量的用户，QQ空间里面记录了许多人的日常，这些就是数据。在日常使用QQ空间的时候，会偶尔点击给我们好友点赞的朋友，之后我们就能看到我们好友的好友的空间，依次类推，我们可以看到海量信息。</p>
<h2 id="过程中用到的算法"><a href="#过程中用到的算法" class="headerlink" title="过程中用到的算法"></a>过程中用到的算法</h2><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>一、 前言</p>
<p>布隆过滤器 (Bloom Filter)是由Burton Howard Bloom于1970年提出，用于判断一个元素是否在集合中。与课本上学的数据结构不同，它是一种<strong>概率型</strong>数据结构，所谓概率型，就是指在判重的时候，并<strong>不是完全一定确保</strong>某个数据在集合中，课本上的二分查找，哈希，都可以<strong>一定确定</strong>某个元素是否在集合中。</p>
<p>在爬虫的时候，数据发生重复，需要判重，判断该条数据是否加入到队列中。传统哈希表可用于判断元素是否在集合中，时间复杂度<code>O(1)</code>,空间复杂度<code>o(n)</code>，布隆过滤器牺牲了一点时间，空间复杂度大约是哈希表的$\frac{1}{4}$。</p>
<p>布隆过滤器也支持数据的插入。</p>
<p>二、算法过程</p>
<p>一个布隆过滤器是一个有m个bit位的数组，每一个bit位都初始化为0。并且定义有k个不同的hash 函数，每个都以随机的将元素均匀hash到m个不同位置中的一个。</p>
<p>在下面的介绍中n为元素数，m为布隆过滤器或哈希表的槽数，k为布隆过滤器hash 函数个数。</p>
<ol>
<li><p>往布隆过滤器增加一个元素：首先用k个hash 函数分别将该元素hash，得到k个数值，于布隆过滤器中将这k个数值对应的bit位置1。</p>
<p>举例：现在有3个哈希函数，$f1,f2,f3$，有一个8位qq号，布隆过滤器数组长度m为10。qq号先经过三个hash函数处理，假设分别得到1，3，7，然后就将布隆数组1，3，7位置1。</p>
</li>
</ol>
<ol start="2">
<li><p>判断布隆过滤器中是否含有某个元素：首先用k个hash函数分别将该元素hash得到k个数值。再判断这k个数值在布隆数组中的位置是否全1，若全位1则此元素在集合中，若其中任一位不为1，则此元素比不在集合中。</p>
<p>举例：现在有3个哈希函数，$f1,f2,f3$，有一个8位qq号，布隆过滤器数组长度m为10。需要查找是否含有这个qq号。该qq号先经过三个hash函数处理，假设分别得到1，3，7，然后查看布隆数组1，3，7位置是否全为1。</p>
</li>
<li><p>概率型数组结构的解释：</p>
<p>举例：现在有3个哈希函数，$f1,f2,f3$，有3个8位qq号，假设分别为$q1,q2,q3$，布隆过滤器数组长度m为10。三个qq号分别经过三个hash函数处理，假设依次得到的结果为</p>
<p>$q1:1，3，7$，</p>
<p>$q2:2，5，8$，</p>
<p>$q3:2，3，7$，</p>
<p>在将$q1,q2 $依次插入到布隆数组中后，查询$q3$，发现其三个位置均为1，于是得到了q3在布隆过滤器的错误。这就是概率型的解释。</p>
</li>
<li><p>避免上述错误：<br>增加hash函数个数k，增加hash范围m。当hash结果范围很大大，且hash结果独立，直接上感觉不太可能发生碰撞。有没有一种hash函数的感觉😁。</p>
</li>
<li><p>使用场景：</p>
<p>总结：数据量大，很大，在使用查询可以接受一定的查询错误，使用布隆过滤器</p>
<p>​            当数据量大小自己能够接受，且不接受误判，使用传统set，哈希表。 </p>
</li>
</ol>
<p>三、举例说明</p>
<p>以垃圾邮件过滤中黑白名单为例：假设现有1亿个email的黑名单，每个都拥有8 bytes的指纹信息，则能的数据量大小为</p>
<p>$$1GB=2^{10} MB=2^{20} KB=2^{30}Bytes=2^{33}bits\approx10^9Byte$$<br>需要的位数组大小为$$2^{8×8}bits=2^{31}GB\approx2×10^9GB$$</p>
<p>这个数据量对于位数组来说是太大了，且在邮箱里，邮箱数量相比较邮箱范围过于稀疏，而且还没有考虑到哈希表中的碰撞问题。</p>
<p><strong>若采用哈希表</strong>，由于大多数采用开放地址法来解决碰撞，而此时的查找时间复杂度为 ：$O(\frac{1}{1-\frac{n}{m}})$，当哈希表半满($\frac{n}{m}=\frac{1}{2}$)，则每次search需要探测2次，因此在保证效率的情况下哈希表的存储效率最好不超过50%。此时每个元素占8 bytes，总空间为：$\frac{10^8×8Byte}{1-0.5}=1.6GB$</p>
<p><strong>若采用布隆过滤器</strong>，取k=8。因为n为1亿，所以总共需要$8 × 10^8$被置位为1，在保证误判率低，选取合适的k，m，让空间利用率为50%，所以总空间为：$\frac{8×10^8bis}{50%}\approx200MB$，所需空间比上述哈希结构小得多，并且误判率在万分之一以下。</p>
<p>四、误判概率的证明和计算</p>
<p>假设布隆过滤器中的hash函数满足简单均匀哈希假设：每个元素都等概率地hash到m个槽中的任何一个，与其它元素被hash到哪个slot无关。</p>
<p>若m为bit数，则对某一特定bit位在一个元素由某特定hash函数插入时没有被置位为1的概率为：$1-\frac{1}{m}$，该结论算法导论有详细证明。</p>
<p>那么k个hash 函数中没有一个对其置位的概率为：$(1-\frac{1}{m})^k$。</p>
<p>如果插入了n个元素，但都未将其置位的概率为：$(1-\frac{1}{m})^{kn}$。</p>
<p>则此位被置位的概率为：$1-(1-\frac{1}{m})^{kn}$。</p>
<p>现在考虑查找阶段，若对应某个待查找元素的k bits全部置位为1，则可判定其在集合中。因此将某元素误判的概率为：$(1-(1-\frac{1}{m})^{kn})^k$。</p>
<p>从上式中可以看出，当m增大或n减小时，都会使得误判率减小，这也符合直觉。</p>
<p>根据小学二年级学过的极限公式:$\lim\limits_{x\to0} (1+x)^{\frac{1}{x}}=e$</p>
<p> $(1-(1-\frac{1}{m})^{kn})^k=(1-(1-\frac{1}{m})^{m×\frac{kn}{-m}})^k$~$(1-e^{-\frac{nk}{m}})^k$。</p>
<p>现在可以假设当给定m，和n的当k取何值时，可以将误判率降至最低。</p>
<p>假设$f(k)=(1-e^{-\frac{nk}{m}})^k$，设$b = e^{\frac{n}{m}}$,此时，$f(k)=(1-b^{-k})^k$，接下来求$f(k)$的最值：</p>
<p>$f(k)=(1-b^{-k})^k$，两边同时取对数$lnf(k)=kln(1-b^{-k})$</p>
<p>两边同时对k求导 $\frac{1}{f(k)}f’(k)=ln(1-b^{-k})+k\frac{b^{-k}lnb}{1-b^{-k}}=0$</p>
<p>解上述方程：$☞(1-b^{-k})ln(1-b^{-k})=-kb^{-k}lnb$</p>
<p>​                       $☞(1-b^{-k})ln(1-b^{-k})=b^{-k}lnb^{-k}$</p>
<p>​                       $☞(1-b^{-k})=b^{-k}$</p>
<p>​                       $☞b^{-k}=\frac{1}{2}$</p>
<p>​                        $☞e^{-\frac{kn}{m}}=\frac{1}{2}$</p>
<p>​                        $☞k = ln2\frac{m}{n}$</p>
<p>此时误判率$f(k)=(1-b^{-k})^k=(1-\frac{1}{2})^{k}=2^{-ln2\frac{m}{n}}\approx0.6185^{\frac{m}{n}}$</p>
<p>调节$\frac{m}{n}$的大小，即可降低误判率$f(k)$。</p>
<p>五、设计和应用布隆过滤器的方法</p>
<p>首先要先由用户决定要add的元素数n，希望的误差率P。其他参数需要计算。</p>
<p>首先要计算需要的内存大小m bits：$p = 2^{-ln2\frac{m}{n}}⇨m=-\frac{nlnp}{(ln2)^2}$</p>
<p>再由m，n得到hash函数的个数：$k = ln2\frac{m}{n}$</p>
<p>至此结束。</p>
<p><a href="https://www.cnblogs.com/allensun/archive/2011/02/16/1956532.html" target="_blank" rel="noopener">原文参考</a></p>
<h3 id="框架算法：BFS广度优先搜索"><a href="#框架算法：BFS广度优先搜索" class="headerlink" title="框架算法：BFS广度优先搜索"></a>框架算法：BFS广度优先搜索</h3><p>一、前言</p>
<p>人的社交可以抽象定义成一个网络图。</p>
<p><img src="/archives/b66ffe92/1.jpg" alt></p>
<p>以每一个个人为中心，向外扩充一圈即时自己的好友圈。好友圈会有交叠。</p>
<p>不断的以每个人为中心，向外扩充，就是整个网络图(社交遍历)。</p>
<h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>每个人的好友圈是不同的，你的好友情况在别人那里情况可能是不一样的。</p>
<p>个人只能看到自己的朋友圈，去看看别人的朋友圈，了解一下其他圈子动态，也是一件相当有趣的事。</p>
<p>经过一圈圈的扩充遍历，好友的动态内容逐渐不同。我一开始能够访问到的内容是像自己一样普通大学生的动态，日常，到中间是那些转发，非原创动态，到最后，就逐渐变成卖衣服，卖手机的。</p>
<p>个人解释：qq空间其实是可以限制访问的，那些开放qq空间的人，会有哪些人？一，不在意别人访问的，二,需要别人浏览，阅读，转发。三，为了利益。</p>
<p>这些数据都有些什么用呢？有这些人的qq号，qq号主发的动态，号主的资料卡信息，其实这里最真实的只有qq号，然后是动态，分析假的资料信息并没有什么意义。qq号没得分析，动态分析，只得大致去浏览了。告一段落吧。</p>
<p>qq空间里人间百态。那个80-90-00的人间百态。</p>
]]></content>
      <categories>
        <category>cv</category>
      </categories>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习</title>
    <url>/archives/83b461a0.html</url>
    <content><![CDATA[<h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><p>string的初始化</p>
<table>
<thead>
<tr>
<th>初始化方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>string s1</td>
<td>默认初始化，s1为一空串</td>
</tr>
<tr>
<td>string s2(s1)</td>
<td>s2是s1的一个副本，直接初始化</td>
</tr>
<tr>
<td>string s2=s1</td>
<td>等价s2(s1)，拷贝初始化</td>
</tr>
<tr>
<td>string s3(“value”)</td>
<td>s3是字面值”value”的副本，不包括最后的空字符</td>
</tr>
<tr>
<td>string s3 = “value”</td>
<td>等价于s3(“value”)</td>
</tr>
<tr>
<td>string s4(n,’c’)</td>
<td>用连续n个字符初始化字符串s4，直接初始化</td>
</tr>
</tbody></table>
<p>string 类对象上的操作</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>os&lt;&lt;s</td>
<td>将s写到输出流os当中，返回os</td>
</tr>
<tr>
<td>is&gt;&gt;s</td>
<td>从is中读取字符串赋给s,字符串以空白分隔，返回is</td>
</tr>
<tr>
<td>getlin(is,s)</td>
<td>从is中读取一行赋给S，返回is</td>
</tr>
<tr>
<td>s.empty()</td>
<td>s为空返回true,否则返回false</td>
</tr>
<tr>
<td>s.size()</td>
<td>返回s中字符的个数，返回的类型为string::size_type</td>
</tr>
<tr>
<td>s[n]</td>
<td>返回s中第n个字符，位置n从0计起</td>
</tr>
<tr>
<td>s1+s2</td>
<td>返回s1和s2连接后的结果</td>
</tr>
<tr>
<td>s1=s2</td>
<td>用s2的副本代替si中原来的字符</td>
</tr>
<tr>
<td>s1!=s2</td>
<td>判断s1和s2中所含的字符是否一样</td>
</tr>
<tr>
<td>s1==s2</td>
<td>同上</td>
</tr>
<tr>
<td>s1(&lt;,&lt;=,&gt;,&gt;=)</td>
<td>字典序比较</td>
</tr>
</tbody></table>
<h2 id="模板vector"><a href="#模板vector" class="headerlink" title="模板vector"></a>模板vector</h2><p>vector&lt;的初始化&gt;</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>vector<T> v1</T></td>
<td>v1为空，默认初始化</td>
</tr>
<tr>
<td>vector<T> v2(v1)</T></td>
<td>v2包含v1的所有元素</td>
</tr>
<tr>
<td>vector<T>v2 = v1</T></td>
<td>等价于vector<T>v2(v1)</T></td>
</tr>
<tr>
<td>vector<T>v3(n,val)</T></td>
<td>初始化了含n个val的vector</td>
</tr>
<tr>
<td>vector<T>v4(n)</T></td>
<td>vector大小为n，可存n个T</td>
</tr>
<tr>
<td>vector<T>v5{a,b,c,…}</T></td>
<td>按a,b,c,…初始化，并且值也确定</td>
</tr>
<tr>
<td>vector<T>v6 = {a,b,c,…}</T></td>
<td>等价于vector<T>{a,b,c,…}</T></td>
</tr>
<tr>
<td>vector<T>v7 = {10,T}</T></td>
<td>初始化了10个T</td>
</tr>
</tbody></table>
<p>vector上的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>v.push_back(T)</td>
<td>向v的末尾添加元素T</td>
</tr>
<tr>
<td>v.size()</td>
<td>v中所含元素个数</td>
</tr>
<tr>
<td>v.empty()</td>
<td>v是否为空</td>
</tr>
<tr>
<td>支持类似数组操作按秩访问</td>
<td></td>
</tr>
</tbody></table>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>stack的初始化</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>stack<int> stack1;</int></td>
<td>初始化一个栈，默认为双端队列</td>
</tr>
<tr>
<td>stack&lt;int,vector<int>&gt;stack2;</int></td>
<td>变成向量</td>
</tr>
<tr>
<td>stack&lt;int,list<int>&gt; stack3</int></td>
<td>链表</td>
</tr>
</tbody></table>
<p>stack上常用操作</p>
<table>
<thead>
<tr>
<th>返回值 操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>bool empty()</td>
<td>判断栈是否为空</td>
</tr>
<tr>
<td>void pop()</td>
<td>弹出栈顶元素，</td>
</tr>
<tr>
<td>void push(const T&amp; el)</td>
<td>将元素el压入栈顶，constT&amp;表示类型</td>
</tr>
<tr>
<td>size_type size()</td>
<td>栈中元素数目</td>
</tr>
<tr>
<td>T&amp; top()</td>
<td>栈顶元素</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>hello-world</title>
    <url>/archives/b1d4025b.html</url>
    <content><![CDATA[<h1 id="长恨歌"><a href="#长恨歌" class="headerlink" title="长恨歌"></a>长恨歌</h1><h2 id="唐代：白居易"><a href="#唐代：白居易" class="headerlink" title="唐代：白居易"></a>唐代：白居易</h2><p>汉皇重色思倾国，御宇多年求不得。<br>杨家有女初长成，养在深闺人未识。<br>天生丽质难自弃，一朝选在君王侧。<br>回眸一笑百媚生，六宫粉黛无颜色。<br>春寒赐浴华清池，温泉水滑洗凝脂。<br>侍儿扶起娇无力，始是新承恩泽时。<br>云鬓花颜金步摇，芙蓉帐暖度春宵。<br>春宵苦短日高起，从此君王不早朝。</p>
<a id="more"></a>

<p>承欢侍宴无闲暇，春从春游夜专夜。<br>后宫佳丽三千人，三千宠爱在一身。<br>金屋妆成娇侍夜，玉楼宴罢醉和春。<br>姊妹弟兄皆列土，可怜光彩生门户。<br>遂令天下父母心，不重生男重生女。<br>骊宫高处入青云，仙乐风飘处处闻。<br>缓歌慢舞凝丝竹，尽日君王看不足。<br>渔阳鼙鼓动地来，惊破霓裳羽衣曲。</p>
<p>九重城阙烟尘生，千乘万骑西南行。<br>翠华摇摇行复止，西出都门百余里。<br>六军不发无奈何，宛转蛾眉马前死。<br>花钿委地无人收，翠翘金雀玉搔头。<br>君王掩面救不得，回看血泪相和流。<br>黄埃散漫风萧索，云栈萦纡登剑阁。<br>峨嵋山下少人行，旌旗无光日色薄。<br>蜀江水碧蜀山青，圣主朝朝暮暮情。</p>
<p>行宫见月伤心色，夜雨闻铃肠断声。<br>天旋地转回龙驭，到此踌躇不能去。<br>马嵬坡下泥土中，不见玉颜空死处。<br>君臣相顾尽沾衣，东望都门信马归。<br>归来池苑皆依旧，太液芙蓉未央柳。<br>芙蓉如面柳如眉，对此如何不泪垂。<br>春风桃李花开日，秋雨梧桐叶落时。<br>西宫南内多秋草，落叶满阶红不扫。(花开日 一作：花开夜；南内 一作：南苑)</p>
<p>梨园弟子白发新，椒房阿监青娥老。<br>夕殿萤飞思悄然，孤灯挑尽未成眠。<br>迟迟钟鼓初长夜，耿耿星河欲曙天。<br>鸳鸯瓦冷霜华重，翡翠衾寒谁与共。<br>悠悠生死别经年，魂魄不曾来入梦。<br>临邛道士鸿都客，能以精诚致魂魄。<br>为感君王辗转思，遂教方士殷勤觅。<br>排空驭气奔如电，升天入地求之遍。</p>
<p>上穷碧落下黄泉，两处茫茫皆不见。<br>忽闻海上有仙山，山在虚无缥渺间。<br>楼阁玲珑五云起，其中绰约多仙子。<br>中有一人字太真，雪肤花貌参差是。<br>金阙西厢叩玉扃，转教小玉报双成。<br>闻道汉家天子使，九华帐里梦魂惊。<br>揽衣推枕起徘徊，珠箔银屏迤逦开。<br>云鬓半偏新睡觉，花冠不整下堂来。</p>
<p>风吹仙袂飘飖举，犹似霓裳羽衣舞。<br>玉容寂寞泪阑干，梨花一枝春带雨。(阑 通：栏)<br>含情凝睇谢君王，一别音容两渺茫。<br>昭阳殿里恩爱绝，蓬莱宫中日月长。<br>回头下望人寰处，不见长安见尘雾。<br>惟将旧物表深情，钿合金钗寄将去。<br>钗留一股合一扇，钗擘黄金合分钿。<br>但教心似金钿坚，天上人间会相见。</p>
<p>临别殷勤重寄词，词中有誓两心知。<br>七月七日长生殿，夜半无人私语时。<br>在天愿作比翼鸟，在地愿为连理枝。<br>天长地久有时尽，此恨绵绵无绝期。</p>
]]></content>
  </entry>
</search>
