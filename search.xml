<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Boost</title>
    <url>/archives/97a5086c.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我今天真的是被这个boost库搞到头炸，怎么在linux下安装boost库，及后续使用。一开始用<code>sudo apt-get install libboost-dev</code>倒是能解决代码中头文件引用不存在问题，但是编译不成功，总是会出现什么未定义引用错误，之后remove掉，重新下载源码编译还是会存在一些问题。</p>
<p><img src="/archives/97a5086c/image-20200706201140831.png" alt></p>
<h1 id="安装全过程"><a href="#安装全过程" class="headerlink" title="安装全过程"></a>安装全过程</h1><ol>
<li><p>到<a href="https://www.boost.org/users/history/version_1_73_0.html" target="_blank" rel="noopener">这里</a>下载boost的源码包，我下载的是unix平台的boost源码包，Version 为1.73.0。</p>
<p><a href="https://www.boost.org/doc/libs/1_73_0/more/getting_started/unix-variants.html" target="_blank" rel="noopener">这里</a>有官网指导教程。</p>
</li>
<li><p>下载好，复制到桌面吧，之后解压，得到压缩包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar --bzip2 -xf boost_1_73_0.tar.bz2</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换到源码目录，<code>cd  boost_1_73_0</code>,可以看到有一个bootstrap.sh文件</p>
</li>
<li><p>然后运行bootstrap.sh脚本并设置相关参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bootstrap.sh --with-libraries=all --with-toolset=gcc</span><br><span class="line"><span class="meta">#</span><span class="bash"> --with-libraries指定编译哪些boost库，all把全部选上，以免出了啥子差错</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --with-toolset指定编译时使用哪种编译器，Linux使用gcc，当然默认就有</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置完成以后，开始编译，编译命令<code>./b2</code>，编译过程有点慢，编译结束后大致涨这个模样。</p>
<p><img src="/archives/97a5086c/image-20200706202831145.png" alt></p>
</li>
<li><p>接着就是安装boost，安装命令<code>./b2 install --prefix=/usr</code></p>
<p><code>--prefix=/usr</code>用来指定boost的安装目录，不加此参数的话默认的头文件在<code>/usr/local/include/boost</code>目录下，库文件在<code>/usr/local/lib/</code>目录下。这里把安装目录指定为–prefix=/usr则boost会直接安装到系统头文件目录和库文件目录下，可以省略配置环境变量。</p>
<p>我没有指定安装目录，直接``./b2 install`，结果还要配置环境变量烦。</p>
<p>还要注意的一点，这个操作是往usr目录写入一些文件，没有提示需要root权限居然也执行成功了，但是在该出现的目录却没有应该要出现的文件，心态崩了，所以需要在root权限下执行，我又重新做了一遍。</p>
</li>
<li><p>最后运行一下<code>ldconfig</code>, 该命令通常在系统启动时运行，而当用户安装了一个新的动态链接库时，就需要手工运行这个命令。</p>
</li>
</ol>
<h1 id="示例使用"><a href="#示例使用" class="headerlink" title="示例使用"></a>示例使用</h1><p>示例代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; dirs;<span class="comment">//目录向量字符串形式</span></span><br><span class="line"><span class="keyword">int</span> INTERVAL = <span class="number">10</span>;<span class="comment">//间隔</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( boost::filesystem::recursive_directory_iterator <span class="built_in">end</span>, dir(<span class="string">"./0"</span>);dir != <span class="built_in">end</span>; ++dir )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; *dir &lt;&lt; "\n";  // full path</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> s = dir-&gt;path().c_str();</span><br><span class="line">        dirs.push_back(s); <span class="comment">// just last bit</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::srand(<span class="number">42</span>);</span><br><span class="line">    <span class="keyword">int</span> ndirs = dirs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Directories found: "</span> &lt;&lt; ndirs &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; files;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">std</span>::rand() % ndirs;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span>* d = &amp;dirs[r];</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> n = *d + <span class="string">"/f"</span> + <span class="built_in">std</span>::to_string(i);</span><br><span class="line">        files.push_back(n);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nfiles = files.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Files generated: "</span> &lt;&lt; nfiles &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = (<span class="keyword">int</span>)time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lastcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">string</span> fn : files)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="built_in">open</span>(fn.c_str(), O_WRONLY | O_CREAT, <span class="number">0777</span>);</span><br><span class="line">        <span class="built_in">close</span>(f);</span><br><span class="line">        <span class="keyword">int</span> current = (<span class="keyword">int</span>)time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (current - start &gt;= INTERVAL)</span><br><span class="line">        &#123;</span><br><span class="line">            start = current;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d:%d\n"</span>, count, (count-lastcount)/INTERVAL);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            lastcount = count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试执行，需要在末尾后面指定 -lboost_filesystem，因为我的示例代码导入了<code>#include &lt;boost/filesystem.hpp&gt;</code>,相应的其他的也需要指定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mm@ubuntu:~/桌面/filt$ g++ create.cpp -o creat -lboost_filesystem</span><br><span class="line">mm@ubuntu:~/桌面/filt$ ./creat</span><br><span class="line">terminate called after throwing an instance of <span class="string">'boost::filesystem::filesystem_error'</span></span><br><span class="line">  what():  boost::filesystem::directory_iterator::construct: No such file or directory: <span class="string">"./0"</span></span><br><span class="line">已放弃 (核心已转储)</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我感觉我的折腾劲在一点点磨掉，我不断地搜索着我出现的问题，其实也就那些前人遇到问题，我不断地尝试，不断地复现，而新问题，我解决不了，还是搜索，求人。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>FILT</title>
    <url>/archives/d0bafb56.html</url>
    <content><![CDATA[<h1 id="LMS-Tree-Log-Structured-Merge-Tree，日志结构合并树"><a href="#LMS-Tree-Log-Structured-Merge-Tree，日志结构合并树" class="headerlink" title="LMS-Tree(Log-Structured Merge-Tree，日志结构合并树)"></a>LMS-Tree(<a href="https://www.researchgate.net/profile/Dieter_Gawlick/publication/226763355_The_log-structured_merge-tree_LSM-tree/links/543fb33f0cf2fd72f99cef39/The-log-structured-merge-tree-LSM-tree.pdf" target="_blank" rel="noopener">Log-Structured Merge-Tree，日志结构合并树</a>)</h1><p>LSM-tree是由两个或两个以上存储数据的结构组成的。最简单的LSM-tree有两个部分，如下图所示。常驻内存部分，称为$C_0$树（或$C_0$），其可以设计为任何方便<code>键值查找</code>的数据结构，常驻硬盘部分，称为$C_1$树（或$C_1$）。C1进一步可延申为$C_2$，$C_3$等等。</p>
<p><img src="/archives/d0bafb56/12202325-4148015185424100886d778a854da94c.png" alt="img"></p>
<h2 id="数据结构名称解析"><a href="#数据结构名称解析" class="headerlink" title="数据结构名称解析"></a>数据结构名称解析</h2><ol>
<li><p>日志：磁盘可以看做是一个日志，就好像日记本一样。在向日志中存放永久性数据及其索引，每次都会添加在日志的末尾。</p>
</li>
<li><p>合并：</p>
<p><img src="/archives/d0bafb56/image-20200703075918216.png" alt></p>
<p>内存中无法保存太多的数据，毕竟内存贵。$C_0$是有一个设定阈值的，当达到阈值后，就会merge到$C_1$中，毕竟磁盘中的$C_1$容量大，还便宜。$C_1$到$C_2$的合并也是如此</p>
</li>
<li><p>树：不多言。</p>
</li>
</ol>
<h1 id="LevelDB"><a href="#LevelDB" class="headerlink" title="LevelDB"></a><a href="https://github.com/google/leveldb" target="_blank" rel="noopener">LevelDB</a></h1><p><a href="https://blog.csdn.net/wangdenghui2005/article/details/104712476?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase" target="_blank" rel="noopener">详细介绍</a></p>
<p>从本周的周报开始，请详细描述你对FILT的理解。如架构、数据流、各函数的调用流程等，务必做到对代码深入理解，为FILT改进做准备。</p>
<p>FILT其实可以看作LevelDB的改进版本。LevelDB是一种持久键值存储容器，其仅仅存储了文件，key-value这种形式的文件。日常使用的文件管理器，还有文件夹这种东西，当然在Linux中也可以当作是一种文件。那么就产生了把文件夹（但可以当作文件）存储到LevelDB这种储存容器中这种想法。通过把文件夹路径Flat indexing，扁平化索引，设计成key-value形式存储到LSM-tree中。</p>
<p>那么问题来了：常规查找一个文件，LSM-tree中查找就可以解决，先从C0内存中查找，查找不到再到C1，C2中找。但是查找指定目录文件夹下有没有特定文件怎么做？这个指定目录可以方便找到，但包含在其中的文件怎么说？</p>
<p>重命名：比如把根目录root重命名为root1，很简单的想法就是把所有含有root及其以下展开的目录文件夹变更成root1.</p>
<p>查找某一文件所属文件夹?</p>
<p>其实应该考虑一下LSM-tree特性，它对写入操作比较擅长，而查找，这属于读操作。</p>
<p>难道有些功能其实可以不予理睬。只需要专注于提供某些特定接口。</p>
<p>那么FLIT做的是啥？是像LevelDB一样的数据库管理程序，还是像xfs一样的文件系统。应该是后者，但代码为什么是LevelDB代码，其中好多都是LevelDB源码？</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>裴谌、王敬伯</title>
    <url>/archives/fba0d57a.html</url>
    <content><![CDATA[<h2 id="故事梗概"><a href="#故事梗概" class="headerlink" title="故事梗概"></a>故事梗概</h2><p>裴谌、王敬伯、<strong>李芳</strong>三个人结为超脱世俗的好友。</p>
<p>隋炀帝大业年间，三个朋友一齐进白鹿山学道。他们认为用铜炼金用汞炼银的方术一定能得到，长生不老的仙药一定能求着。至于腾云驾雾，羽化成仙的功夫，只要苦修苦炼，也是早晚能成功的。</p>
<p>然而，他们经过十几年的修炼内功，采集仙药，历尽了辛苦艰难，手、脚都磨起了老茧，却仍然什么也没得到。</p>
<a id="more"></a>

<p>后来<strong>梁芳</strong>死了，王敬伯对裴谌说：“咱们背井离乡，抛弃了世间豪华富贵的生活进了这深山老林，听不见美妙的音乐，吃不到美味的佳饮，看不到美丽的女色。离开华美的府第住进茅屋，以享乐为耻，自甘寂寞过着如此清苦的生活，这一切都是为了能得了道，成了仙，有朝一日能骑鹤驾云到蓬莱仙宫去过上神仙的日子。就算成不了仙，也希望能长生不老与天地同寿。然而如今仙境渺渺不知在哪里，长生也没什么指望，我们如果继续在这里苦熬，只能死在山中了。我打算立刻出山去重新过豪华的生活，乘肥马穿轻裘，欣赏音乐亲近美女。游遍京城胜地，玩够了再去追求功名宦位，以求在世间显身扬名。纵然不能饮宴于天宫瑶池，不能乘着天马神龙听凤歌看鸾舞，不能日日与神仙为伴，但是在人世上身居高官，身穿紫袍腰系金带，每天和高官显贵在一起，还能使自己的图像挂在天子为功臣特建的，‘凌烟阁’上，该多么荣耀。咱们为什么不回去呢？何必白白死在这空山里！”</p>
<p>裴谌说：“我早已看破人间的荣华富贵如过眼烟云。大梦初醒的人怎么可能再回到梦境中去呢？”</p>
<p>王敬伯任凭裴谌怎样挽留也不听，一个人出了山。</p>
<p>当时是唐太宗贞观初年，王敬伯不但恢复了原任的官职，而且在旧职的级别上被新任为左武卫骑曹参军。大将军赵朏将自己的女儿嫁给他，不到几年他就升任为大理寺的廷评，穿上了红袍。</p>
<p>有一次他奉命出使淮南，坐船走到高邮，当时他的船队仪仗森严，威风十足，江上的民船都躲着不敢走。这时天下着小雨，忽然有一只小渔舟出现在官家船队前面，船上是一位头戴斗笠身披蓑衣的渔夫。划着桨很快地驶过船队，像一阵疾风。王敬伯心里很不高兴，心想我是朝里派出的使臣，谁都对我敬畏回避，怎么这个渔夫敢为此放肆？仔细一看。那渔夫意是当年和他一起在山中修道的裴谌。</p>
<p>于是赶快派船追上去。把裴谌追到后，王敬伯命手下人把裴谌的渔船连在自己大船的后面，请裴谌上了大船，进舱坐下，握着裴谌的手说：“老兄当初坚持不和我一起出山，抛开了世上的功名利禄，一意修道，但到如今你又得到了什么呢，不还是个江上的渔夫吗？所以我看修道的事如同捕风捉影，太坑人了。<strong>古人尚懂得人生苦短抓紧享乐，甚至点着灯烛不让夜晚虚度，何况青春年少白白扔掉岁月呢？</strong>我出山后才几年就做到了廷尉评事，由于我办案公正受到朝廷赞赏，天子特赐我穿红袍系金腰带。最近淮南有一件疑案一直定不了案，案情上报到大理寺，皇上命令派一个干练的官员到淮南复审疑案，我被选中，所以才有这次淮南之行。我现在虽然还算不上飞黄腾达，但比起山中的老翁还是要强得多吧。裴兄你却仍像从前那样甘心在山中埋没了自己，我真是不能理解啊！不知裴兄需要什么东西，我一定满足你的要求。”</p>
<p>裴谌说：“我虽是个山中的平民，但早把心寄托于闲云野鹤，我怎么会像《庄子》中说得那样，让<strong>只腐烂的死鼠引起我的兴趣</strong>呢？<strong>我像鱼一样在江里游，你像鸟一样在天上飞，各有各的乐趣，你何必向我炫耀你那些浮名微利呢？人世间需要的东西我都非常充足，你能送我什么呢？</strong>我和山里的朋友一同到广陵卖药，也有个歇脚的地方。在青园楼的东边，有一个几里宽的樱桃园，园北有个行车的门，那就是我家。你公余之后如果有空，可以到那里找我。”裴谌说完，就潇洒地离去了。</p>
<p>王敬伯到广陵十几天后，空闲时想起了裴谌的话。就去找裴谌，找到了樱桃园，果然有个车门，一打听，果然是裴家。门上领王敬伯往里去。起初周围挺荒凉，越走景色越好。走了几百步后，又近了一个大门，门内楼阁重重，花草繁茂，好像不是凡人住的地方。雾气笼罩，景色无比秀丽，无法形容，阵阵香风袭人，令人神清气爽，飘飘然好像身在云中。</p>
<p>王敬伯此时的心情也大大转变了，觉得做官为宦实在没什么意思，自己的肉体像只死老鼠一样卑贱，看他那些同僚也像蚂蚁一样卑微了。不一会儿，听见轻微的佩剑撞击的声音，两个青衣女子出来说：“裴郎来了。”</p>
<p>只见一个仪表堂堂衣冠华贵的人来到面前，王敬伯赶快下拜，抬头一看，竟是裴谌。</p>
<p>裴谌安慰王敬伯说：“你长期在人间做官，久吃腥膻的鱼肉，<strong>心中尽是贪欲私心，像背着一个沉重的包袱使你步履艰难</strong>。”裴谌把王敬伯请到客厅，只见门窗屋梁都装饰着奇珍异宝，屏风帐幕都画着仙鹤。</p>
<p>不一会儿，四个青衣女子捧着碧玉的盘子进来，其中的器皿光彩照人，不是人间有的东西，摆上来的美酒佳肴也从来没吃过。天快黑时，裴谌请王敬伯入席，在室内点起了放射多种彩色的灯，照得室中光彩迷离。又叫来了二十个奏乐的女子，一个个都是绝代佳丽，列坐在王敬伯面前。</p>
<p>裴谌告诉管家说：“王敬伯是我山中的朋友，由于修道的意志不坚，扔下我下了山，离别十年了，他才做到廷尉，他的心已经完全归于凡俗了，所以就叫世间的妓女来让他取乐吧。我看花街柳巷的那些女子也太差了，你不妨在书香门第和官宦人家给他找一个女子来。如果近处没有美貌的，在五千里之内为他请一个也行。”</p>
<p>管家答应着出去了。那些奏乐女子就给碧玉筝调弦，弦还没调好。管家已经领了一个女子进来，向裴谌下拜。裴谌说：“快拜见王评事。”王敬伯也连忙向那女子还礼。仔细一看，竟是自己的妻子赵氏。</p>
<p>王敬伯大吃一惊，但没敢说什么，他妻子也很惊恐，不断地看他。裴谌让赵氏坐在玉石台阶下，一名侍女捧着玳瑁镶嵌的筝给了她。赵氏平时就很会弹筝，裴谌就让她和那些女子一起合奏以助酒兴。王敬伯趁裴谌不注意，从盘子里拿了一枚深色的红李子扔给妻子赵氏，赵氏看了看，把李子偷放在衣带里。那些女子演奏的曲子赵氏跟不上，裴谌就叫她们随着赵氏演奏，并常常让其余的女子停下演奏以显出赵氏的独奏。歌曲和音乐虽然不像《云门大卷》和《韶乐》这些古代名曲那样演奏后能引来凤凰，但旋律十分清亮，宛转动听，宾主敬酒酬答十分快活。</p>
<p>到天快亮时，裴谌召来管家让他送赵氏回去。并说：“这个厅堂是九天画堂，凡人是不能进的。但我过去和王敬伯是修道时的朋友，可怜他为世上的荣华迷了心窍，自己甘心赴汤蹈火，聪明反被聪明误，工于心计反害了自己，从此将在生生死死的苦海中沉浮，看不到彼岸，所以才故意请他到这里来，想使他开窍醒悟。今天一见之后，将来很难重逢。夫人你也是命中有缘到这里一游。你来往一次经过了万重云山，十分辛苦，我就不再说什么了。”</p>
<p>赵氏就拜别了裴谌。裴谌又对王敬伯说：“你身有公务，却在这里住了一宿，你的下属和郡里的官员会因找不到你而惊惶的，你就先回你的驿馆吧。在你没有回京复命前，还可以再来看我，尘世上的路漫长遥远。人在世上常常会有千愁万虑，望你多多珍重吧。”</p>
<p>王敬伯也拜谢辞别了裴谌。</p>
<p>五天后，王敬伯公务完毕要回京了，就偷偷又去找裴谌，想向他辞行。但到了樱桃园，车门内再也没有裴谌的华贵府邸，只是一块长满野草的荒地，心中十分惆怅他回去了。</p>
<p>王敬伯到京城复命之后，回到自己家去时，妻子赵氏全家都怒气冲冲找他理论，说：“我家女儿尽管丑陋配不上你，但既然行了大理和你成婚你就应该敬重她，这样才能上以继承祖业，下以传继后代，这是决不能有一点苟且的。可是你为什么用妖术把她弄到万里之外，让她当乐伎让外人取乐呢？那颗红李子还在，她说得也有根有据，你还想隐瞒吗？”王敬伯只好说了全部详情，并说：“当时我也没有办法，不知是怎么回事。看来是裴谌已经得道成仙，故意显示道术给我看看的。”妻子赵氏也记得裴谌当时说的那些话，说绝不是王敬伯用了妖术，大家才不再责骂王敬伯。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我常常听见别人家的孩子，我有个朋友怎么怎么样这样的言语。我上了大学，同学之间也在不断地比较，谁谁谁过的更好。裴谌、王敬伯、李芳三人行，求仙问道，李芳中途病逝，王敬伯退出去做官，收获了名与 利，裴湛坚持求仙问道，最终成仙。三人三种结局。</p>
<p>我的一家之言，在古人看来，比做官更好的应该是仙人了，这样的对比才说得过去。在如今，比做官更好的结局应该有所修正，因为不同人的价值取向不同，那么判定结果也不同。《庄子》一则故事中<strong>猫头鹰的腐烂的死鼠</strong>，他人所追求的，所放不下的，在另外一些有追求，有思想的人中，就像腐烂的死鼠，不值得追求。<strong>我像鱼一样在江里游，你像鸟一样在天上飞，各有各的乐趣，你何必向我炫耀你那些浮名微利呢？人世间需要的东西我都非常充足，这不就够了嘛？</strong></p>
<p>每个人在最开始选定了方向以后，因为什么外在原因，或者内在原因而中途放弃，中途改变，继而有了不同的结果。现实的情况是：比如两个一开始经历相似的好友，有着相同的目标，一个一直坚持下去，结果碌碌无为，一个及时转换目标，结果他个人很满意。未来这是，说不清的。或者，一直坚持的人有所成，但换目标的人，一直在换目标，结果就是一直在换目标了。</p>
<p>其实我感觉没有那么多适合，每一件事想要做到极致，都会有各种各样说不清的麻烦，但重要的还是要攻克难关。裴湛攻克了修仙难关，王敬伯换目标，也需要攻克了做官的难关，都是有所成之人？没必要互相比较。一个人想要的是在水里游，一个人想要的是在天上飞。</p>
<p>李芳呢？？？奋斗的过程也是幸福的，只能这么解释了😂😂。</p>
]]></content>
      <categories>
        <category>太平广记</category>
      </categories>
      <tags>
        <tag>神话</tag>
      </tags>
  </entry>
  <entry>
    <title>瞎bb时间</title>
    <url>/archives/55860cfb.html</url>
    <content><![CDATA[<p>上次写文章还是很早以前了，中间断断续续的在写，但是断断续续的在删。老色批又来了。</p>
<p>本次关于某<a href="http://xphone2020.applinzi.com/" target="_blank" rel="noopener">漫画网站</a>的漫画的爬取。<br><img src="/archives/55860cfb/image-20200619201112741.png" alt></p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>我在看一些视频网站，一些漫画网站，一些小说网站时，下面就有一些稀奇古怪的网站，你懂的。像我这样老色批就喜欢点进去看一看，上面就是这样的一个网站，估计以后就会改。</p>
<p>在该网站看漫画，前面几章是免费看的，看的心痒痒，但后面的几张就需要付费购买了。像我这样的穷屌丝，买是不可能买的，但又想看，只能花点时间白嫖，看能不能破解。</p>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>为了把整个网站的漫画都存到我的硬盘里面，需要得到所有漫画的名称，每本漫画的所有章节，以及每个章节的漫画图片。</p>
<ol>
<li><p>所有漫画名称</p>
<p>可以在找书一栏，看到所有的漫画</p>
<p><img src="/archives/55860cfb/image-20200619202739283.png" alt></p>
<p>用鼠标下滑，发现右边的XHR会不断的又新文件产生，因此分析一下这个文件的内容。</p>
<p><img src="/archives/55860cfb/image-20200619202921774.png" alt></p>
<p><img src="/archives/55860cfb/image-20200619202958829.png" alt></p>
<p>经过对比Request URL的内容，很容易就看出page=$i$发生了改变，因此参考网页，构造一个get请求就可以得到json内容了，Preview就是最后得到的json文件了，可以得到每本漫画的bookId了，比如”/book/info/id/819”,最后的数字414就是这本书的ID了</p>
<p><img src="/archives/55860cfb/image-20200619203603972.png" alt></p>
</li>
<li><p>有了这本书的Id，那么访问这本漫画，右边开发者栏，看到有3个XHR文件，稍微preview一下，infoOnload是这些人的评论啥的。</p>
<p><img src="/archives/55860cfb/image-20200619203724807.png" alt></p>
<p>在左侧点击目录，就出现了一个listOnload文件，preview就能看到看到各个章节信息。</p>
<p><img src="/archives/55860cfb/image-20200619204018052.png" alt></p>
<p>思路同上，还是看headers内容，这次是构造Post请求了。表单数据都有显示，是上面的漫画的ID</p>
<p><img src="/archives/55860cfb/image-20200619204401015.png" alt></p>
<p>最后经过爬取，可以得到本章节的ID，如这次的47972</p>
<p><img src="/archives/55860cfb/image-20200619204600180.png" alt></p>
</li>
<li><p>章节的ID也已经拿到，那么最后该拿该章节的所有图片了。</p>
<p><img src="/archives/55860cfb/image-20200619204955126.png" alt></p>
<p>在上面免费的第二话的XHR的preview中，可以看到有imgdata，imgdate2，这两个属性，我试着用浏览器访问其中的内容，是可以看到一些图片的。</p>
<p><img src="/archives/55860cfb/image-20200619205050413.png" alt></p>
<p>在上面收费的第8话的XHR的preview中，看到没有了imgdata属性，但是imgdata2属性还在，在尝试用浏览器能不能访问这些链接，发现居然是可以的，图片也是漫画的图片，那么至此，其实不需要破解收费其实也能够访问这些漫画。</p>
<p>不足之处：在imgdata2下，有一些链接是无法直接访问的，加上referen头也不行。姑且放过，这就导致章节中存在图片缺失，不过老色批会在意这个情节嘛？</p>
<p>最后只需要像上面构造post请求就行了，把图片链接都拿到，最后写好items，pipeline就行了。</p>
<p>最后展示一下最后的成果吧，部署在服务器上，还没有爬完。</p>
<p><img src="/archives/55860cfb/image-20200619211321243.png" alt></p>
</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>放<a href="https://github.com/Otaomp/xphone2020" target="_blank" rel="noopener">github</a>上了</p>
<p>写一下下github上传项目操作吧，怕自己又又又又忘了。</p>
<ol>
<li>网页github新建一个项目xphone2020</li>
<li>使用命令 $git\ clone\ xxxx$ 这个项目到本地，然后把代码复制到clone下的这个文件夹</li>
<li>使用命令 $ git \ add \ . $ 将代码文件全部添加到缓存中。</li>
<li>使用命令 $git \ commit -m \  ‘注释’$ ，表示提交，还没有真正提交。</li>
<li>使用命令$git \ push \ -u \ origin \  master$，（此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码）finished.</li>
</ol>
<p>github相关问题。</p>
<ol>
<li><p>配置账号：</p>
<p>首先配置user_name,email_name</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"你的github名"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.email <span class="string">"你的giuhub邮箱地址"</span></span><br></pre></td></tr></table></figure>

<p>然后生成公钥私钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"你的github邮箱"</span></span><br></pre></td></tr></table></figure>

<p>最后一路enter,可能需要输入密码</p>
<p>Your identification has been saved in /c/Users/pc/.ssh/id_rsa.<br>Your public key has been saved in /c/Users/pc/.ssh/id_rsa.pub.<br>将id_rsa.pub粘贴到github上的SSH key</p>
</li>
<li><p>原有账号删除</p>
<ul>
<li>运行一下命令缓存输入的用户名和密码：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper wincred</span><br></pre></td></tr></table></figure>

<ul>
<li>清除掉缓存在git中的用户名和密码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git credential-manager uninstall</span><br></pre></td></tr></table></figure>
</li>
<li><p>git的代理问题</p>
<p>本地开启VPN后，GIt也需要设置代理，才能正常略过GFW，访问goole code等网站</p>
<p>设置如下（可复制）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line"></span><br><span class="line">git config --global https.proxy https://127.0.0.1:1080</span><br><span class="line"></span><br><span class="line">git config --global http.proxy <span class="string">'socks5://127.0.0.1:1080'</span> </span><br><span class="line"></span><br><span class="line">git config --global https.proxy <span class="string">'socks5://127.0.0.1:1080'</span></span><br></pre></td></tr></table></figure>

<p>取消</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">b</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本来想着通过搜索，学习一些网站破解的知识，拿到一些特别的数据，结果，可能时因为小网站吧，数据加密也不严密，反爬虫策略也没有，中间学了不少post请求，头大。但最后的结果还算满意吧，一开口就懂了.</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title>第89场周赛</title>
    <url>/archives/bee0cf41.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-89/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="852-山脉数组的峰顶索引"><a href="#852-山脉数组的峰顶索引" class="headerlink" title="852. 山脉数组的峰顶索引"></a><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/" target="_blank" rel="noopener">852. 山脉数组的峰顶索引</a></h4><p><strong>题解：</strong>根据描述，只需要找到最大值所在的索引即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max_element(A.<span class="built_in">begin</span>(),A.<span class="built_in">end</span>())-A.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="853-车队"><a href="#853-车队" class="headerlink" title="853. 车队"></a><a href="https://leetcode-cn.com/problems/car-fleet/" target="_blank" rel="noopener">853. 车队</a></h4><h4 id="855-考场就座"><a href="#855-考场就座" class="headerlink" title="855. 考场就座"></a><a href="https://leetcode-cn.com/problems/exam-room/" target="_blank" rel="noopener">855. 考场就座</a></h4><h4 id="854-相似度为-K-的字符串"><a href="#854-相似度为-K-的字符串" class="headerlink" title="854. 相似度为 K 的字符串"></a><a href="https://leetcode-cn.com/problems/k-similar-strings/" target="_blank" rel="noopener">854. 相似度为 K 的字符串</a></h4>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>回溯算法</title>
    <url>/archives/376d0826.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>人生没有回溯！我多想回溯啊。（祝你生日快乐）</p>
<p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种<code>选优搜索法</code>，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
<a id="more"></a>

<p>回溯问题胃酸法1：递归解决问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">void findSolutions(n,other params):</span><br><span class="line">    <span class="keyword">if</span>(found a solution)<span class="comment"># 当找到一个解</span></span><br><span class="line">        solutionsFound = solutionsFound + <span class="number">1</span><span class="comment"># 解更新</span></span><br><span class="line">        displaySolution()<span class="comment"># 显示解</span></span><br><span class="line">        <span class="keyword">if</span> (solutionsFound &gt;= solutionTarget):<span class="comment"># 解不满足调节</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span>(val = first to last):<span class="comment"># 枚举各种状态</span></span><br><span class="line">        <span class="keyword">if</span>(isValid(val, n)): <span class="comment"># 该状态是否合法</span></span><br><span class="line">            applyValue(val, n)<span class="comment"># 使用该状态</span></span><br><span class="line">            findSolutions(n+<span class="number">1</span>, other params)<span class="comment"># 使用该值进行查找解</span></span><br><span class="line">            removeValue(val, n)<span class="comment"># 移除该状态</span></span><br></pre></td></tr></table></figure>

<p>胃酸法2：递归判断问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">boolean findSolutions(n, other params) :</span><br><span class="line">    <span class="keyword">if</span> (found a solution):</span><br><span class="line">        displaySolution()</span><br><span class="line">        <span class="keyword">return</span> true</span><br><span class="line">    <span class="keyword">for</span>(val = first to last):</span><br><span class="line">        <span class="keyword">if</span>(isValid(val, n)):</span><br><span class="line">            applyValue(val, n)</span><br><span class="line">            <span class="keyword">if</span> (findSolutions(n+<span class="number">1</span>, other params)):</span><br><span class="line">            	<span class="keyword">return</span> true</span><br><span class="line">            removeValue(val, n)</span><br><span class="line">        <span class="keyword">return</span> false</span><br></pre></td></tr></table></figure>

<h1 id="骑士旅行问题"><a href="#骑士旅行问题" class="headerlink" title="骑士旅行问题"></a>骑士旅行问题</h1><p>问题描述：一个骑士在国际象棋棋盘（8×8）中，给予其一个初始位置(0,0)，求其是否能够走完整个棋盘。</p>
<p>从(0,0)位置开始，枚举每一种走法，当该走法安全时，以该走法的终点做为新的起点，继续枚举，一直到走完，如果不能走完，那么重新标记该位置未走过。采用下一种走法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 8</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isSafe</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;sol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//当该位置合法且没有被访问</span></span><br><span class="line">	<span class="keyword">return</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; N &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp;y &lt; N &amp;&amp; sol[x][y] == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solveKTUtil</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> movei, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;sol, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; xMove, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;yMove)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (movei == N*N)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//1表示走成功了</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)<span class="comment">//尝试每一种走法</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> next_x = x + xMove[k];</span><br><span class="line">		<span class="keyword">int</span> next_y = y + yMove[k];</span><br><span class="line">		<span class="keyword">if</span> (isSafe(next_x, next_y, sol))<span class="comment">//当该走法安全时</span></span><br><span class="line">		&#123;</span><br><span class="line">			sol[next_x][next_y] = movei;<span class="comment">//该位置是第几步走到的</span></span><br><span class="line">			<span class="keyword">if</span> (solveKTUtil(next_x, next_y, movei + <span class="number">1</span>, sol, xMove, yMove) == <span class="number">1</span>)<span class="comment">//从该位置开始，继续走</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				sol[next_x][next_y] = <span class="number">-1</span>;<span class="comment">// 该位置走不通，标记没走过</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSolution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;sol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; N; x++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; N; y++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" %2d "</span>, sol[x][y]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solveKT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;sol(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">-1</span>));</span><br><span class="line">	<span class="comment">//骑士的马走法</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;xMove = &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;yMove = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">	sol[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (solveKTUtil(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, sol, xMove, yMove) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Solution does not exist"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		printSolution(sol);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的结果。</p>
<p><img src="/archives/376d0826/1.png" alt="image-20200501214653363"></p>
<h1 id="老鼠走迷宫问题"><a href="#老鼠走迷宫问题" class="headerlink" title="老鼠走迷宫问题"></a>老鼠走迷宫问题</h1><p>有4×4的迷宫，老鼠从（0，0）处开始出发，1表示可行，0表示不可行。老鼠只能向右或者向下走。如何才可以到到达终点。白色可走，灰色为墙。</p>
<p><img src="/archives/376d0826/2.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSafe</span><span class="params">(<span class="keyword">int</span> maze[N][N], <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="comment">//表示位置x，y处是否是可以走的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; N &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; N &amp;&amp; maze[x][y] == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSolution</span><span class="params">(<span class="keyword">int</span> sol[N][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" %d "</span>, sol[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solveMazeUtil</span><span class="params">(<span class="keyword">int</span> maze[N][N], <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> sol[N][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == N - <span class="number">1</span> &amp;&amp; y == N - <span class="number">1</span> &amp;&amp; maze[x][y] == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sol[x][y] = <span class="number">1</span>;<span class="comment">//到达目的地</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isSafe(maze, x, y) == <span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sol[x][y] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (solveMazeUtil(maze, x + <span class="number">1</span>, y, sol) == <span class="literal">true</span>)<span class="comment">//往右走</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (solveMazeUtil(maze, x, y + <span class="number">1</span>, sol) == <span class="literal">true</span>)<span class="comment">//往下走</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		sol[x][y] = <span class="number">0</span>;<span class="comment">//上面均不成功，回退，标记0，表示走不通</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solveMaze</span><span class="params">(<span class="keyword">int</span> maze[N][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sol[N][N] = &#123; &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (solveMazeUtil(maze, <span class="number">0</span>, <span class="number">0</span>, sol) == <span class="literal">false</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Solution doesn't exist"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printSolution(sol);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maze[N][N] = &#123; &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,&#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;,&#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">	solveMaze(maze);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h1><p>有N×N的棋盘，怎么把N个皇后放到棋盘上并且保证他们不互相攻击。</p>
<p>解决思路很简单，首先把一个皇后放到某一列中，那么下一个皇后只能放到上一个皇后攻击不到的范围内。满足所有条件的N皇后。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSafe</span><span class="params">(<span class="keyword">int</span> board[N][N], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//检测左边是否安全即可，右边还没有添加</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++)</span><br><span class="line">		<span class="keyword">if</span> (board[row][i]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//所在行是不是安全的</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = row, j = col; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--)</span><br><span class="line">		<span class="keyword">if</span> (board[i][j]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//检测左上走，行减列减</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = row, j = col; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; N; i++, j--)</span><br><span class="line">		<span class="keyword">if</span> (board[i][j]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//检测左下走，行加，列减</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solveNQUtil</span><span class="params">(<span class="keyword">int</span> board[N][N], <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (col == N)&#123;</span><br><span class="line">        <span class="comment">//处理结果</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isSafe(board, i, col)) &#123;</span><br><span class="line">			board[i][col] = <span class="number">1</span>;<span class="comment">//当前试探是安全的，可以添加</span></span><br><span class="line"></span><br><span class="line">			ret = ret||(solveNQUtil(board, col + <span class="number">1</span>))<span class="comment">//继续向右添加</span></span><br><span class="line">			board[i][col] = <span class="number">0</span>; <span class="comment">// 不安全，只能返回原有状态</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="m-着色问题"><a href="#m-着色问题" class="headerlink" title="m-着色问题"></a><a href="https://en.wikipedia.org/wiki/Graph_coloring" target="_blank" rel="noopener">m-着色问题</a></h1><p>给定一个无向图（输入二维邻接矩阵，顶点数为V）和可以使用的颜色种类数m，确定该图是否可以最多使用m种颜色着色，并且保证该图相邻两顶点颜色着色不同。结果数组为color[i]=1…m， 表示分配给第 i 个顶点的颜色。</p>
<p>该图为三着色。</p>
<p><img src="/archives/376d0826/D:%5Chexo%5Cmyblog%5Csource%5C_posts%5C3.png" alt></p>
<p>回溯思虑：从顶点 0 开始，逐个将给不同的顶点涂色。在涂色之前，检查相邻顶点是否具有相同的颜色。如果涂色方案不冲突，则将该顶点涂色。如果无法分配颜色，则回溯并返回 false。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">graphColoringUtil</span><span class="params">(<span class="keyword">bool</span> graph[V][V], <span class="keyword">int</span> m, <span class="keyword">int</span> color[], <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v == V) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= m; c++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (isSafe(v, graph, color, c))</span><br><span class="line">		&#123;</span><br><span class="line">			color[v] = c;</span><br><span class="line">			<span class="keyword">if</span> (graphColoringUtil(graph, m, color, v + <span class="number">1</span>) == <span class="literal">true</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			color[v] = <span class="number">0</span>;<span class="comment">//回溯</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSafe</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">bool</span> graph[V][V], <span class="keyword">int</span> color[], <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">		<span class="keyword">if</span> (graph[v][i] &amp;&amp; c == color[i])<span class="comment">//检查与顶点v相邻的顶点颜色是否与要图的颜色冲突</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="求解哈密顿回路"><a href="#求解哈密顿回路" class="headerlink" title="求解哈密顿回路"></a>求解哈密顿回路</h1><p>哈密尔顿图定义： 若从某个顶点出发，有且仅经过其他顶点一次，并且再回到起点，这样的图成为哈密顿图，该回路称为哈密顿回路。</p>
<p>哈密尔顿图的必要条件： 若G=(V,E) 是一个哈密尔顿图，则对于V的每一个非空子集S，均有W(G－S) ≤|S|。其中|S|是S中的顶点数，W(G－S)表示图G擦去属于S中的顶点后，剩下子图的连通分枝的个数。</p>
<p>哈密尔顿图的充分条件： 设G=(V,E)是一个无向简单图，|V|=n. n≥3. 若对于任意的两个顶点u，v∊V，d(u)+d(v) ≥n，那么, G是哈密尔顿图 。</p>
<p>创建一个空路径数组，并将顶点 0 添加到其中。添加其他顶点，从顶点 1 开始。在添加顶点之前，检查它是否与以前添加的顶点相邻且尚未被添加。如果我们找到这样的顶点，我们会添加该顶点到结果中。如果我们找不到顶点，则返回 false。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSafe</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">bool</span> graph[V][V],<span class="keyword">int</span> path[], <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (graph[path[pos - <span class="number">1</span>]][v] == <span class="number">0</span>)<span class="comment">//v与path[pos-1]的节点是否连通</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; i++)<span class="comment">//当当前节点在路径数组中，说明这个节点加入到path中不安全的</span></span><br><span class="line">		<span class="keyword">if</span> (path[i] == v) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hamCycle</span><span class="params">(<span class="keyword">bool</span> graph[V][V],<span class="keyword">int</span> path[], <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos == V)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (graph[path[pos - <span class="number">1</span>]][path[<span class="number">0</span>]] == <span class="number">1</span>)<span class="comment">//是否返回到起点</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt; V; v++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (isSafe(v, graph, path, pos))<span class="comment">//逐个探查每一个位置</span></span><br><span class="line">		&#123;</span><br><span class="line">			path[pos] = v;<span class="comment">//如果是安全的，那么该位置可以设置为v</span></span><br><span class="line">			<span class="keyword">if</span> (hamCycle(graph, path, pos + <span class="number">1</span>) == <span class="literal">true</span>)<span class="comment">//继续下一个位置</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			path[pos] = <span class="number">-1</span>;<span class="comment">//回溯</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DST</category>
      </categories>
      <tags>
        <tag>DST</tag>
      </tags>
  </entry>
  <entry>
    <title>堆</title>
    <url>/archives/fab451a5.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>堆，顾名思义，是长得像个草堆一样的数据结构。但在计算机存储里面，堆一般使用数组来表示。</p>
<p><img src="/archives/fab451a5/1.jpg" alt></p>
<p>按照堆的性质区分，可分为大顶堆，小顶堆。<br>大顶堆：所有的parent节点值都要<code>大于</code>其child节点。<br>小顶堆：所有的parent节点值都要<code>小于</code>其child节点。</p>
<a id="more"></a>

<p>堆有三个主要的操作：</p>
<ol>
<li><p>Heaplify，时间复杂度$O(lgn)$，作用是维护堆的性质。</p>
<p>对于某个节点，如果不满足堆的性质，需要堆这个节点加一调整。调整的流程是，以大顶堆为例，倘若parent节点小于其子节点，需要进行交换，交换后，被交换的子节点也可能不满足大顶堆的性质，需要堆这个子节点继续进行heaplify。<br>以下是算法导论伪代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Max_Heaplify(A,i): <span class="comment"># 对大顶堆A的位置i处进行调整，A的本质是一个数组</span></span><br><span class="line">	l = Left(i) <span class="comment"># l表示i处节点的左孩子位置</span></span><br><span class="line">    r = Right(i) <span class="comment"># r表示i处节点的右孩子位置</span></span><br><span class="line">    <span class="keyword">if</span> l&lt;=A.heap_size() <span class="keyword">and</span> A[l]&gt;A[i]<span class="comment"># 若左孩子大于parent节点值</span></span><br><span class="line">    	largest = l</span><br><span class="line">    <span class="keyword">else</span> largest = i</span><br><span class="line">    <span class="keyword">if</span> r&lt;=A.heap_size() <span class="keyword">and</span> A[r]&gt;A[i]<span class="comment"># 若右孩子大于parent节点值</span></span><br><span class="line">    	largest = r</span><br><span class="line">    <span class="keyword">if</span> largest!=i <span class="comment">#当最大值不是在i处</span></span><br><span class="line">    	swap(A[i],A[largest])</span><br><span class="line">        Max_heaplify(A,largest)<span class="comment"># 对被交换的节点进行Max_Heaplify</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Build_Heap，时间复杂度$O(n)$，作用是使用n个元素建立一个堆。</p>
<p>对于给定的数组A，将他调整为一个堆。需要做的是从<code>最后一个非叶子节点</code>开始，一直到根节点，不断进行Heaplify。最后一个非叶子节点恰好位于元素中间位置。以建立一个大顶堆为例，以下是算法导论伪代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BUild_Max_Heap(A):<span class="comment"># A的本质是一个数组，调整结束后还是一个数组</span></span><br><span class="line">	A.heap_size = A.length</span><br><span class="line">    <span class="keyword">for</span> i= A.length/<span class="number">2</span> downto <span class="number">1</span>:</span><br><span class="line">        Max_Heaplify(A,i)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Heap_insert，时间复杂度$O(lgn)$，作用是向堆中插入一个元素。<br>首先需要在数组末尾增加一个元素，数组长度加一。并不断将该元素与其父节点进行比较，如果不满足堆的性质，则发生交换。交换后的父节点也可能不满足堆的性质，因此需要继续调整。将该父节点与他的父节点进行调整，一直到满足堆的性质，或调整到了根节点。以大顶堆为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Max_Heap_Insert(A,elem):</span><br><span class="line">	A.length = A.length+<span class="number">1</span> <span class="comment"># 数组长度加一</span></span><br><span class="line">	A[length+<span class="number">1</span>] = elem <span class="comment"># 在数组末尾加入该元素</span></span><br><span class="line">	pos = A.length <span class="comment"># 最后的位置</span></span><br><span class="line">	<span class="keyword">while</span> pos&gt;<span class="number">1</span> <span class="keyword">and</span> A[parent(pos)]&lt;A[pos]: <span class="comment"># 调整加入节点与父节点的关系</span></span><br><span class="line">		swap(A[pos],A[parent(pos)])</span><br><span class="line">		pos = parent(pos)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>堆引申出来的堆排序</p>
<p>如果要对数组进行升序排序，需要使用大顶堆。建立大顶堆后，将大顶堆的堆顶元素与堆末尾元素进行交换，然后再调整交换后的堆顶，不过此时堆的大小减一，最后位置元素不可参与堆调整范围里。如此反复。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HeapSort(A):</span><br><span class="line">    BUild_Max_Heap(A)</span><br><span class="line">    <span class="keyword">for</span> i = A.lenght to <span class="number">2</span>: <span class="comment"># 当堆只剩一个元素，不用调整了,所以到2</span></span><br><span class="line">        swap(A[<span class="number">1</span>],A[i])<span class="comment"># 交换堆顶元素与堆末尾元素</span></span><br><span class="line">        A.heap_size = A.heap_size<span class="number">-1</span></span><br><span class="line">        Max_Heaplify(A,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="C-STL中与heap有关操作"><a href="#C-STL中与heap有关操作" class="headerlink" title="C++ STL中与heap有关操作"></a>C++ STL中与heap有关操作</h1><ol>
<li>make_heap()  用给定的数据建立一个堆，默认大顶堆，小顶堆要设置比较函数，保证最大值在所给范围的最前面，其他值的位置不确定</li>
<li>push_heap() 往堆中压入一个元素</li>
<li>pop_heap() 排出堆顶元素</li>
<li>is_heap():这个函数用于检查容器是否是heap。</li>
<li>is_heap_until():-此函数第一个不满足堆性质的元素迭代器。</li>
<li>sort_heap() 堆排序，默认升序，对象必须已经是堆</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVec</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	locale::global(<span class="built_in">std</span>::locale(<span class="string">""</span>));</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = &#123; <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">25</span>, <span class="number">15</span> &#125;;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"原始数组v1："</span>;</span><br><span class="line">	printVec(v1);</span><br><span class="line">	make_heap(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());<span class="comment">//将vector v1弄成了大顶堆,v1还是vector，不过具有heap性质</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"make_heap以后："</span>;</span><br><span class="line">	printVec(v1);</span><br><span class="line">	<span class="comment">//make_heap(v1.begin(), v1.end(),greater&lt;int&gt;());//将vector v1弄成了大顶堆</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; "堆顶元素" &lt;&lt; v1.front() &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	v1.push_back(<span class="number">50</span>);</span><br><span class="line">	push_heap(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"push 一个元素以后："</span>;</span><br><span class="line">	printVec(v1);</span><br><span class="line">	<span class="comment">//push_heap之前还是push_back了一下，这么看来和make_heap好像没啥区别</span></span><br><span class="line"></span><br><span class="line">	pop_heap(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());<span class="comment">//将堆顶元素与最后一个元素交换，并未真正删除</span></span><br><span class="line">	v1.pop_back();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"pop_heap以后："</span>;</span><br><span class="line">	printVec(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判定vector v1是否为堆</span></span><br><span class="line">	is_heap(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>()) ?<span class="built_in">cout</span> &lt;&lt; <span class="string">"The container is heap "</span> :<span class="built_in">cout</span> &lt;&lt; <span class="string">"The container is not heap"</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//堆排序。仅对已经是堆的v1进行堆排序，不然出错，结果不对</span></span><br><span class="line">	sort_heap(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"堆排序之后: "</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : v1)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">80</span>,<span class="number">30</span>, <span class="number">45</span>,<span class="number">1</span>, <span class="number">55</span>, <span class="number">15</span> &#125;;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"原始数组v2："</span>;</span><br><span class="line">	printVec(v2);</span><br><span class="line">	<span class="keyword">auto</span> it = is_heap_until(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// Displaying heap range elements</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"从v2开始到第一个不满足堆性质的元素: "</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it1 = v2.<span class="built_in">begin</span>(); it1 != it; it1++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it1 &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/archives/fab451a5/2.png" alt></p>
<ol start="7">
<li>priority_queue</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序队列 </span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; q; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>&#125;)</span><br><span class="line">    q.push(n);</span><br><span class="line">print_queue(q);</span><br></pre></td></tr></table></figure>

<h1 id="将数组的元素相加直到每个元素都大于等于k"><a href="#将数组的元素相加直到每个元素都大于等于k" class="headerlink" title="将数组的元素相加直到每个元素都大于等于k"></a>将数组的元素相加直到每个元素都大于等于k</h1><p>描述：给定一个数组，和一个K值，将数组中的一些元素拿出后再相加后再加入到数组中，一直到数组中所有元素都大于等于K。求这最小相加次数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input:arr &#x3D; &#123;1 10 12 9 2 3&#125; K &#x3D; 6</span><br><span class="line">输出:2</span><br></pre></td></tr></table></figure>

<p>解释：首先将拿出数组中的1和2相加，得到3，再将3加入到数组中，数组变成了$[3,10,12,9,3]$，然后再拿出3 和3，并相加，得到6，再将6加入到数组中，数组变成了$[6,10,12,9]$，现在数组中的所有元素都大于等于6。因此，需要相加两次。</p>
<p>其实就是<a href="https://en.wikipedia.org/wiki/Huffman_coding" target="_blank" rel="noopener">霍夫曼编码</a>。用原数组建成一个小顶堆，之后取堆顶最小的两个元素，相加后再加入到堆中，一直到这个小顶堆的堆顶大于给定的K。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countMinOps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : nums)q.push(i);<span class="comment">//建小顶堆</span></span><br><span class="line">	<span class="keyword">while</span> (q.top() &lt; k&amp;&amp;q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> a = q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">int</span> b= q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		q.push(a + b);</span><br><span class="line">		ret++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DST</category>
      </categories>
      <tags>
        <tag>DST</tag>
      </tags>
  </entry>
  <entry>
    <title>杜子春</title>
    <url>/archives/f2fd9a72.html</url>
    <content><![CDATA[<h2 id="故事梗概"><a href="#故事梗概" class="headerlink" title="故事梗概"></a>故事梗概</h2><p>这杜子春是南北朝时期，周朝至隋朝的人。他这个人呢，家里有点钱，整天无所事事，纵酒闲游，最后把家产都败光了。然后迫于生计，去投奔亲友，但亲友们都认为他是那种游手好闲之人，都不愿意收留他。这时的杜子春真的是到了人生谷底，饥寒交迫，孤苦无依。 </p>
<p>说这时来了一个老人，拄着拐杖，来到杜子春面前，问他为何留宿街头，杜子春就把自己的经历告诉了他，埋怨亲友们对他无情无义，越说越激动，越说越愤慨。老人问他：几缗则丰用？杜子春答道，三五万则可以活矣。老人又说：未也？认为杜子春要的太少，不够，经过一番言价，最后杜子春答定：三百万足以。于是这老人就给了杜子春三百万。杜子春拿到了这么多钱，又开始了他的醉生梦死的生活，只用了一两年，钱财挥霍尽空。又如上次那般，穷途末路，在街头长叹起来，感慨人生。 </p>
<a id="more"></a>

<p>这时那个老人又出现了，说还要帮助他，这时的杜子春就有些羞愧难当了，不好意思开口。老人再三逼问，杜子春就惭愧的赔礼道歉。老人最后给了他一千万，叫他这次奋发向上，置办家业，把古时候的大富翁石崇，猗顿给比下去。</p>
<p>可，这钱一到手，杜子春的心境就变了，又开始了他的挥霍无度的生活，又过了一两年，两手空空，比上次还惨。这人呢，在长安街头徘徊，又碰到了给他钱的老头，这次给了他三千万。并言道：此而不痊，则子贫在膏育矣。</p>
<p>杜子春这次聪明了，开始思考了，如何处置这些钱财？他定了一个小目标，今后不但自立，而且要周济天下孤儿寡母，取得一番成就。并与老人做了约定，待目标完成，老庙前，树下相约。于是乎来到了扬州。那时候孤儿寡母大多在淮南。他建造了许多房子，给孤儿寡母们居住。完成了小目标后，如期赴约。</p>
<p>老人见到杜子春后，就领他登上华山云台峰。进山四十多里后，来到一个地方，见到一幢高大严整的房舍，看样子非凡人所住。彩云遥覆，惊鹤飞翔其上。屋子的正堂中间，有一个九尺多高的炼丹炉子，炉内紫光闪耀。玉女九人，环炉而立，青龙白虎，分据前后。</p>
<p>这时天快黑了，再看那老人，身上穿的已不是凡间的衣服，而是穿着黄道袍，戴着黄道冠，一副仙师模样。仙师拿了三个白石丸和一杯酒给了杜子春，让他赶快吃下去。仙师又拿了一张虎皮，铺在内屋西墙下，面朝东坐下，告诫杜子春：“你千万不要出声。这里出现的尊神、恶鬼、夜叉或者地狱、猛兽；以及你的亲属们被绑着受刑遭罪，这一切都不是真事。你不论看见什么惨状，都不要说话，安心别害怕，那就绝不会对你有什么伤害，千万牢记我的叮嘱”。</p>
<p>仙师去后，杜子春向院里看，院里有一个装满了水的大瓮，此外什么也没有了。道士刚走，杜子春就听见外面，人喊马叫，震天动地，只见满山满谷都是士兵，旌旗飘飘，戈矛闪闪，千乘万骑蜂拥而来。有一个人自称大将军，身高一丈多，他本人和他的马 都披着金铠甲，光芒耀眼。大将军的卫士就有几百人，都举着剑张着弓，一直来到屋前，大声呵斥杜子春说：”你是什么人？ 大将军到了怎么竟不回避！“有些卫士还用剑逼着杜子春问他的姓名，还问他在做什么，他都一声也不吭。见他不出声，卫士们大怒，一声声喊叫着”杀了他！“”射死他！“杜子春仍是不出声，那个大将军只好怒气冲冲地带着队伍走了。</p>
<p>过了片刻，又来了一群的猛虎毒龙、狮子，蝮蛇和毒蝎，争先恐后地扑向杜子春要撕碎他、吞食他，有的还在他头顶跳来跳去张牙舞爪，杜子春仍是不动声色，过了一会儿，这些毒蛇猛兽也都散去了。</p>
<p>这时突然大雨滂沱、雷电交加，天昏地暗、伸手不见五指，不一会儿又有大火轮燃烧着在他左右滚动，光芒在身前身后闪耀，亮得眼都睁不开。片刻之间，院子里水深一丈多，空中雷声隆隆电光闪闪，像要让山峰崩塌，河水倒流，势不可挡。一眨眼的工夫滚滚的浪涛涌到杜子春的坐位前，他仍是端端正正坐着连眼皮也不眨一 下。接着那位大将军又来了，领着一群地狱中的牛头马面和狰狞的厉鬼，将一口装满滚开的水的大锅放在杜子春面前，鬼怪们 手执长矛和两股铁叉，命令道：”说出你的姓名，就放了你，如果不说，就把你放在锅煮！“杜子春仍不说话。</p>
<p>这时鬼怪们又把他的妻子抓来绑在台阶下，指着他妻子向杜子春说：”说出你的姓名，就放了她。“杜子春还是不做声。于是鬼怪们鞭打他的妻子，用刀砍她，用箭射她，一会儿烧，一会儿煮，百般折磨惨不忍睹。他妻子苦不堪忍，就向杜子春哭号道：”我虽然又丑又笨，配不上你，但我毕竟给你作了十几年妻子了。现在我被鬼抓来这样折磨，我实在受不了啦！我不敢指望你向他们跪伏求情，只希望你说一句话，我就能活命了。人非无情，丈夫你就忍心不出声，让我继续受折磨吗？“他妻子边哭边喊，又咒又骂，杜子春始终不理不睬。那位大将军也说：”你不说话，我还有更毒辣的手段对付你老婆！“说着命令抬来了锉碓，从脚上开始一寸寸地锉他的妻子。妻子哭声越来越高，杜子春还是连看也不看。</p>
<p>大将军说：”这个家伙有妖术，不能留他在世上！“于是命令左右，把杜子春斩了，然后带着他的魂魄去见阎王。阎王一见杜子春就说：”这不是云台峰的那个妖民吗？给我把他打入地狱里去！“于是杜子春受尽了上刀山下火海，所有的地狱酷刑。然而他心里仍牢记着那位仙师的叮嘱，咬着牙都挺过来了，连叫都不叫一声。后来，地狱的鬼卒向阎王报告，说所有的刑罚都给杜子春用完了。阎王说：”这个家伙阴险毒恶，不该让他当男人，下辈子让他做女人！“</p>
<p>于是让杜子春投胎转世到了宋州单父县的县丞王劝家。杜子春转世为女子，一生下来就体弱多病，扎针吃药一天没断过，还掉进火里摔到床下，受了无数的苦，但杜子春始终不出声。转眼间杜子春长成了一个容貌绝代的女子，但就是不说话，县丞王劝的全家认为她是个哑女。有些人对她百般侮辱调戏，杜子春总是一声不吭。</p>
<p>县丞的同乡有个考中了进士的人叫卢生，听说县丞的女儿容貌很美，就很倾慕，就求媒人去县丞家提媒。县丞家借口是哑女，把媒人推辞了。卢生说：”妻子只要贤惠就好，不会说话 有什么关系呢？正好给那些长舌妇作个榜样。“县丞就答应了婚事。卢生按照规矩施行了六礼，和杜子春办了婚事。两个人过了几年，感情非常好，生了一个男孩，男孩已经两岁了，十分聪明。卢生抱着孩子和她说话，她不吭声，想尽办法逗她也不说话。卢生大怒说：”古时贾大夫的妻子瞧不起他，始终不笑，但后来妻子看见贾大夫射了山鸡，也就对他无憾了。我虽然地位不如贾大夫，但我的才学比会射山鸡不强百倍吗？可是你却不屑于跟我说话！大丈夫被妻子瞧不起，还要她的儿子做什么！“说着就抓起男孩的两腿扔了出去，孩子的头摔在石头上，顿时脑浆迸裂，鲜血溅出好几步远。</p>
<p>杜子春爱子心切，一时间忘了仙师的嘱咐，不觉失声喊道：”咦！……“声还没落，发现他自己又坐在云台峰的那间道观中，他的仙师也在面前。这时是黎明时分，突然紫火窜上了屋梁，转眼间烈火熊熊，把屋子烧毁了。仙师说：”你这个穷酸小子，可把我坑苦了！“说就提着杜子春的头发扔进水瓮里，火立刻就灭了。仙师说：”在你的心里，喜、怒、哀、惧、恶、欲都忘掉了，只有爱你还没忘记。卢生摔你孩子时，你若不出声，我的仙丹就能炼成，你也就能成为上仙了。可叹啊，仙才真是太难得了！我的仙丹可以再炼，但你却还得回到人间去，以后继续勤奋地修道吧！“说完给他向远方指了路，让他回去。临走时，他登上烧毁的房基，看见那炼丹炉已坏了，当中有个铁柱子，有手臂那么粗，好几尺长，那仙师正脱了衣服，用刀子削那铁柱 子。杜子春回到家后，非常悔恨他，当初忘了对仙师发的誓，想回去找到仙师为他效力，以补偿自己的过失。他再来到云台峰什么也没找到，只好怀着惋惜悔恨的心情回去了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>浪子回头，真的需要钱。</li>
<li>人世间最真挚的感情，应该是母子之情，那什么爱情，父子之情都要靠后站一站。</li>
<li>完成一件事，难在坚持。</li>
</ol>
]]></content>
      <categories>
        <category>太平广记</category>
      </categories>
      <tags>
        <tag>神话</tag>
      </tags>
  </entry>
  <entry>
    <title>今日🤦‍</title>
    <url>/archives/e0c67a5d.html</url>
    <content><![CDATA[<p>👨的头好疼啊。</p>
<p><img src="/archives/e0c67a5d/1.gif" alt></p>
<p>于是乎去吃了一个苹果，苹果很老，上面还坏了一点，但是很甜。我想起那句话，叫虫喜欢吃的苹果越甜。</p>
<p>人如苹果，越老的苹果故事越多。越被虫盯上的苹果就是越有本领。<br>我又回想起今天再路上的一只猫，被压死的猫。这只猫在被呼啸而过的汽车碾过的时候，它是不是还在挣扎，可是我挣扎的动吗？我除了有一点意识外，身体已经不受支配了，我在不断的抽搐，嘴角冒出一点鲜血，我看着后面的汽车相继在我身边驶过，我庆幸的是他们没有在我不能动弹的身体上驶过，我悲伤的是没有一个人来帮我，让我离开马路中间。我想起在被压倒之前，我可以飞快的奔跑，也能从容的上树，但我现在动弹不了，而后又有一辆车在我身上驶过，他应该是无意的，我本就不该躺在马路中间，我没了意识。再看时，我已经一动不动了，我知道我变成了一摊腐肉。</p>
]]></content>
  </entry>
  <entry>
    <title>图</title>
    <url>/archives/b1c317b.html</url>
    <content><![CDATA[<h1 id="图及其表示方式"><a href="#图及其表示方式" class="headerlink" title="图及其表示方式"></a>图及其表示方式</h1><p>图由两个部分组成，一是点node，二是边edge。<br>图的表示方法由邻接表法和邻接矩阵法。当然还有其他的方式。<br>如下所示，有一无向图，其邻接表和邻接矩阵示意图为：</p>
<a id="more"></a>

<p><img src="/archives/b1c317b/1.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> V;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; *adj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Graph(<span class="keyword">int</span> V);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">	adj = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[V];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graph::addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	adj[v].push_back(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="图的广度优先遍历及应用"><a href="#图的广度优先遍历及应用" class="headerlink" title="图的广度优先遍历及应用"></a>图的广度优先遍历及应用</h1><p>如图所示：，从源点2开始且标记访问，与2相邻的0，3入队，并标记已经访问过。结束后，0出队，与0相邻的1，入队，由于2已经标记访问过了，不在入队。3也是如此。遍历结果2，0，3，1.<br><img src="/archives/b1c317b/2.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 标记未被访问过的节点</span></span><br><span class="line">    <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[V];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// 用于BFS的队列</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">    <span class="comment">// 标记当前节点已被访问并且入队</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">queue</span>.push_back(s);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())&#123;<span class="comment">//开始BFS</span></span><br><span class="line">        s = <span class="built_in">queue</span>.front();</span><br><span class="line">        <span class="built_in">queue</span>.pop_front();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历与s相连接的顶点，这些点存在adj[s]中</span></span><br><span class="line">        <span class="keyword">for</span> (i = adj[s].<span class="built_in">begin</span>(); i != adj[s].<span class="built_in">end</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[*i])&#123;</span><br><span class="line">                visited[*i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">queue</span>.push_back(*i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用：</p>
<ol>
<li>无权图的最小生成树和最短路径。</li>
<li>点对点网络。在点对点网络中，比如BitTorrent，广度优先搜索用于查找所有邻居节点。</li>
<li>搜索引擎中的爬虫。</li>
<li>社交网站：在社交网络中，我们可以找到某个特定的人距离为“K”的所有人。</li>
<li>GPS导航：使用广度优先搜索查找所有邻近位置。</li>
<li>网络广播:在网络中，广播机制是优先搜索所有相邻可达到节点。</li>
<li><a href="https://lambda.uta.edu/cse5317/notes/node48.html" target="_blank" rel="noopener">垃圾收集</a></li>
<li>无向图的环检测:在无向图中，BFS或DFS可以用来检测循环。在有向图中，只有深度首先可以使用搜索。</li>
<li>在Ford-Fulkerson算法中，可以使用广度先或深度先遍历，找到最大流。优先考虑BFS，时间复杂度更小。</li>
<li>判断一个图是否是可以二分，既可以使用广度优先，也可以使用深度优先遍历。</li>
<li>判断两个点之间是否存在路径。</li>
<li>从给定节点中，查找可以访问的所有节点。</li>
</ol>
<h1 id="图的深度优先遍历及应用"><a href="#图的深度优先遍历及应用" class="headerlink" title="图的深度优先遍历及应用"></a>图的深度优先遍历及应用</h1><p>从源点2开始，并标记已经访问2了，之后查找它的所有相邻顶点，重复上面操作。下面的访问顺序之一为2,0,1,3。<img src="/archives/b1c317b/2.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">bool</span> visited[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	visited[v] = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">	<span class="keyword">for</span>(i= adj[v].<span class="built_in">begin</span>(); i != adj[v].<span class="built_in">end</span>(); ++i)</span><br><span class="line">	<span class="keyword">if</span> (!visited[*i])</span><br><span class="line">		DFS(*i, visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用</p>
<ol>
<li>对于无权图，DFS可以生成最小生成树。</li>
<li>检测图中是否有循环。</li>
<li>查找给定节点uv之间是否有路径</li>
<li>拓扑排序</li>
<li>判断一个图是否可以二分</li>
<li>寻找图的强连通分量</li>
<li>迷宫问题</li>
</ol>
<h1 id="深度优先遍历的非递归实现"><a href="#深度优先遍历的非递归实现" class="headerlink" title="深度优先遍历的非递归实现"></a>深度优先遍历的非递归实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">	<span class="built_in">stack</span>.push(s);</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">stack</span>.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		s = <span class="built_in">stack</span>.top();</span><br><span class="line">		<span class="built_in">stack</span>.pop();</span><br><span class="line">		<span class="keyword">if</span> (!visited[s]) visited[s] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> i = adj[s].<span class="built_in">begin</span>();i != adj[s].<span class="built_in">end</span>();++i)</span><br><span class="line">			<span class="keyword">if</span> (!visited[*i])</span><br><span class="line">				<span class="built_in">stack</span>.push(*i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，当图不是完全有向图的，需要对每个节点，重复调用DFS，这样才能遍历到每个节点。</p>
<h1 id="检测有向图中是否有环"><a href="#检测有向图中是否有环" class="headerlink" title="检测有向图中是否有环"></a>检测有向图中是否有环</h1><p><img src="/archives/b1c317b/2.png" alt></p>
<p>如在上图中，是存在0-&gt;2-&gt;0这样的环。3-&gt;3的环。当且仅当存在一条后向边才可以认为图中有环。后向边(u,v)是指节点u连接到其在深度优先搜索树中的一个祖先节点v这样的一条边。3-&gt;3这样的自循环也可以认为是一条后向边。</p>
<p>为了检测图中的后向边，对DFS递归函数的中递归栈进行跟踪。如果我们当前遍历的顶点出现在递归栈中，那么就认为存在一条后向边，图中存在循环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Graph::isCyclic</span><span class="params">(<span class="keyword">int</span> v, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;visited, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;recStack)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//recStack表示递归栈</span></span><br><span class="line">        <span class="keyword">if</span> (visited[v] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            visited[v] = <span class="literal">true</span>;</span><br><span class="line">            recStack[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i=adj[v].<span class="built_in">begin</span>(); i != adj[v].<span class="built_in">end</span>();++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果节点v所连接的另一边节点i还没有被访问，</span></span><br><span class="line">                <span class="comment">//并且在节点i处存在环，那么真的存在环</span></span><br><span class="line">                <span class="keyword">if</span>(!visited[*i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(isCyclic(*i, visited, recStack))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">			    <span class="comment">//如果节点i已经被访问了，且在递归栈中有i，那么有环</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (recStack[*i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    recStack[v] = <span class="literal">false</span>;</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面函数仅能够判断从节点v出发判断是否存在环，若要对整个图判断一下，需要对图中每个节点都调用一次。</p>
<h1 id="检测无向图中是否存在环"><a href="#检测无向图中是否存在环" class="headerlink" title="检测无向图中是否存在环"></a>检测无向图中是否存在环</h1><p><img src="/archives/b1c317b/3.png" alt></p>
<p>很明显，在图中是存在一个环的。对于一个正在访问的节点V，如果它的相连接的节点u已经访问过，并且不是v的父节点，那么就可以认为图中存在环。</p>
<p>比如在图中，从节点0出发，使用DFS进行遍历。访问节点1，此时节点0是1的父节点。在访问节点2，1是2的父节点，但0不是2的父节点，并且0已经被访问过了，此时就可以判定图中存在环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCyclic</span><span class="params">(<span class="keyword">int</span> v, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;visited, <span class="keyword">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	visited[v] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i = adj[v].<span class="built_in">begin</span>(); i != adj[v].<span class="built_in">end</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!visited[*i])</span><br><span class="line">		&#123;<span class="comment">//这个if一定得这么写，不得两个if用&amp;&amp;连起来</span></span><br><span class="line">			<span class="keyword">if</span> (isCyclic(*i, visited, v))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*i != parent)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是只能检测联通的图，如果不连通，每个位置统统调用检测一遍。</p>
<h1 id="并查集-在无向图中检测是否存在环"><a href="#并查集-在无向图中检测是否存在环" class="headerlink" title="并查集(在无向图中检测是否存在环)"></a>并查集(在无向图中检测是否存在环)</h1><p>并查集一种数据结构，它跟踪一组被划分为多个没有交集的子集中的元素。并查集有两个主要操作，<br>查找（find）:确定某个元素所在的子集，确定两个元素是否在同一个子集中。<br>联合（union）:将两个子集连接成一个子集。<br>并查集算法可用于检测无向图是否有环。此方法需要假设图不包含任何自循环，设置一个父数组parent。如</p>
<p><img src="/archives/b1c317b/4.png" alt></p>
<p>使用图的每一个顶点创建子集。parent数组的所有元素都初始化为-1(意味着每个槽就是一个子集)。如果两个顶点都在同样的子集，就可以找到一个循环。</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
</tr>
</tbody></table>
<p>现在逐个处理每条边。首先是0-1边：找到顶点0和1所在的子集。由于它们属于不同的子集，故要取它们的并集。对于取并集（union），可以让节点1作为节点0的父节点，反之也可以。数组就更新为下面这样</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">-1</td>
<td align="center">-1</td>
</tr>
</tbody></table>
<p>然后是1-2边：1在子集1中，2在子集2中，不在同一个子集，于是union起来，将子集1置于子集2下面。结果如下</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>-1</td>
</tr>
</tbody></table>
<p>最后是0-2边：0在子集2中（0在子集1中，子集1在子集2中），2也在子集2中。那么加上这条边就形成一个环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;parent, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//并查集查找，查找i所在的子集</span></span><br><span class="line">	<span class="keyword">if</span> (parent[i] == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">find</span>(parent, parent[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;parent, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//并查集的并</span></span><br><span class="line">	<span class="keyword">int</span> xset = <span class="built_in">find</span>(parent, x);</span><br><span class="line">	<span class="keyword">int</span> yset = <span class="built_in">find</span>(parent, y);</span><br><span class="line">	<span class="keyword">if</span> (xset != yset) &#123;</span><br><span class="line">		parent[xset] = yset;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Graph::isCycle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//环判定，值得一提是，这里检测的是无向图，但图的定义在添加边的时候添加单向边</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;parent(<span class="keyword">this</span>-&gt;v, <span class="number">-1</span>);<span class="comment">//🧑数组，</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; <span class="keyword">this</span>-&gt;V; v++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i = adj[v].<span class="built_in">begin</span>(); i != adj[v].<span class="built_in">end</span>(); ++i)</span><br><span class="line">		&#123;<span class="comment">//v和*i是一条边的两端</span></span><br><span class="line">			<span class="keyword">int</span> x = <span class="built_in">find</span>(parent, v);</span><br><span class="line">			<span class="keyword">int</span> y = <span class="built_in">find</span>(parent, *i);</span><br><span class="line">			<span class="keyword">if</span> (x == y)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			Union(parent, x, y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>拓扑排序是有向无环图所有顶点的线性排序，满足对于每一条有向边$(u,v)$，顶点$u$在$v$之前。例如，下面图的拓扑排序是“5 4 2 3 1 0”,拓扑排序次序并不唯一。</p>
<p><img src="/archives/b1c317b/5.png" alt></p>
<p>拓扑排序过程：将DFS修改一下就行了。首先需要一个栈，暂时保存结果，从某个源点S开始，对源点S相邻的点递归调用拓扑排序，结束之后再把S压入栈中。最后将栈内元素全部出战即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topologicalSortUtil</span><span class="params">(<span class="keyword">int</span> v,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;visited,<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp;Stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	visited[v] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> i = adj[v].<span class="built_in">begin</span>(); i != adj[v].<span class="built_in">end</span>(); ++i)</span><br><span class="line">		<span class="keyword">if</span>(!visited[*i]) topologicalSortUtil(*i, visited, Stack);</span><br><span class="line">	Stack.push(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topologicalSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Stack;<span class="comment">//保存拓扑结果</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;visited(V, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)<span class="comment">//对于每个节点，若没有被访问过，都要进行拓扑排序</span></span><br><span class="line">		<span class="keyword">if</span> (visited[i] == <span class="literal">false</span>)</span><br><span class="line">			topologicalSortUtil(i, visited, Stack);</span><br><span class="line">	<span class="keyword">while</span> (Stack.empty() == <span class="literal">false</span>)</span><br><span class="line">		Stack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="有向无环图（DAG）的最长路径"><a href="#有向无环图（DAG）的最长路径" class="headerlink" title="有向无环图（DAG）的最长路径"></a>有向无环图（DAG）的最长路径</h1><p>描述：给出一个带权有向无环图(DAG)和其中的一个源点s，求出<br>s到图中所有其它顶点的最长距离。<br>众所周知，一般图最长路径问题是NPH problem。但对于DAG的最长路径问题有一个线性时间解。使用拓扑排序可以求解。</p>
<p>求解过程：首先初始化源点S到其他顶点的距离为无穷小，源点S到S的距离为0。之后对整个图DAG进行拓扑排序。按照拓扑排序后的节点顺序，更新到源点距离就行了。</p>
<p>如图：<img src="/archives/b1c317b/6.png" alt><br><img src="/archives/b1c317b/7.png" alt><br>对图a进行拓扑排序结果为$r,s,t,x,y,z$。如图b所示，并标出图中所有的边。<br>1.如图c所示，更新r到其他点的距离。<br>2.如图d所示，更新s到其他点的距离。<br>3.如图e所示，更新t到其他点的距离。<br>4.如图f所示，更新x到其他点的距离。<br>5.如图g所示，更新y到其他点的距离。<br>6.如图h所示，更新z到其他点的距离。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longestPath</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Stack;<span class="comment">//保存拓扑排序的结果</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dist(<span class="keyword">this</span>-&gt;V);<span class="comment">//距离数组</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;visited(<span class="keyword">this</span>-&gt;V, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对每个位置进行拓扑排序，得到结果</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">		<span class="keyword">if</span> (visited[i] == <span class="literal">false</span>)</span><br><span class="line">			topologicalSortUtil(i, visited, Stack);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化所有距离为负无穷，源点距离为0</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">		dist[i] = INT_MIN;</span><br><span class="line">	dist[s] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不断出栈，并且更新出栈元素，到其相邻的边的最长长度</span></span><br><span class="line">	<span class="keyword">while</span> (Stack.empty() == <span class="literal">false</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = Stack.top();</span><br><span class="line">		Stack.pop();</span><br><span class="line">		<span class="built_in">list</span>&lt;AdjListNode&gt;::iterator i;</span><br><span class="line">		<span class="keyword">if</span> (dist[u] != INT_MAX) &#123;</span><br><span class="line">			<span class="keyword">for</span> (i = adj[u].<span class="built_in">begin</span>(); i != adj[u].<span class="built_in">end</span>(); ++i)</span><br><span class="line">				<span class="keyword">if</span> (dist[i-&gt;getV()] &lt; dist[u] + i-&gt;getWeight())</span><br><span class="line">					dist[i-&gt;getV()] = dist[u] + i-&gt;getWeight();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印最后结果</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">		<span class="keyword">if</span> (dist[i] == INT_MIN)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"INF "</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; dist[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="判断图是否可以二分"><a href="#判断图是否可以二分" class="headerlink" title="判断图是否可以二分"></a>判断图是否可以二分</h1><p>若有无向图$G=(V,E)$，其顶点V可分割为两个互不相交的子集$(A,B)$，并且图中的每条边$(i,j)$所关联的两个顶点$i$和$j$分别属于这两个不同的顶点集$(V_A,U_B)$，则称图是一个<a href="[https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E5%9B%BE](https://baike.baidu.com/item/二分图)">二分图</a>。</p>
<p>如果一个图是二分图，那么可以使用两种颜色将节点划分到两个集合中（每个集合中节点的颜色一样）。</p>
<p>胃酸法：开始对任意一未染色的顶点染色，之后判断其相邻的顶点中，若未染色则将其染上和相邻顶点不同的颜色， 若已经染色且颜色和相邻顶点的颜色相同则说明不是二分图，若颜色不同则继续判断，bfs和dfs可以搞定！</p>
]]></content>
      <categories>
        <category>DST</category>
      </categories>
      <tags>
        <tag>DST</tag>
      </tags>
  </entry>
  <entry>
    <title>动态🐢❀</title>
    <url>/archives/63b7a160.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>动态规划(Dynamic programming)，通过组合子问题的解来求解原问题。当原问题的子问题存在重叠的情况，即不同的子问题具有公共的<code>子子</code>问题。动态规划算法对每个子问题只求解一次，将其解保存到一个表格中，从而无需每次求解一个子子问题时都重新计算，<code>避免</code>了这种不必要的计算工作。</p>
<p>动态规划方法通常用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值的解。</p>
<p>我们按照如下4个步骤来设计一个动态规划算法</p>
<ol>
<li><p>刻画一个最优解的结构特征</p>
</li>
<li><p>递归地定义最优解的值</p>
</li>
<li><p>计算最优解的值，通常采用自底向上的方法</p>
</li>
<li><p>利用计算出来的信息构建最优解</p>
<a id="more"></a>

<blockquote>
<p>算法导论15章序</p>
</blockquote>
</li>
</ol>
<p>实现方式</p>
<ol>
<li>自顶向下递归实现</li>
<li>带备忘录形式的自顶向下</li>
<li>自底向上</li>
</ol>
<p>在动态规划中，首先需要求得子问题的最优解，然后通过<code>状态转移</code>，求得原问题的解。在求原问题的过程中（状态转移），需要有一些<code>选择</code>，做出这些选择需要一些<code>代价</code>。原问题的解就等于子问题的解加上这次选择的<code>代价</code>。</p>
<p>例如，在<code>无权最短路径问题</code>具有以下最优子结构性质：如果节点$x$位于从源节点$u$到目标节点$v$的最短路径上，则$u$到$v$的最短路径<strong>是</strong>$u$到$x$的最短路径<strong>和</strong>从$x$到$v$<strong>之和</strong>。如在所有节点对的最短路径算法中，Floyd-Warshall和Bellman-Fordare均是动态规划。</p>
<h1 id="最长上升子序列Longest-Increasing-Subsequence-LIS"><a href="#最长上升子序列Longest-Increasing-Subsequence-LIS" class="headerlink" title="最长上升子序列Longest Increasing Subsequence (LIS)"></a>最长上升子序列Longest Increasing Subsequence (LIS)</h1><p><strong>描述：</strong>给定一个序列，求这个序列的子序列的最长上式子序列的长度，子序列不必连续。</p>
<p>比如序列$[10,22,9,33,21,50,41,60,80]$的LIS长度为6,LIS为$[10,22,33,50,60,80]$。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input : nums = &#123;3, 10, 2, 1, 20&#125;</span><br><span class="line">Output : Length of LIS = 3</span><br><span class="line">The longest increasing subsequence is 3, 10, 20</span><br><span class="line">Input : nums = &#123;3, 2&#125;</span><br><span class="line">Output : Length of LIS = 1</span><br><span class="line">The longest increasing subsequences are &#123;3&#125; and &#123;2&#125;</span><br><span class="line">Input : nums = &#123;50, 3, 10, 7, 40, 80&#125;</span><br><span class="line">Output : Length of LIS = 4</span><br><span class="line">The longest increasing subsequence is &#123;3, 7, 40, 80&#125;</span><br></pre></td></tr></table></figure>

<p>最优子结构：让$nums[0 …n-1]$为输入数组，$L(i)$为索引$i$处结束的$LIS$的长度，并且$nums[i]$是$LIS$的最后一个元素。则$L(i)$可递归表示为:<br>$L(i) = 1 + max(L(j))$，其中$0 &lt; j &lt; i, nums[j] &lt; nums[i]$<br>$L(i) = 1$，如果不存在上面的$j$。<br>要找到给定数组的LIS，需要返回$max(L(i))$，其中$0 &lt; i &lt; n%$。可以看到$LIS$问题满足最优子结构性质，原问题可以用子问题的解来解决。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>,n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;lis(n);</span><br><span class="line">        <span class="comment">//初始化一维dp表格</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            lis[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//自底向上规划</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) </span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j] &amp;&amp; lis[i] &lt; lis[j] + <span class="number">1</span>)</span><br><span class="line">                    lis[i] = lis[j] + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ret&lt;lis[i])ret=lis[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="最长共同子序列Longest-Common-Subsequence-LCS"><a href="#最长共同子序列Longest-Common-Subsequence-LCS" class="headerlink" title="最长共同子序列Longest Common Subsequence(LCS)"></a>最长共同子序列Longest Common Subsequence(LCS)</h1><p><strong>描述：</strong>给定两个序列，求在者两个序列中最长公共子序列的长度。子序列相不是从原序列中连续相邻取得。例如$“abc”, “abg”, “bdf”, “aeg”, ‘”acefg”$均是$“abcdefg”$的子序列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序列“ABCDGH”和“AEDFHR”有公共最长子序列“ADH”，长度为3.</span><br><span class="line">序列“AGGTAB”和“GXTXAYB”有公共最长子序列“GTAB”，长度为4.</span><br></pre></td></tr></table></figure>

<p>最优子结构：设输入序列为$X[0…m - 1]$和$Y [0…n-1]$，长度分别为m和n。<br>假设$L(X[i],Y[j])$为两个序列$X$和$Y$在位置$i$和位置$j$的$LCS$长度。<br>如果两个序列的最后一个字符相等（$X[m-1] == Y[n-1]$)，则<br>$$L(X[m-1],Y[n-1]) =1+L(X[m-2],Y[n-2])$$<br>如果两个序列的最后一个字符不相等($X[m-1]!= Y[n-2]$)，则<br>$$L(X[m-1],Y[n-1])= max(L(X[m-2],Y[n-1]),L(X[m-1]),Y[n-2]))$$</p>
<p>如有序列“AGGTAB” 和“GXTXAYB”。</p>
<ol>
<li><p>它们最后一个字符相等<br>$$L(“AGGTAB”, “GXTXAYB”) = 1 + L(“AGGTA”, “GXTXAY”)$$</p>
</li>
<li><p>再考虑“AGGTA” 和“GXTXAY“，他们最后一个字符并不相等。<br>$$L(“AGGTA”, “GXTXAY”) = max(L(“AGGT”, “GXTXAY”),L(“AGGTA”, “GXTXA”)  )$$</p>
</li>
<li><p>依次递推，如下所示。</p>
<p><img src="/archives/63b7a160/1.png" alt></p>
</li>
<li><p>到达边界以后，停止了规划。值得注意的是，按照上面这个走法，复杂度很高，不可取。因此考虑自底向上解法。如下。<img src="/archives/63b7a160/2.png" alt></p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.<span class="built_in">size</span>(),n = text2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;L(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>) L[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])</span><br><span class="line">                    L[i][j] = L[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    L[i][j] = <span class="built_in">max</span>(L[i<span class="number">-1</span>][j], L[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><p><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></p>
<p>最优子结构：设输入序列为$X[0…m - 1]$和$Y [0…n-1]$，长度分别为m和n。<br>假设$dp(X[i],Y[j])$为两个序列$X$和$Y$在位置$i$和位置$j$的最短编辑数。<br>如果两个序列的最后一个字符相等（或$X[m-1] == Y[n-1]$)，则<br>$$dp(X[m-1],Y[n-1]) =1+dp(X[m-2],Y[n-2])$$<br>如果两个序列的最后一个字符不相等($X[m-1]!= Y[n-2]$)，则有三种选择：取三种选择最小操作数<br>$$dp(X[m-1],Y[n-1])= min(dp(X[m-2],Y[n-1]),dp(X[m-1]),Y[n-2]),dp(X[m-2],Y[n-2]))$$</p>
<p>如有序列“AGAB” 和“GXAYB”。</p>
<ol>
<li><p>它们最后一个字符相等<br>$$dp(“AGAB”, “GXAYB”) = 1 + dp(“AGA”, “GXAY”)$$</p>
</li>
<li><p>再考虑“AGA” 和“GXAY“，他们最后一个字符并不相等。<br>$$dp(“AGA”,“GXAY”) =min(dp(“AG”, “GXAY”),dp(“AGA”, “GXA”),dp(“AG”,”GXA”))$$</p>
</li>
<li><p>按照上面这种递归，数据量大就会超时，自底向上书写代码。</p>
</li>
<li><p>当其中一个序列长度为0时，编辑距离明显是到达他的长度。</p>
<p>当当前位置$i,j$字符相等时候，编辑距离$dp[i][j]=dp[i-1][j-1]$</p>
<p>当当前位置$i,j$字符不相等时候，编辑距离$dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])$</p>
<p>如图所示，计算过程</p>
<p><img src="/archives/63b7a160/3.png" alt></p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(),n = word2.length();</span><br><span class="line">        <span class="keyword">int</span> dp[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) dp[i][j] =j;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)dp[i][j]=i;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>])dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="number">1</span>+<span class="built_in">min</span>(<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]),dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="最小成本路径Minimum-Cost-Path-MCP"><a href="#最小成本路径Minimum-Cost-Path-MCP" class="headerlink" title="最小成本路径Minimum Cost Path(MCP)"></a>最小成本路径Minimum Cost Path(MCP)</h1><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></p>
<ol>
<li><p>最优子结构：到达(m, n)的必须经过：(m-1, n-1)，(m-1, n)，(m, n-1)中的一个，所以到达(m, n)的最小代价可以写成<br>$$dp(m, n) = min(dp(m-1, n-1), dp(m-1, n),dp(m, n-1))+weight[m][n]$$</p>
</li>
<li><p>在递归求解，有重复子问题，递归不太适合。</p>
<p>采用填表格的形式计算</p>
<p><img src="/archives/63b7a160/4.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(),n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-1</span>]+grid[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]))+grid[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="兑换硬币"><a href="#兑换硬币" class="headerlink" title="兑换硬币"></a>兑换硬币</h1><p><strong>描述：</strong>假定有一整钱N，如果我们需要将其兑换为零钱。零钱的选择从数组$S= [S1, S2…]$中选择。并且每种零钱数量是无限的。那么有多少种兑换方式？</p>
<p>如，对于N=4和$S=[1,2,3]$，有四个解:{1,1,1,1}，{1,1,2}，{2,2}，{1,3}。那么结果为4。<br>对于N=10和$S =[2, 5, 3, 6]$，有5个解:{2,2,2,2,2}，{2,2,3,3}，{2,2,6}，{2,3,5}和{5,5}。所以结果为5。</p>
<p>最优子结构：为了计算解的总数，我们可以把所有的集合解分成两个部分。1. 不含s[m]的解；至少含有一个s[m]的解。<br>令count(vector<int>s,m, n)为计算解的个数的函数，那么可写成count(S,m,n) = count(S,m-1, n)+count(S,m, n-S[m])，递归求解。</int></p>
<p>很明显，会超时，因为在递归求解的时候有很多重复计算。</p>
<ol start="2">
<li><p>怎么用dp方程表示呢？$dp[N][m]$表示用数组$S[m]$得到N得数量，那么$$dp[N][m] = dp[N][m-1]+dp[N-S[m]][m]$$<br>初始化，当N=0时，只有一种取法。然后，填充剩余部分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.<span class="built_in">size</span>()==<span class="number">0</span>&amp;&amp;N==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(S.<span class="built_in">size</span>()==<span class="number">0</span>&amp;&amp;N!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = S.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(N+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//i-s[j]&gt;=0,表示可以取s[j]，</span></span><br><span class="line">                <span class="comment">//若小于的话，表示不可取，为0</span></span><br><span class="line">                <span class="keyword">if</span>((i-S[j])&gt;=<span class="number">0</span>) x=dp[i-S[j]][j];</span><br><span class="line">                <span class="keyword">else</span> x = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//当不去s[m]的时候，那么取s[m-1]</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=<span class="number">1</span>) y = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> y=<span class="number">0</span>;</span><br><span class="line">                <span class="comment">//取s[m]的数量加上不取s[m]的数量</span></span><br><span class="line">                dp[i][j] = x+y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="矩阵链乘法"><a href="#矩阵链乘法" class="headerlink" title="矩阵链乘法"></a>矩阵链乘法</h1><p>有n个矩阵的链$&lt;A_1A_2…A_n&gt;$，矩阵$A_i$的大小为$p_{i-1}×p$，求计算该矩阵乘法所需的最小的标量乘法次数。</p>
<p>如：假设A为10×30矩阵，B为30×5矩阵，C为5×60矩阵。然后,<br>(AB)C =(10×30×5)+(10×5×60)= 1500 + 3000 = 4500个乘法操作。<br>A(BC) =(30×5×60)+(10×30×60)= 9000 + 18000 = 27000个乘法操作。</p>
<p>最优子结构：见算法导论第372章。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int matricMultiply(vector&lt;int&gt;&amp;p) &#123;</span><br><span class="line">        int n &#x3D; p.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;dp(n,vector&lt;int&gt;(n,0));</span><br><span class="line">        for(int L&#x3D;2;L&lt;n;L++)&#123;</span><br><span class="line">            for(int i&#x3D;1;i&lt;n-L+1;i++)&#123;</span><br><span class="line">                int j &#x3D; i+L-1;</span><br><span class="line">                dp[i][j] &#x3D; INT_MAX;</span><br><span class="line">                for(int k&#x3D;i;k&lt;j;k++)&#123;</span><br><span class="line">                    int q &#x3D; dp[i][k]+dp[k+1][j]+p[i-1]*p[k]*p[j];</span><br><span class="line">                    if(q&lt;dp[i][j])dp[i][j] &#x3D; q;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;n;j++)&#123;</span><br><span class="line">                cout&lt;&lt;dp[i][j]&lt;&lt;&#39; &#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[1][n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二项式系数"><a href="#二项式系数" class="headerlink" title="二项式系数"></a>二项式系数</h1><p>描述：二项式系数$C(n, k)$定义为$(1+x)^n$展开式中$X^k$的系数。</p>
<p>最优子结构：$C(n, k)$的值可以用以下标准二项式公式计算</p>
<p>$$C(n, k) = C(n-1, k-1) + C(n-1, k)$$<br>$$C(n, 0) = C(n, n) = 1$$</p>
<p>按照这个公式，建立下面这样表格，递推计算。<img src="/archives/63b7a160/5.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binomialCoeff</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;c(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(i,k);j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>||j==i) c[i][j]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c[n][k];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h1><p><strong>描述：</strong>经典问题， 给定$n$种物品和一背包。物品$i$的重量是$w_i$，其价值为$v_i$，背包的容量为$W$。问应如何选择装入背包的物品，使得装入背包中物品的总价值$V$最大?</p>
<p>最优子结构：对于一种物品$i$，要么装入背包，要么不装。所以可以设置一种物品的装入状态取0和1，那么,对于位置$i$处的背包装满容量$W$的最大值可以写成$V[i][W] = max(V[i-1][W-w_i]+v_i,V[i-1][W])$</p>
<p>第一项，表示取位置$i$处的物品，那么需要加上物品$i$的价值；第二项表示不取位置$i$处的物品，那么总价值就时$V[i-1][W]$，二者取较大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapSack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;weight,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;value,<span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = weight.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(W+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>;w&lt;W;w++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||w==<span class="number">0</span>) dp[i][w] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(weight[i<span class="number">-1</span>]&lt;=w) dp[i][w] = <span class="built_in">max</span>(value[i<span class="number">-1</span>]+dp[i<span class="number">-1</span>][w-weight[i<span class="number">-1</span>]],dp[i<span class="number">-1</span>][w]);</span><br><span class="line">                <span class="keyword">else</span> dp[i][w] = dp[i<span class="number">-1</span>][w];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][W];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="扔鸡蛋问题"><a href="#扔鸡蛋问题" class="headerlink" title="扔鸡蛋问题"></a>扔鸡蛋问题</h1><p><a href="https://leetcode-cn.com/problems/super-egg-drop/" target="_blank" rel="noopener">887. 鸡蛋掉落</a></p>
<p>鸡蛋从某一层扔下去，可能的情况有两种，碎了，没碎。如果鸡蛋从第$x$层扔下去并且碎了了，那么只需要检查楼层$x$以下楼层，问题变成有楼层$x-1$和有鸡蛋$n-1$个。</p>
<p>如果鸡蛋从第x层扔下去并且没有碎，那么只需要检查楼层x以上的楼层，那么问题变成有楼$k-x$层和鸡蛋$n$个。我们需要将最坏情况下的移动次数最少，那么可以定义为</p>
<p>$$eggDrop(K,N) = 1+min(eggDrop(K,N),max(eggDrop(x-1,N-1)+eggDrop(k-x,N)))$$</p>
<p>之后按照自底向上写递推转移。写自底向上dp还是超时，还要加上二分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//原始dp</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(K+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//dp[K][N]鸡蛋，楼层</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;K+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//对于楼层为0，以及楼层为1</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//对于只有一个鸡蛋</span></span><br><span class="line">        dp[<span class="number">1</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;K+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;N+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            dp[i][j] = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=j;x++)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j],<span class="number">1</span>+<span class="built_in">max</span>(dp[i<span class="number">-1</span>][x<span class="number">-1</span>],dp[i][j-x]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;dp[i][j]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[K][N];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(K + <span class="number">1</span>))</span></span>;</span><br><span class="line">		<span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (dp[m][K] &lt; N) &#123;</span><br><span class="line">			++m;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; ++j) &#123;</span><br><span class="line">				dp[m][j] = dp[m - <span class="number">1</span>][j - <span class="number">1</span>] + dp[m - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a></p>
<p>最优子结构：假设$X[0…n-1]$为长度n的输入序列，$L(0,n -1)$为其最长回文子序列长度。<br>如果$X$的最后一个字符和第一个字符相同，那么就有<br>$$L(0, n-1) = L(1, n-2) + 2$$<br>如果$X$的最后一个字符第一个字符不相同，那么就有<br>$$L(0, n-1) = max(L(1,n-1),L(0,n-2))$$。<br>开始写递推方程$dp[i][j]$表示$X$的位置从$i$，$j$见的最长回文子序列长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if x[i]&#x3D;&#x3D;x[j] dp[i][j]  &#x3D; dp[i+1][j-1]+2</span><br><span class="line">else dp[i][j] &#x3D; max(dp[i+1][j],dp[i][j-1])</span><br></pre></td></tr></table></figure>

<p>举个栗子，如有字符串”bbbab”，最长子序列长度为4。子序列为bbbb。</p>
<p>当只有一个字符时，最长子序列必定为1.将表格初始化全为1.</p>
<p>从两个位置距离为1开始算起，然后算距离为2的。。。</p>
<p><img src="/archives/63b7a160/6.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;<span class="comment">//两个位置间的距离</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> k = i+j;</span><br><span class="line">                <span class="keyword">if</span>(s[j]==s[k]&amp;&amp;i==<span class="number">1</span>)dp[j][k]=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[j]==s[k])dp[j][k] = dp[j+<span class="number">1</span>][k<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[j][k] = <span class="built_in">max</span>(dp[j][k<span class="number">-1</span>],dp[j+<span class="number">1</span>][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DST</category>
      </categories>
      <tags>
        <tag>DST</tag>
      </tags>
  </entry>
  <entry>
    <title>Crawl Dy</title>
    <url>/archives/ffc3f523.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>抖音是一个很好的平台，森罗万象，大到央视新闻，小到普通老百姓日常。上面的活跃用户的粉丝数量，有如恒河沙数，也有如寥若晨星。</p>
<p>抖音的推荐算法会逐渐决定你将要看什么，滑稽吧？你的观看选择，从这个角度看，居然是他人决定，而不是自己去寻找🤣。自己去寻找的不好吗？人懒了吗？</p>
<p>本文建立抖音推荐算法的基础上，爬取一些自己喜欢的东西，当然是小姐姐了。一开口👨就知道是老色批了，又在ghs，👨‍✈️拷走。👨这边前期刷抖音的时候，在一下小姐姐视频上停留时间过长，抖音app会自动判定你喜欢这类视频，或者在刷到漂亮小姐姐，点个like，后面还是会推送这类视频。于是不需要使用人脸判定接口了，麻烦。</p>
<p>先上结果图：</p>
<a id="more"></a>

<p><img src="/archives/ffc3f523/17.png" alt></p>
<p><img src="/archives/ffc3f523/16.png" alt></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>一款安卓模拟器，我用的是<a href="https://www.yeshen.com/" target="_blank" rel="noopener">夜神模拟器</a></li>
<li>抓包工具 <a href="https://www.telerik.com/download/fiddler" target="_blank" rel="noopener">fiddle</a></li>
<li>python代码编辑器</li>
</ol>
<h2 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h2><ol>
<li><p>配置fiddle</p>
<p>打开fiddle，在option里设置如下</p>
<p><img src="/archives/ffc3f523/1.png" alt></p>
<p><img src="/archives/ffc3f523/2.png" alt></p>
<p>重启fiddler。</p>
</li>
<li><p>配置模拟器</p>
<p>配置网络，查看本机ip，为192.168.0.106</p>
<p><img src="/archives/ffc3f523/3.png" alt></p>
<p>配置模拟器，保存。</p>
<p><img src="/archives/ffc3f523/4.png" alt></p>
<p>配置证书:在浏览器中输入设置的ip:端口，我的是192.168.0.106:8888，就会打开fiddler的页面。然后点击fiddlerRoot certificate，安装证书。如果没有下面，重启一下fiddle。</p>
<p><img src="/archives/ffc3f523/5.png" alt></p>
<p>点击以后开始下载，在任务栏点击安装，设置名称，设置锁屏手势。</p>
<p><img src="/archives/ffc3f523/6.png" alt></p>
</li>
<li><p>打开抖音，如图所示，fiddle有些花眼。红框是需要抓取的进程数据。</p>
<p><img src="/archives/ffc3f523/7.png" alt></p>
</li>
<li><p>于是定义显示规则，只显示这个process，不显示其他进程，在其他进程上右键，filter now ，hide’XXXXX’</p>
<p><img src="/archives/ffc3f523/8.png" alt></p>
</li>
<li><p>分析抓包数据，我们需要找到json数据。在滑动抖音后，fiddle里面就一个json 包，还非常小，点开后啥数据也没有。</p>
<p><img src="/archives/ffc3f523/9.png" alt></p>
<p>经过我百般探索，在模拟器抖音点击用户头像，就会有较大body 的json出现。</p>
<p><img src="/archives/ffc3f523/10.png" alt></p>
<p>这个json数据包很大吧，打开分析吧。</p>
</li>
<li><p>打开后，仔细比较，这就是用户所有数据了。</p>
<p><img src="/archives/ffc3f523/11.png" alt></p>
<p>仔细找找，在video里就能找到视频，把url_list里链接复制到浏览器就能够播放。</p>
<p><img src="/archives/ffc3f523/12.png" alt></p>
</li>
<li><p>已经完成一大半了，接下来就是批量获取json数据，然后解析json数据中的video链接，下载到本地。</p>
<p>批量获取json数据，在fiddle定义script rule。如图所示，然后点击 save script。</p>
<p><img src="/archives/ffc3f523/13.png" alt></p>
<p>下面是代码，fielname变量指向的目录<code>D:/抖音/raw_data</code>手动生成。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">OnBeforeResponse</span>(<span class="params">oSession: Session</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Hide304s &amp;&amp; oSession.responseCode == <span class="number">304</span>) &#123;</span><br><span class="line">            oSession[<span class="string">"ui-hide"</span>] = <span class="string">"true"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (oSession.uriContains(<span class="string">"https://aweme.snssdk.com/aweme/v1/aweme/post/"</span>)||oSession.uriContains(<span class="string">"https://api3-core-c-lf.amemv.com/aweme/v1/aweme/post/"</span>))&#123;</span><br><span class="line">            <span class="keyword">var</span> strBody=oSession.GetResponseBodyAsString();</span><br><span class="line">            <span class="keyword">var</span> sps = oSession.PathAndQuery.slice(<span class="number">-58</span>,);</span><br><span class="line">            <span class="keyword">var</span> filename = <span class="string">"D:/抖音/raw_data"</span> + <span class="string">"/"</span> + sps + <span class="string">".json"</span>;  <span class="comment">//目录需要手动去生成。</span></span><br><span class="line">            <span class="keyword">var</span> curDate = <span class="keyword">new</span> <span class="built_in">Date</span>();   </span><br><span class="line">            <span class="keyword">var</span> sw : System.IO.StreamWriter;  </span><br><span class="line">            <span class="keyword">if</span> (System.IO.File.Exists(filename))&#123;  </span><br><span class="line">                sw = System.IO.File.AppendText(filename);  </span><br><span class="line">                sw.Write(strBody);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>&#123;  </span><br><span class="line">                sw = System.IO.File.CreateText(filename);  </span><br><span class="line">                sw.Write(strBody);  </span><br><span class="line">            &#125;  	</span><br><span class="line">            sw.Close();  </span><br><span class="line">            sw.Dispose();  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来，只需要在模拟器里滑动，点击用户，就可以看到在定义的目录里有很多json文件。</p>
<p><img src="/archives/ffc3f523/14.png" alt></p>
<ol start="8">
<li><p>手动划肯定不得行，于是就需要像按键精灵一样的东西，于是乎，就可以用夜神模拟器里面的操作录制。需要注意的是，有的用户头像上会有直播，点进去会跳到用户直播界面，我也没得办法，可以点击左下方的@user按钮，但按钮位置不太固定。也不好用。</p>
<p>我的解决办法是深夜进行这个操作录制，那时没得人在直播。正常模拟点击即可。</p>
<p><img src="/archives/ffc3f523/15.png" alt></p>
</li>
<li><p>解析json. 在<code>D:/抖音/</code>下新建crawl.py。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,json,requests</span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36'</span>&#125;</span><br><span class="line"></span><br><span class="line">videos_list = os.listdir(<span class="string">'D:/抖音/raw_data/'</span>)</span><br><span class="line">count = <span class="number">0</span> <span class="comment"># 统计下载视频数量</span></span><br><span class="line"><span class="keyword">for</span> videos <span class="keyword">in</span> videos_list:</span><br><span class="line">    json_data = open(<span class="string">'./raw_data/&#123;&#125;'</span>.format(videos),encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        content = json.load(json_data)[<span class="string">'aweme_list'</span>]</span><br><span class="line">        title = content[<span class="number">0</span>][<span class="string">'author'</span>][<span class="string">'nickname'</span>] <span class="comment">#小姐姐名称</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">r'#\/:*\@#?"&lt;&gt;|/'</span>:</span><br><span class="line">            title = title.replace(c,<span class="string">''</span>)</span><br><span class="line">        print(title,<span class="string">":可爱又美丽的我正在去往您的硬盘里\n"</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'./VIDEO/'</span>+title):</span><br><span class="line">            os.makedirs(<span class="string">'./VIDEO/'</span>+title,) <span class="comment"># 建立以小姐姐名称的文件夹</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> video <span class="keyword">in</span> content: </span><br><span class="line">            video_name = video[<span class="string">'desc'</span>]</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">r'#\/:*\@#?"&lt;&gt;|/'</span>:</span><br><span class="line">                video_name = video_name.replace(c,<span class="string">''</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                video_url = video[<span class="string">'video'</span>][<span class="string">'play_addr'</span>][<span class="string">'url_list'</span>][<span class="number">0</span>]</span><br><span class="line">                print(video_name)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                videoMp4 =  requests.request(<span class="string">'get'</span>,video_url,headers=headers).content </span><br><span class="line">                <span class="keyword">with</span> open(<span class="string">'./VIDEO/&#123;&#125;/&#123;&#125;.mp4'</span>.format(title,video_name),<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(videoMp4)</span><br><span class="line">                    print(<span class="string">"可爱又美丽的我已经在硬盘了"</span>)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">         <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">'--------------------------------'</span>)</span><br><span class="line">print(<span class="string">"一共&#123;&#125;有个在您的硬盘里呢"</span>.format(count))</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这些小姐姐们，都是以自己美颜后的模样呈现在视频前，在视频前摆几个动作而已，没看到有啥子与众不同的才艺，或者说闪光点。又或者说，这才是我们大众喜欢的女性，不然怎么一个个的好几万like。人均校花🤠。</p>
<p>小姐姐们确实挺好看的，不过不太符合我的审美观。萝卜青菜，各有所爱。👨希望每个人的另一半都是自己眼里最美的啦。</p>
<p>👨后面打算，基于这些小姐姐，做视频帧数切割，以及😃切割。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>cv</category>
      </categories>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>AC GAN</title>
    <url>/archives/d8960418.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li>在输入数据是分辨率较低的图片时，原有的gan能够生成和原始数据极为接近的结果，但对于高分辨率图片，就不太行。</li>
<li>在gan中的数据种类越多，生成就越困难。</li>
</ol>
<a id="more"></a>

<p>AC gan全称为Auxiliary Classifier GANs，翻译成中文就叫辅助分类器生成对抗网络。从名字可以看出，AC gan是对原有gan model修改后的一种model。</p>
<p>AC gan 在原有的基础上，增加了一个辅助分类器，用来限制label，并且使用了特定的损失函数。</p>
<p>下面是acgan的图形解释</p>
<p><img src="/archives/d8960418/1.png" alt></p>
<h2 id="AC-gan的数学表达"><a href="#AC-gan的数学表达" class="headerlink" title="AC gan的数学表达"></a>AC gan的数学表达</h2><p>原有的gan model中生成的假数据结果，定义为$X = G(z)$，$z$是输入噪音，$X$是输出结果。现在的AC gan引入了辅助分类器，故在原的$X$生成中引入了新的变量，现在将其定义为$X=G(c,z)$。</p>
<p>假设$D(X)$为输入数据$X$被鉴别为真的概率，其中$X$的输入，可以为真数据，也可以是生成的假数据。</p>
<p>假设用$P(S|X = D(x)$表示输入为数据后，判别数据得到的概率。</p>
<p>假设用$P(C|X = D(x))$表示输入数据后，判别label class得到的的概率。</p>
<p>那么对于输入数据有$L_S = E[logP(S=real|X_{real})]+E[logP(S=fake|X_{fake})]$</p>
<p>第一项：当输入数据是真数据，判定为真的结果的期望。<br>第二项：当输入数据是假数据，判定为假的结果的期望。</p>
<p>对于输入标签有：</p>
<p>$L_C = E[logP(C=c|X_{real})]+E[logP(C=c|X_{fake})]$</p>
<p>第一项：当输入真数据的label被判定确切属于某类c的期望。<br>第二项：当输入假数据的label被判定确切属于某类c的期望。</p>
<p>对于鉴别器(Discriminator D)而言，它的任务是尽可能的判定真的数据为真，假的数据为假，真的数据的label确切属于某类C，假的数据label确切属于某类c。故它的目标可以写成</p>
<p>$$max (L_S+L_C)$$</p>
<p>对于生成器(Generator G)而言，它的任务是尽可能的让真的数据被判定为真，让假的数据被判定为真，真的数据的label确切属于某类C，假的数据label确切不属于某类c。故它的目标可以写成（我感觉解释不通。待改）</p>
<p>$$max (L_C-L_S)$$</p>
]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>GAN Model</title>
    <url>/archives/f2925084.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>gan，全名Generative Adversarial Nets，翻译成中文，生成对抗网络。顾名思义，有生成过程，有对抗过程的一种net model。</p>
<p>这种模型大致工作流程：</p>
<p>有一生产者，也可以称其为造假者，他的工作是生成类似于源数据的数据，比如与古董真假难辨的伪造古董。生产者在这里就扮演了伪造古董的“工艺大师”。</p>
<a id="more"></a>

<p>有一对抗者，形象一点称其为鉴别者，他的工作就是判断某一数据是否来源于源数据，比如说，判断某一可能是古董的工艺品是不是真的古董。对抗者在这里就充当了“鉴宝大师”。</p>
<p>“工艺大师”和“鉴宝大师”相互竞争（对抗），驱使着他们各自变得更加优秀（前者生成真假难辨的古董，后者对再怎么真假难辨的古董也能分辨出来）。</p>
<p><strong>gan的目的</strong>就是让这个“工艺大师”能够生成无限接近于（相似于）源数据的数据。对于工艺大师，就是生成“古董”。</p>
<h2 id="gan数学表达"><a href="#gan数学表达" class="headerlink" title="gan数学表达"></a>gan数学表达</h2><p>假设源数据集(古董数据)分布：$p_{data}$</p>
<p>假设生成的数据集(伪造的古董)分布：$p_{g}(x_i,\theta_g)$，定义一个先验噪声$p_z(z)$,经过多层感知机处理，噪声经过$G(z,\theta_g)$处理得到$x$，即$x = G(z,\theta_g)$.</p>
<p>假设$D(x)$表示$x$来自源数据集$p_{data}$被鉴别为真（古董）的概率，那么$D(G(z))$则可以表示为$x = G(z,\theta_g)$来自于$p_g$而被鉴别为真（古董的概率）。</p>
<ol>
<li>对于鉴宝大师，他的目标是尽可能的使$D(x)$趋于1，使$D(G(z))$趋于0。因此可以这样表达：<br>$$\mathop{max}\limits_{D} E_{x\sim p_{data}}[logD(X)]+E_{z\sim p_z}[log(1-D(G(z)))]$$</li>
<li>对于工艺大师，他的目标是尽可能的使$D(G(x))$趋于1，产生误判。因此可以这样表达：<br>$$\mathop{min}\limits_{G}E_{z\sim p_z}[log(1-D(G(z)))]$$</li>
<li>结合以上两者，可以归纳为一个公式<br>$$\mathop{min}\limits_{G}\mathop{max}\limits_{D} E_{x\sim p_{data}}[logD(X)]+E_{z\sim p_z}[log(1-D(G(z)))]$$</li>
</ol>
<h2 id="gan数学表达的全局最优解"><a href="#gan数学表达的全局最优解" class="headerlink" title="gan数学表达的全局最优解"></a>gan数学表达的全局最优解</h2><p>将上式记为$$\mathop{min}\limits_{G}\mathop{max}\limits_{D} V(G,D) = \mathop{min}\limits_{G}\mathop{max}\limits_{D} E_{x\sim p_{data}}[logD(X)]+E_{z\sim p_z}[log(1-D(G(z)))]$$</p>
<p>$$\mathop{=====}\limits^{将期望用积分表达}\int_xp_{data}(x)log(D(x))dx+\int_zp(z)log(1-D(G(z)))dz$$</p>
<p>$$\mathop{===}\limits^{将z换成x}\int_x[p_{data}(x)log(D(x))+p_glog(1-D(x)]dx$$</p>
<p>求其全局最优解，将G固定，求此时的$\mathop{max}\limits_{D}V(D)$</p>
<p>$$\mathop{max}\limits_{D}V(D)=\mathop{max} \int_x[p_{data}(x)log(D(x))+p_glog(1-D(x)]dx$$</p>
<p>对上式中的$D$求偏微分，使其偏微分为0，于是有</p>
<p>$$\frac{\partial}{\partial D}[V(D)]=\int_x\frac{\partial}{\partial D}[p_{data}(x)log(D(x))+p_glog(1-D(x)]dx$$</p>
<p>$$=\int_x\frac{\partial}{\partial D}[p_{data}\frac{1}{D(x)}+p_g\frac{1}{1-D(x)}]dx=0$$</p>
<p>解得有：$D_G^* = \frac{p_{data}}{p_{data}+p_g}$</p>
<p>再将$D_G^* = \frac{p_{data}}{p_{data}+p_g}$代回$\mathop{min}\limits_{G}\mathop{max}\limits_{D} V(G,D) $，此时有</p>
<p>$$\mathop{min}\limits_{G}V(G,D)=E_{x\sim p_{data}}[log\frac{p_{data}}{p_{data}+p_g}]+E_{x\sim p_g}[log(1-\frac{p_{data}}{p_{data}+p_g})]$$       </p>
<p>关于求解上式，有一个叫KL散度的东西，相对熵，衡量两个概率$P(x),Q(x)$分布的距离：如下</p>
<p>$$D_{KL}(P||Q) = \sum\limits_{i=1}logP(x)\frac{P(x)}{Q(X)}=E_{P(x)}[log\frac{P(x)}{Q(x)}]$$<br>其中$P(x),Q(x)$均为$0-1$的概率值。</p>
<p>在本式中，除以2处理</p>
<p>$$\mathop{min}\limits_{G}V(G,D)=\mathop{min}\limits_{G}E_{x\sim p_{data}}[log\frac{p_{data}/2}{(p_{data}+p_g)/2}]+E_{x\sim p_g}[log(\frac{p_g/2}{(p_{data}+p_g)/2})]$$   </p>
<p>$$=\mathop{min}\limits_{G}E_{x\sim p_{data}}[log\frac{p_{data}}{(p_{data}+p_g)/2}]+E_{x\sim p_g}[log(\frac{p_g}{(p_{data}+p_g)/2})]-log4$$  </p>
<p>$$=\mathop{min}\limits_{G} KL(p_{data}||\frac{p_{data}+p_g{}}{2})+KL(p_g||\frac{p_{data}+p_g{}}{2})-log4\geq -log4$$</p>
<p>当$p_g==p_{data}$时，取全局最优最小值。</p>
<h2 id="论文中实现生成对抗伪算法"><a href="#论文中实现生成对抗伪算法" class="headerlink" title="论文中实现生成对抗伪算法"></a>论文中实现生成对抗伪算法</h2><p><img src="/archives/f2925084/1.png" alt="algorithm"></p>
<blockquote>
<p><a href="https://arxiv.org/abs/1406.2661" target="_blank" rel="noopener">gan论文</a></p>
<p><a href="https://www.bilibili.com/video/BV1eE411g7xc" target="_blank" rel="noopener">视频讲解</a></p>
</blockquote>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>略。</p>
]]></content>
      <categories>
        <category>cv</category>
      </categories>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>风格迁移</title>
    <url>/archives/163371af.html</url>
    <content><![CDATA[<h2 id="先看一下迁移后的图片"><a href="#先看一下迁移后的图片" class="headerlink" title="先看一下迁移后的图片"></a>先看一下迁移后的图片</h2><a id="more"></a>

<p><a href="https://github.com/cysmith/neural-style-tf" target="_blank" rel="noopener">传送门</a></p>
<h2 id="VGG19"><a href="#VGG19" class="headerlink" title="VGG19"></a>VGG19</h2><p><img src="/archives/163371af/1.jpg" alt="Vgg19网络结构图"></p>
<p><img src="/archives/163371af/2.jpg" alt="上图进一步分离"></p>
<p>一些是运行中打印出的网络结构代码，与上图完全对应。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LAYER GROUP <span class="number">1</span> <span class="comment">#卷积层组1</span></span><br><span class="line"><span class="comment"># 下面有两个卷积层，一个池化层，relu为线性整流层，每次卷积后，都relu一下</span></span><br><span class="line">--conv1_1 | shape=(<span class="number">1</span>, <span class="number">663</span>, <span class="number">1000</span>, <span class="number">64</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">64</span>)</span><br><span class="line">--relu1_1 | shape=(<span class="number">1</span>, <span class="number">663</span>, <span class="number">1000</span>, <span class="number">64</span>) | bias_shape=(<span class="number">64</span>,)</span><br><span class="line">--conv1_2 | shape=(<span class="number">1</span>, <span class="number">663</span>, <span class="number">1000</span>, <span class="number">64</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line">--relu1_2 | shape=(<span class="number">1</span>, <span class="number">663</span>, <span class="number">1000</span>, <span class="number">64</span>) | bias_shape=(<span class="number">64</span>,)</span><br><span class="line">--pool1   | shape=(<span class="number">1</span>, <span class="number">332</span>, <span class="number">500</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">LAYER GROUP <span class="number">2</span> <span class="comment">#卷积层组2</span></span><br><span class="line"><span class="comment"># 下面有两个卷积层，一个池化层</span></span><br><span class="line">--conv2_1 | shape=(<span class="number">1</span>, <span class="number">332</span>, <span class="number">500</span>, <span class="number">128</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">128</span>)</span><br><span class="line">--relu2_1 | shape=(<span class="number">1</span>, <span class="number">332</span>, <span class="number">500</span>, <span class="number">128</span>) | bias_shape=(<span class="number">128</span>,)</span><br><span class="line">--conv2_2 | shape=(<span class="number">1</span>, <span class="number">332</span>, <span class="number">500</span>, <span class="number">128</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line">--relu2_2 | shape=(<span class="number">1</span>, <span class="number">332</span>, <span class="number">500</span>, <span class="number">128</span>) | bias_shape=(<span class="number">128</span>,)</span><br><span class="line">--pool2   | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">LAYER GROUP <span class="number">3</span> <span class="comment"># 卷积层组3</span></span><br><span class="line"><span class="comment"># 下面有四个卷积层，一个池化层</span></span><br><span class="line">--conv3_1 | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">256</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">128</span>, <span class="number">256</span>)</span><br><span class="line">--relu3_1 | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">256</span>) | bias_shape=(<span class="number">256</span>,)</span><br><span class="line">--conv3_2 | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">256</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">--relu3_2 | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">256</span>) | bias_shape=(<span class="number">256</span>,)</span><br><span class="line">--conv3_3 | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">256</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">--relu3_3 | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">256</span>) | bias_shape=(<span class="number">256</span>,)</span><br><span class="line">--conv3_4 | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">256</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">--relu3_4 | shape=(<span class="number">1</span>, <span class="number">166</span>, <span class="number">250</span>, <span class="number">256</span>) | bias_shape=(<span class="number">256</span>,)</span><br><span class="line">--pool3   | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">LAYER GROUP <span class="number">4</span> <span class="comment"># 卷积层组4</span></span><br><span class="line"><span class="comment"># 下面有四个卷积层，一个池化层</span></span><br><span class="line">--conv4_1 | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">512</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>, <span class="number">512</span>)</span><br><span class="line">--relu4_1 | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">512</span>) | bias_shape=(<span class="number">512</span>,)</span><br><span class="line">--conv4_2 | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">512</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">--relu4_2 | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">512</span>) | bias_shape=(<span class="number">512</span>,)</span><br><span class="line">--conv4_3 | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">512</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">--relu4_3 | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">512</span>) | bias_shape=(<span class="number">512</span>,)</span><br><span class="line">--conv4_4 | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">512</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">--relu4_4 | shape=(<span class="number">1</span>, <span class="number">83</span>, <span class="number">125</span>, <span class="number">512</span>) | bias_shape=(<span class="number">512</span>,)</span><br><span class="line">--pool4   | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">LAYER GROUP <span class="number">5</span> <span class="comment"># 卷积层组5</span></span><br><span class="line"><span class="comment"># 下面有四个卷积层，一个池化层</span></span><br><span class="line">--conv5_1 | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">--relu5_1 | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>) | bias_shape=(<span class="number">512</span>,)</span><br><span class="line">--conv5_2 | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">--relu5_2 | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>) | bias_shape=(<span class="number">512</span>,)</span><br><span class="line">--conv5_3 | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">--relu5_3 | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>) | bias_shape=(<span class="number">512</span>,)</span><br><span class="line">--conv5_4 | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>) | weights_shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">--relu5_4 | shape=(<span class="number">1</span>, <span class="number">42</span>, <span class="number">63</span>, <span class="number">512</span>) | bias_shape=(<span class="number">512</span>,)</span><br><span class="line">--pool5   | shape=(<span class="number">1</span>, <span class="number">21</span>, <span class="number">32</span>, <span class="number">512</span>)</span><br></pre></td></tr></table></figure>

<p>vgg 本身还是一个<a href="[https://blog.csdn.net/qq_25762497/article/details/51052861#%E5%8D%B7%E7%A7%AF%E5%B1%82convolutional-layer](https://blog.csdn.net/qq_25762497/article/details/51052861#卷积层convolutional-layer)">卷积神经网络（CNN）(详细介绍)</a>，卷积神经网络由输入层、卷积层、激活函数、池化层、全连接层组成，即INPUT（输入层）-CONV（卷积层）-RELU（激活函数）-POOL（池化层）-FC（全连接层）。</p>
<p>vgg19在卷积☛池化部分做了扩充修改。</p>
<p>由图及code，可以观察到，vgg19一共有五个卷积层组（conv layer），卷积层使用的卷积核均为3×3卷积核，三个全连接层（FC layer）。</p>
<p>共计一共19个隐藏层，其中16个卷积层，1个池化层。</p>
<ol>
<li><p>VGG优点:<br> VGGNet的结构非常简洁，整个网络都使用了同样大小的卷积核尺寸（3x3）和池化尺寸（2x2）。<br> 几个小滤波器（3x3）卷积层的组合比一个大滤波器（5x5或7x7）卷积层好：验证了通过不断加深网络结构可以提升性能。</p>
</li>
<li><p>VGG缺点:<br> VGG耗费更多计算资源，并且使用了更多的参数（这里不是3x3卷积的锅），导致更多的内存占用。</p>
</li>
</ol>
<p>其中绝大多数的参数都是来自于第一个全连接层。VGG可是有3个全连接层</p>
<h2 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a><a href="ww.cv-foundation.org/openaccess/content_cvpr_2016/papers/Gatys_Image_Style_Transfer_CVPR_2016_paper.pdf">论文阅读</a></h2><ol>
<li>原始content图像，用$\vec{p}$表示，即最开始输入图像内容。</li>
<li>生成图像，用$\vec{x}$表示，即迁移学习过程中生成的图像。</li>
<li>原始style图像，用$\vec{a}$表示，即输入风格图像。</li>
<li>$N_l$：在第$l$个网络层中的feature map数</li>
<li>$M_l$：在第$l$个网络层中的feature map大小，即feature map的长宽乘积。</li>
<li>$F^l$：图像在第$l$个网络层的所有特征图组成的矩阵。</li>
<li>$F^l_{ij}$：原content图像在第$l$个网络层的$F^l$在第$i$个filter，位置$j$处的激活。</li>
<li>$A^l_{ij}$：原style图像在第$l$个网络层的$A^l$在第$i$个filter，位置$j$处的激活。</li>
<li>$P^l_{ij}$：同$F^l_{ij}$，$P$表示生成过程中图像。</li>
<li>定义误差损失函数$L_{content}(\vec{p},\vec{x},l) = \frac{1}{2}\sum\limits_{i,j}(F_{ij}^l-P_{ij}^l)^2$</li>
<li>$G_{il}^l = \sum\limits_{k}F_{ik}^lF_{kj}^l$，表示在第$l$层，feature map <code>i</code>与feature map <code>j</code>的内积。</li>
<li>$E_l=\frac{1}{4N_l^2M_l^2}\sum\limits_{i,j}(G_{ij}^l-A_{ij}^l)^2$，生成图像与原始style图像在第$l$层的均方损失。</li>
<li>$L_{style}(\vec{a},\vec{x})=\sum\limits_{l=0}^Lw_lE_l$，每一层生成的图像$\vec{x}$与原始style图像的总损失。</li>
<li>$L_{total} = {\alpha}L_{content}(\vec{p},\vec{x})+{\beta}L_{style}(\vec{a},\vec{x})$</li>
</ol>
<p>未写其反向传播过程，不太理解他那张图。待填坑。</p>
]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>第88场周赛</title>
    <url>/archives/5122a47f.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-88/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="848-字母移位"><a href="#848-字母移位" class="headerlink" title="848. 字母移位"></a><a href="https://leetcode-cn.com/problems/shifting-letters/" target="_blank" rel="noopener">848. 字母移位</a></h4><p><strong>题解</strong>：根据描述，第一反应模拟这个过程，超时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shiftingLetters</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; shifts)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;shifts.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            S = shiftStr(S,shifts[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shiftStr</span><span class="params">(<span class="built_in">string</span> &amp;s,<span class="keyword">int</span> shift,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        shift%=<span class="number">26</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()&amp;&amp;i&lt;=<span class="built_in">end</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] =<span class="string">'a'</span> + (s[i]-<span class="string">'a'</span>+shift)%<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第二反应：根据上述这个模拟超时过程，想一优化，shifts数组后面开始，逐个偏移，根据描述，后面的偏移会加到前面。于是有了后缀和这一说法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shiftingLetters</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; shifts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=shifts.<span class="built_in">size</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            shifts[i]%=<span class="number">26</span>;</span><br><span class="line">            shifts[i]+=shifts[i+<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//计算后缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            S[i] =<span class="string">'a'</span> + (S[i]-<span class="string">'a'</span>+shifts[i])%<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="849-到最近的人的最大距离"><a href="#849-到最近的人的最大距离" class="headerlink" title="849. 到最近的人的最大距离"></a><a href="https://leetcode-cn.com/problems/maximize-distance-to-closest-person/" target="_blank" rel="noopener">849. 到最近的人的最大距离</a></h4><p><strong>题解</strong>：根据描述，本题可转换为最长连续0的长度。分三种情况，一开始就连续的0（左边无1），在中间连续的0（指0的左右都有1），在末尾连续的0（右边无1）.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDistToClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; seats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = seats.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> K = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        &#123;<span class="comment">//统计中间0的长度，</span></span><br><span class="line">            <span class="keyword">if</span> (seats[i] == <span class="number">1</span>)</span><br><span class="line">                K = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                K++;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, (K + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        &#123;<span class="comment">//统计第一种情况</span></span><br><span class="line">            <span class="keyword">if</span> (seats[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;<span class="comment">//统计第三种情况</span></span><br><span class="line">            <span class="keyword">if</span> (seats[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, N - <span class="number">1</span> - i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="851-喧闹和富有"><a href="#851-喧闹和富有" class="headerlink" title="851. 喧闹和富有"></a><a href="https://leetcode-cn.com/problems/loud-and-rich/" target="_blank" rel="noopener">851. 喧闹和富有</a></h4><p><strong>题解</strong>：根据描述，好像描述有点复杂，上图。</p>
<p><img src="/archives/5122a47f/1.png" alt></p>
<p>依据谁比谁更穷（比如0号选手比1号选手穷）这样的关系，构建了一个有向图。旁边红字对应的是每位选手的安静值。题目的意思就是把每位选手的安静值更新为所有比他富有的选手的安静值中，最小值对应的选手，怎么办？模拟图的深搜过程，假设DFS(i)表示所有比i号选手富有的选手的最小安静值对应的选手。那么,写成代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;answer;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;graph;</span><br><span class="line">   <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">loudAndRich</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; richer, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quiet)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> N = quiet.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> node=<span class="number">0</span>;node&lt;N;++node)</span><br><span class="line">       &#123;<span class="comment">//邻接表初始化</span></span><br><span class="line">           <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">           graph.push_back(v);</span><br><span class="line">           answer.push_back(<span class="number">-1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> i:richer)</span><br><span class="line">           graph[i[<span class="number">1</span>]].push_back(i[<span class="number">0</span>]);</span><br><span class="line">       <span class="comment">//邻接表赋值</span></span><br><span class="line">   </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> node=<span class="number">0</span>;node&lt;N;node++)</span><br><span class="line">           dfs(node,quiet);</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">return</span> answer;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;quiet)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (answer[node] == <span class="number">-1</span>) </span><br><span class="line">       &#123;</span><br><span class="line">           answer[node] = node;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> child: graph[node])</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">int</span> cand = dfs(child,quiet);</span><br><span class="line">               <span class="keyword">if</span> (quiet[cand] &lt; quiet[answer[node]])</span><br><span class="line">                   answer[node] = cand;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> answer[node];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="850-矩形面积-II"><a href="#850-矩形面积-II" class="headerlink" title="850. 矩形面积 II"></a><a href="https://leetcode-cn.com/problems/rectangle-area-ii/" target="_blank" rel="noopener">850. 矩形面积 II</a></h4><p>不会，待填坑，开始复习简历上的内容了。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第87场周赛</title>
    <url>/archives/a029fff2.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-87/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a><a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener">844. 比较含退格的字符串</a></h4><p><strong>题解</strong>：日常水题，根据描述，按照描述来干了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s_tmp = enterStr(S);</span><br><span class="line">        <span class="built_in">string</span> t_tmp = enterStr(T);</span><br><span class="line">        <span class="keyword">return</span> s_tmp== t_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">enterStr</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'#'</span>&amp;&amp;(ret.length()&gt;<span class="number">0</span>)) ret.erase(ret.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'#'</span>&amp;&amp;(ret.length()==<span class="number">0</span>))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> ret+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="845-数组中的最长山脉"><a href="#845-数组中的最长山脉" class="headerlink" title="845. 数组中的最长山脉"></a><a href="https://leetcode-cn.com/problems/longest-mountain-in-array/" target="_blank" rel="noopener">845. 数组中的最长山脉</a></h4><p><strong>题解</strong>：超喜欢这类写的工工整整的题目。根据描述，只要我们遍历数组，找到符合山脉条件（中间的山要高于两侧）的位置，然后以该位置为中心，向左右拓展。（改一下写代码习惯，括号另起一行书写）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.<span class="built_in">size</span>()&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;A[i<span class="number">-1</span>]&amp;&amp;A[i]&gt;A[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">int</span> left = i<span class="number">-1</span>;</span><br><span class="line">               	<span class="keyword">while</span>(left&gt;<span class="number">0</span> &amp;&amp;A[left]&gt;A[left<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp++;</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> right = i+<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">while</span>(right&lt;A.<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;A[right]&gt;A[right+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp++;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret=<span class="built_in">max</span>(ret,tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="846-一手顺子"><a href="#846-一手顺子" class="headerlink" title="846. 一手顺子"></a><a href="https://leetcode-cn.com/problems/hand-of-straights/" target="_blank" rel="noopener">846. 一手顺子</a></h4><p><strong>题解</strong>：根据描述，只需要对手上所有的牌建立一个map，每三张连续的牌的val-1，一直检测，若不能检测到连续的牌，return false。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNStraightHand</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; hand, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = hand.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n % W != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : hand) mp[i]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>();it != mp.<span class="built_in">end</span>();)&#123;</span><br><span class="line">            <span class="keyword">while</span>(it!=mp.<span class="built_in">end</span>() &amp;&amp; it-&gt;second &lt;= <span class="number">0</span>) it++;</span><br><span class="line">            <span class="keyword">if</span>(iter == mp.<span class="built_in">end</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> cm = it-&gt;first,cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(cnt = <span class="number">0</span>;cnt &lt; W;++cnt) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[cm] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    mp[cm]--;</span><br><span class="line">                    cm++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="847-访问所有节点的最短路径"><a href="#847-访问所有节点的最短路径" class="headerlink" title="847. 访问所有节点的最短路径"></a><a href="https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/" target="_blank" rel="noopener">847. 访问所有节点的最短路径</a></h4>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第86场周赛</title>
    <url>/archives/4feb94cc.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-86/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="840-矩阵中的幻方"><a href="#840-矩阵中的幻方" class="headerlink" title="840. 矩阵中的幻方"></a><a href="https://leetcode-cn.com/problems/magic-squares-in-grid/" target="_blank" rel="noopener">840. 矩阵中的幻方</a></h4><p><strong>题解</strong>：根据描述，第一反应，由数据范围，满足题意的3×3的矩阵，从3×3矩阵的中间元素暴力枚举。</p>
<p>如何判断一个3×3矩阵是幻方的？首先这9个数均不相同，其次这9个数范围为1-9。最后每一行每一列，和对角线元素和均为15，最中间元素为5。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numMagicSquaresInside</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;++j)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(judgeSquares(grid,i,j)) ret++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s = &#123;grid[i<span class="number">-1</span>][j<span class="number">-1</span>],grid[i<span class="number">-1</span>][j],grid[i<span class="number">-1</span>][j+<span class="number">1</span>],</span><br><span class="line">                    grid[i][j<span class="number">-1</span>],grid[i][j],grid[i][j+<span class="number">1</span>],</span><br><span class="line">                    grid[i+<span class="number">1</span>][j<span class="number">-1</span>],grid[i+<span class="number">1</span>][j],grid[i+<span class="number">1</span>][j+<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()!=<span class="number">9</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=<span class="number">0</span>||i&gt;<span class="number">10</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (grid[i][j]==<span class="number">5</span>&amp;&amp;(grid[i<span class="number">-1</span>][j<span class="number">-1</span>]+grid[i<span class="number">-1</span>][j]+grid[i<span class="number">-1</span>][j+<span class="number">1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i][j<span class="number">-1</span>]+grid[i][j]+grid[i][j+<span class="number">1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i+<span class="number">1</span>][j<span class="number">-1</span>]+grid[i+<span class="number">1</span>][j]+grid[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i<span class="number">-1</span>][j<span class="number">-1</span>]+grid[i][j]+grid[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i<span class="number">-1</span>][j+<span class="number">1</span>]+grid[i][j]+grid[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i<span class="number">-1</span>][j<span class="number">-1</span>]+grid[i][j<span class="number">-1</span>]+grid[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i<span class="number">-1</span>][j]+grid[i][j]+grid[i+<span class="number">1</span>][j]==<span class="number">15</span>)</span><br><span class="line">                        &amp;&amp;(grid[i<span class="number">-1</span>][j+<span class="number">1</span>]+grid[i][j+<span class="number">1</span>]+grid[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">15</span>)</span><br><span class="line">                        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="841-钥匙和房间"><a href="#841-钥匙和房间" class="headerlink" title="841. 钥匙和房间"></a><a href="https://leetcode-cn.com/problems/keys-and-rooms/" target="_blank" rel="noopener">841. 钥匙和房间</a></h4><p><strong>题解</strong>：根据描述，第一反应，我们只需要按照他的描述，进一个房间，拿钥匙，再进另一个房间。自然转换成深度优先搜索了。</p>
<p>第二反应，其实就是遍历一遍，看哪些房间不可到达。可用BFS</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = rooms.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;visit(len,<span class="number">0</span>);</span><br><span class="line">        dfs(rooms,<span class="number">0</span>,visit);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:visit)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms,<span class="keyword">int</span> i,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;visit)</span></span>&#123;</span><br><span class="line">        visit[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> room:rooms[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[room]) dfs(rooms,room,visit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="842-将数组拆分成斐波那契序列"><a href="#842-将数组拆分成斐波那契序列" class="headerlink" title="842. 将数组拆分成斐波那契序列"></a><a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/" target="_blank" rel="noopener">842. 将数组拆分成斐波那契序列</a></h4><h4 id="843-猜猜这个单词"><a href="#843-猜猜这个单词" class="headerlink" title="843. 猜猜这个单词"></a><a href="https://leetcode-cn.com/problems/guess-the-word/" target="_blank" rel="noopener">843. 猜猜这个单词</a></h4>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第85场周赛</title>
    <url>/archives/a4dc2fcf.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-85/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="836-矩形重叠"><a href="#836-矩形重叠" class="headerlink" title="836. 矩形重叠"></a><a href="https://leetcode-cn.com/problems/rectangle-overlap/" target="_blank" rel="noopener">836. 矩形重叠</a></h4><p><strong>题解</strong>：根据描述，我们需要找到什么时候才是重合的规律。如图所示，</p>
<p><img src="/archives/a4dc2fcf/1.png" alt></p>
<p>可以看到规律了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rec2[<span class="number">0</span>]&lt;rec1[<span class="number">2</span>] &amp;&amp; rec2[<span class="number">1</span>]&lt;rec1[<span class="number">3</span>] &amp;&amp; rec2[<span class="number">2</span>]&gt;rec1[<span class="number">0</span>] &amp;&amp; rec2[<span class="number">3</span>]&gt;rec1[<span class="number">1</span>] )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="838-推多米诺"><a href="#838-推多米诺" class="headerlink" title="838. 推多米诺"></a><a href="https://leetcode-cn.com/problems/push-dominoes/" target="_blank" rel="noopener">838. 推多米诺</a></h4><p><strong>题解</strong>：根据描述，第一反应时模拟这个过程，把每经过一秒后的状态表示出来，再用这个新状态去更新这个过程。当状态没有更新，结束这个模拟过程。有如下code，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">pushDominoes</span><span class="params">(<span class="built_in">string</span> dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = dominoes.length();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> dominoes;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">int</span> flag;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            ret = <span class="string">""</span>;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(dominoes[<span class="number">0</span>]==<span class="string">'.'</span>&amp;&amp;dominoes[<span class="number">1</span>]==<span class="string">'L'</span>)&#123;</span><br><span class="line">                ret+=<span class="string">"L"</span>;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ret+=dominoes[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len<span class="number">-1</span>;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;i&lt;len<span class="number">-1</span>&amp;&amp;dominoes[i]==<span class="string">'.'</span>&amp;&amp;dominoes[i+<span class="number">1</span>]==<span class="string">'L'</span>&amp;&amp;dominoes[i<span class="number">-1</span>]!=<span class="string">'R'</span>)&#123;</span><br><span class="line">                    ret+=<span class="string">"LL"</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;i&lt;len<span class="number">-1</span>&amp;&amp;dominoes[i]==<span class="string">'.'</span>&amp;&amp;dominoes[i<span class="number">-1</span>]==<span class="string">'R'</span>&amp;&amp;dominoes[i+<span class="number">1</span>]!=<span class="string">'L'</span>)&#123;</span><br><span class="line">                    ret+=<span class="string">"R"</span>;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ret+=dominoes[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dominoes[len<span class="number">-2</span>]==<span class="string">'R'</span>&amp;&amp;dominoes[len<span class="number">-1</span>]==<span class="string">'.'</span>)&#123;</span><br><span class="line">                ret+=<span class="string">"R"</span>;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ret+=dominoes[len<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        dominoes = ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第二反应：上面这个过程复杂了。每次都要针对原有状态遍历一遍，产生新的状态，很是繁琐。</p>
<p>从左到右遍历一遍字符串，分一下几种情况（记下第一个LR的位置，然后在下一个字符型LR的时候处理这一段的字符）<br>L—–L 里面‘.’全部填充L；<br>L—–R 里面左边一半填充L，右边一半填充R（注意这里要分类，中间可能会有一个‘.’或者没有）<br>R—–R 里面‘.’全部填充R；<br>R—–L 不用处理；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//从a-b位置的全部变成指定的lr符号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trans</span><span class="params">(<span class="built_in">string</span>&amp; temp,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">char</span> lr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=a;i&lt;=b;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp[i]=lr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">pushDominoes</span><span class="params">(<span class="built_in">string</span> dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> temp=dominoes;<span class="comment">//用于存储结果</span></span><br><span class="line">        <span class="keyword">char</span> temp1=<span class="string">'N'</span>;<span class="comment">//上一个识别的字符是L还是R</span></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">-1</span>;<span class="comment">//上一个识别的字符是位置标号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dominoes.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断此时的字符串是L</span></span><br><span class="line">            <span class="keyword">if</span>(dominoes[i]==<span class="string">'L'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//左侧符号位为N的时候，左侧全部填充L</span></span><br><span class="line">                 <span class="keyword">if</span>(temp1==<span class="string">'N'</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     trans(temp,<span class="number">0</span>,i<span class="number">-1</span>,<span class="string">'L'</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">                <span class="comment">//左侧符号位为L的时候，左侧全部填充L</span></span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span>(temp1==<span class="string">'L'</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     trans(temp,index+<span class="number">1</span>,i<span class="number">-1</span>,<span class="string">'L'</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">                <span class="comment">//左侧符号位为R的时候，靠近左侧填充R，右侧填充L（填充个数为m=(i-index-1)/2）</span></span><br><span class="line">                 <span class="keyword">else</span> </span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">int</span> m=(i-index<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                     trans(temp,index+<span class="number">1</span>,index+m,<span class="string">'R'</span>);</span><br><span class="line">                     trans(temp,i-m,i<span class="number">-1</span>,<span class="string">'L'</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">                 temp1=<span class="string">'L'</span>;</span><br><span class="line">                 index=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时的符号位R</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dominoes[i]==<span class="string">'R'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//上一个符号为R,则填充R，其他情况不用考虑</span></span><br><span class="line">                <span class="keyword">if</span>(temp1==<span class="string">'R'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=index+<span class="number">1</span>)</span><br><span class="line">                        trans(temp,index+<span class="number">1</span>,i<span class="number">-1</span>,<span class="string">'R'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                 temp1=<span class="string">'R'</span>;</span><br><span class="line">                 index=i;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左侧是R到字符串结尾没有处理 需要全部变成R</span></span><br><span class="line">        <span class="keyword">if</span>(temp1==<span class="string">'R'</span>)</span><br><span class="line">            trans(temp,index+<span class="number">1</span>,temp.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="string">'R'</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：brother_of_brother</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/push-dominoes/solution/cxiang-xi-ti-jie-by-brother_of_brother/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h4 id="837-新21点"><a href="#837-新21点" class="headerlink" title="837. 新21点"></a><a href="https://leetcode-cn.com/problems/new-21-game/" target="_blank" rel="noopener">837. 新21点</a></h4><p><strong>题解</strong>：</p>
<h4 id="839-相似字符串组"><a href="#839-相似字符串组" class="headerlink" title="839. 相似字符串组"></a><a href="https://leetcode-cn.com/problems/similar-string-groups/" target="_blank" rel="noopener">839. 相似字符串组</a></h4>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第84场周赛</title>
    <url>/archives/4b1e44f1.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-84/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="832-翻转图像"><a href="#832-翻转图像" class="headerlink" title="832. 翻转图像"></a><a href="https://leetcode-cn.com/problems/flipping-an-image/" target="_blank" rel="noopener">832. 翻转图像</a></h4><p><strong>题解</strong>：根据描述，我们按照描述一步一步来就行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flipAndInvertImage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;A[i].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                A[i][j] =(!A[i][j]); </span><br><span class="line">            &#125;</span><br><span class="line">            reverse(A[i].<span class="built_in">begin</span>(),A[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="833-字符串中的查找与替换"><a href="#833-字符串中的查找与替换" class="headerlink" title="833. 字符串中的查找与替换"></a><a href="https://leetcode-cn.com/problems/find-and-replace-in-string/" target="_blank" rel="noopener">833. 字符串中的查找与替换</a></h4><p>题解：根据描述，有如下想法，对于测试点1，只要找到首个匹配字符位置，末尾字符匹配位置，使用replace函数替换即可。在下轮替换的时候，开始找的位置应为由于插入而带来的字符串长度改变的偏置。</p>
<p>根据这一想法，可以通过前8个测试点。后面的替换位置并不是有序的，因此我们需要把替换位置sort一下。重写一下输入的数据结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp</span>&#123;</span></span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            <span class="built_in">string</span> source;</span><br><span class="line">            <span class="built_in">string</span> target;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(struct tmp a,struct tmp b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a.index&lt;b.index;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findReplaceString</span><span class="params">(<span class="built_in">string</span> &amp;S, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indexes, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; sources, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; targets)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;struct tmp&gt;v(indexes.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;indexes.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            v[i].index = indexes[i];</span><br><span class="line">            v[i].source = sources[i];</span><br><span class="line">            v[i].target = targets[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">int</span> bisa=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;indexes.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="number">0</span>,j,start=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i=<span class="number">0</span>)j = v[i].index;</span><br><span class="line">            <span class="keyword">else</span> j = v[i].index+bisa;</span><br><span class="line">            start=j;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;S.length();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(S[j]!=v[i].source[k])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k==v[i].source.length())&#123;</span><br><span class="line">                S.replace(S.<span class="built_in">begin</span>()+start,S.<span class="built_in">begin</span>()+start+v[i].source.length(),v[i].target);</span><br><span class="line">                <span class="comment">//每次替换带来了偏置</span></span><br><span class="line">                 bisa += v[i].target.length()-v[i].source.length();</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="835-图像重叠"><a href="#835-图像重叠" class="headerlink" title="835. 图像重叠"></a><a href="https://leetcode-cn.com/problems/image-overlap/" target="_blank" rel="noopener">835. 图像重叠</a></h4><p>题解：根据描述，数据量在$0-30$范围内，使用蛮力算法即可。<br>枚举A中出现的1，对于B中出现的1，有相同偏置的位置在记录数组中加一。比如</p>
<table>
<thead>
<tr>
<th align="center">index A</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">index B</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>对于矩阵A(0,0)处的1，B中所有的1(分别位于[(1,1)(1,2),(2,2)]处)，相对于A(0,0)处的偏置分别为[(1,1)(1,2),(2,2)] <strong>下标相减即可</strong></p>
<p>对于矩阵A(0,1)处的1，B中所有的1(分别位于[(1,1)(1,2),(2,2)]处)，相对于A(0,0)处的偏置分别为[(1,0),(1,1),(2,1)]</p>
<p>对于矩阵A(1,1)处的1，B中所有的1(分别位于[(1,1)(1,2),(2,2)]处)，相对于A(0,0)处的偏置分别为[(0,0),(0,1),(1,1)]</p>
<p>对于矩阵A(2,1)处的1，B中所有的1(分别位于[(1,1)(1,2),(2,2)]处)，相对于A(0,0)处的偏置分别为[(-1,0),(-1,1),(0,2)]</p>
<p>统计偏置数组[(1,1)(1,2),(2,2)]，[(1,0)(1,1),(2,1)]，[(0,0),(0,1),(1,1)]，[(-1,0),(-1,1),(0,2)]，可发现(1,1)出现最多，是为3次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">2</span>*N][<span class="number">2</span>*N];</span><br><span class="line">        <span class="built_in">memset</span>(count,<span class="number">0</span>,<span class="keyword">sizeof</span>(count));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">0</span>; i2 &lt; N; ++i2)</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j2 = <span class="number">0</span>; j2 &lt; N; ++j2)</span><br><span class="line">                            <span class="keyword">if</span> (B[i2][j2] == <span class="number">1</span>)</span><br><span class="line">                                count[i-i2 +N][j-j2 +N] += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*N;++j)&#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret,count[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="834-树中距离之和"><a href="#834-树中距离之和" class="headerlink" title="834. 树中距离之和"></a><a href="https://leetcode-cn.com/problems/sum-of-distances-in-tree/" target="_blank" rel="noopener">834. 树中距离之和</a></h4>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第83场周赛</title>
    <url>/archives/a9c25f88.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-83/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="830-较大分组的位置"><a href="#830-较大分组的位置" class="headerlink" title="830. 较大分组的位置"></a><a href="https://leetcode-cn.com/problems/positions-of-large-groups/" target="_blank" rel="noopener">830. 较大分组的位置</a></h4><p><strong>题解</strong>：根据描述，只要设置两个指针$i$，$j$。初始$i$指向第一次出现的字母，$j$指向$i$的后面一个位置，不断增加$j$，使得$i$与$j$之间的字母相同，当$j$指向字母与$i$不同时且$ij$之间的距离大于等于3保存结果，小于3则更新$i$至位置$j$，$j$向后移动一位。</p>
<p>注意如字符串$“aaa”$，上述原则失效，可以在$“aaa”$后增加一个哨兵(一个隐藏的字符)。也可以在最后增加一个判断。当上述循环结束时，$ij$距离大于2即可。以下是个人code。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">largeGroupPositions</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;ret;</span><br><span class="line">        <span class="keyword">if</span>(!S.length()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>,j = <span class="number">1</span>;i&lt;S.length()&amp;&amp;j&lt;S.length();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==S[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>((j-i)&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                    ret.emplace_back(&#123;i,j<span class="number">-1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                i = j;</span><br><span class="line">                j = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((j-i)&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            ret.emplace_back(&#123;i,j<span class="number">-1</span>&#125;);&#125;</span><br><span class="line">        <span class="keyword">return</span> ret;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="831-隐藏个人信息"><a href="#831-隐藏个人信息" class="headerlink" title="831. 隐藏个人信息"></a><a href="https://leetcode-cn.com/problems/masking-personal-information/" target="_blank" rel="noopener">831. 隐藏个人信息</a></h4><p><strong>题解</strong>：根据描述，我们只需要根据是否有@符号，设计两个函数maskMail与maskPhone。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">maskPII</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;    	</span><br><span class="line">    transform(S.<span class="built_in">begin</span>(),S.<span class="built_in">end</span>(),S.<span class="built_in">begin</span>(),::<span class="built_in">tolower</span>);</span><br><span class="line">    <span class="comment">//转换所有字符变为小写</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:S)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="string">'@'</span>)&#123;</span><br><span class="line">                <span class="comment">//当有@符号，用maskMail</span></span><br><span class="line">                <span class="built_in">string</span> ret = maskMail(S);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//没有@符号，用maskPhone</span></span><br><span class="line">        <span class="built_in">string</span> ret = maskPhone(S);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">maskMail</span><span class="params">(<span class="built_in">string</span> S)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;S.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[j]==<span class="string">'@'</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> star = <span class="string">"*****"</span>;</span><br><span class="line">        star.insert(star.<span class="built_in">begin</span>(),S[<span class="number">0</span>]);</span><br><span class="line">        star.insert(star.<span class="built_in">end</span>(),S[j<span class="number">-1</span>]);</span><br><span class="line">        <span class="built_in">string</span> ret=star+S.substr(j,S.length()-j);</span><br><span class="line">        <span class="keyword">return</span> ret;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">maskPhone</span><span class="params">(<span class="built_in">string</span> &amp;S)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:S)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="string">'0'</span>&amp;&amp;i&lt;=<span class="string">'9'</span>) tmp.emplace_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        由于电话号码的数字只有10-13位，根据数字长度，</span></span><br><span class="line"><span class="comment">        加上不同的前缀即可。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">size</span>()==<span class="number">10</span>)&#123;</span><br><span class="line">            ret+=<span class="string">"***-***-"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">6</span>;i&lt;<span class="number">10</span>;i++) ret+=tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">size</span>()==<span class="number">11</span>)&#123;</span><br><span class="line">            ret+=<span class="string">"+*-***-***-"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&lt;<span class="number">11</span>;i++) ret+=tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">size</span>()==<span class="number">12</span>)&#123;</span><br><span class="line">            ret+=<span class="string">"+**-***-***-"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">8</span>;i&lt;<span class="number">12</span>;i++) ret+=tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">size</span>()==<span class="number">13</span>)&#123;</span><br><span class="line">            ret+=<span class="string">"+***-***-***-"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">9</span>;i&lt;<span class="number">13</span>;i++) ret+=tmp[i];</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="829-连续整数求和"><a href="#829-连续整数求和" class="headerlink" title="829. 连续整数求和"></a><a href="https://leetcode-cn.com/problems/consecutive-numbers-sum/" target="_blank" rel="noopener">829. 连续整数求和</a></h4><p>题解：根据题意，</p>
<p>第一反应：蛮力遍历求和，看是否有满足连续的整数和。<br>第二反应：使用等差数列求和公式，设求和为$N$，求和起点为$x$，一共有$k$个数参与求和，那么有<br>$$N = (x+1)+(x+2)+…+(x+k)=\frac{(2x+k+1)k}{2}$$</p>
<p>解得$$x = \frac{1}{2}(\frac{2N}{k} - k - 1)$$，至此，只要枚举$k(k&gt;=1)$，并且使得$x$为整数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">consecutiveNumbersSum</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2N = k(2x + k + 1)</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>*N; ++k)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * N % k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = <span class="number">2</span> * N / k - k - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (y % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span>)</span><br><span class="line">                    ret++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三反应：减小$k$的枚举范围。<br>$$N = (x+1)+(x+2)+…+(x+k)=\frac{(2x+k+1)k}{2}$$<br>在该式中，明显可观察到$k&lt;2x+k+1$，由此我们可用小学二年级学过的放缩大致确定$k&lt;\sqrt{2n}$。</p>
<p>第四反应:</p>
<p><img src="/archives/a9c25f88/1.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">consecutiveNumbersSum</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; N &gt; <span class="number">0</span>; N-=i, i++)</span><br><span class="line">        ans += (N % i == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第四种解法可以看作另一种形式的枚举吧，优美且简洁。</span></span><br><span class="line">作者：pris_bupt</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/consecutive-numbers-sum/solution/c-ji-jian-by-pris_bupt/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h4 id="828-统计子串中的唯一字符"><a href="#828-统计子串中的唯一字符" class="headerlink" title="828. 统计子串中的唯一字符"></a><a href="https://leetcode-cn.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/" target="_blank" rel="noopener">828. 统计子串中的唯一字符</a></h4><p>题解：待填坑（我不会，哭唧唧）</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>第184场周赛</title>
    <url>/archives/c4e3d004.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-184/" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h4 id="5380-数组中的字符串匹配"><a href="#5380-数组中的字符串匹配" class="headerlink" title="5380. 数组中的字符串匹配"></a><a href="https://leetcode-cn.com/problems/string-matching-in-an-array/" target="_blank" rel="noopener">5380. 数组中的字符串匹配</a></h4><p><strong>题解</strong>：根据描述，加上简单题，以及数据规模很小，不妨有按照题目描述解法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.length()&lt;b.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">stringMatching</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sort(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;words.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> <span class="built_in">begin</span>=<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>((<span class="built_in">begin</span>=words[j].<span class="built_in">find</span>(words[i],<span class="built_in">begin</span>+<span class="number">1</span>))!=<span class="built_in">string</span>::npos)</span><br><span class="line">                &#123;<span class="comment">//此句为字符串匹配</span></span><br><span class="line">                    ret.push_back(words[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5381-查询带键的排列"><a href="#5381-查询带键的排列" class="headerlink" title="5381. 查询带键的排列"></a><a href="https://leetcode-cn.com/problems/queries-on-a-permutation-with-key/" target="_blank" rel="noopener">5381. 查询带键的排列</a></h4><p><strong>题解</strong>：根据描述，有了啊，有了啥？有了答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">processQueries</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;p;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)p.push_back(i);<span class="comment">//根据描述生成数组p</span></span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ret;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queries.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">           <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(),queries[i]);</span><br><span class="line">           <span class="keyword">int</span> tmp = *it;<span class="comment">//1.保存移动的值</span></span><br><span class="line">           p.erase(it);<span class="comment">//2. 删掉</span></span><br><span class="line">           ret.push_back(it-p.<span class="built_in">begin</span>());<span class="comment">//3. 插到最前面</span></span><br><span class="line">           p.insert(p.<span class="built_in">begin</span>(),tmp);<span class="comment">//</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1410-HTML-实体解析器"><a href="#1410-HTML-实体解析器" class="headerlink" title="1410. HTML 实体解析器"></a><a href="https://leetcode-cn.com/problems/html-entity-parser/" target="_blank" rel="noopener">1410. HTML 实体解析器</a></h4><p><strong>题解</strong>：本次周赛前三题都是模拟题呢？没有啥子变通，根据题意模拟就行啦，自己的代码功底（API）熟悉程度不行啊，哭唧唧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">entityParser</span><span class="params">(<span class="built_in">string</span> <span class="built_in">text</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">char</span>&gt;m = &#123;&#123;<span class="string">"&amp;gt"</span>,<span class="string">'&gt;'</span>&#125;,&#123;<span class="string">"&amp;lt"</span>,<span class="string">'&lt;'</span>&#125;,&#123;<span class="string">"&amp;amp"</span>,<span class="string">'&amp;'</span>&#125;,&#123;<span class="string">"&amp;quot"</span>,<span class="string">'"'</span>&#125;,&#123;<span class="string">"&amp;apos"</span>,<span class="string">'\''</span>&#125;,&#123;<span class="string">"&amp;frasl"</span>,<span class="string">'/'</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">text</span>.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">text</span>[i]!=<span class="string">'&amp;'</span>) ret+=<span class="built_in">text</span>[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">string</span> sub = <span class="built_in">text</span>.substr(i,<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j:m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sub==j.first)&#123;</span><br><span class="line">                        flag = <span class="number">1</span>;</span><br><span class="line">                        ret+=j.second;</span><br><span class="line">                        i+=<span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                sub = <span class="built_in">text</span>.substr(i,<span class="number">4</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j:m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sub==j.first)&#123;</span><br><span class="line">                        flag=<span class="number">1</span>;</span><br><span class="line">                        ret+=j.second;</span><br><span class="line">                        i+=<span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                sub = <span class="built_in">text</span>.substr(i,<span class="number">5</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j:m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sub==j.first)&#123;</span><br><span class="line">                        flag=<span class="number">1</span>;</span><br><span class="line">                        ret+=j.second;</span><br><span class="line">                        i+=<span class="number">5</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sub = <span class="built_in">text</span>.substr(i,<span class="number">6</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j:m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sub==j.first)&#123;</span><br><span class="line">                        flag =<span class="number">1</span>;</span><br><span class="line">                        ret+=j.second;</span><br><span class="line">                        i+=<span class="number">6</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag ==<span class="number">0</span>) ret+=<span class="string">'&amp;'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5383-给-N-x-3-网格图涂色的方案数"><a href="#5383-给-N-x-3-网格图涂色的方案数" class="headerlink" title="5383. 给 N x 3 网格图涂色的方案数"></a><a href="https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid/" target="_blank" rel="noopener">5383. 给 N x 3 网格图涂色的方案数</a></h4><p>题解：先看图</p>
<p><img src="/archives/c4e3d004/1.png" alt></p>
<p>根据上图，可以将排列情况分为两种，ABA，ABC，前者颜色有重复，后者无，在这两种下面再添加元素有这么12种选择</p>
<p>ABC  ACB BAC BCA  CAB CBA  ABA ACA BAB BCB CAC CBC</p>
<p>可分别加入到下面的如表格所示</p>
<table>
<thead>
<tr>
<th align="center">ABA</th>
<th align="center">ABC</th>
</tr>
</thead>
<tbody><tr>
<td align="center">unrepeat：BAC</td>
<td align="center">unrepeat：BCA</td>
</tr>
<tr>
<td align="center">unrepeat：CAB</td>
<td align="center">unrepeat：CAB</td>
</tr>
<tr>
<td align="center">unrepeat：BAB</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">repeat：BCB</td>
<td align="center">repeat：BAB</td>
</tr>
<tr>
<td align="center">repeat：CAC</td>
<td align="center">repeat：BCB</td>
</tr>
</tbody></table>
<p>在形如ABA这样的下面只能由3种unrepeat填充，2种repeat填充</p>
<p>在形如ABC这样的下面只能由2种unrepeat填充，2种repeat填充</p>
<p>每次填充依赖选择，当前可填充数目为</p>
<p>$$ repeat_n=3×unrepeat_{n-1}+2×repeat_{n-1}$$</p>
<p>$$ unrepeat_n=2×unrepeat_{n-1}+2×repeat_{n-1}$$</p>
<p>总结好规律后有下面代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numOfWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">long</span> m = <span class="number">6</span>,k = <span class="number">6</span>;<span class="comment">//k，m表示上一层repeat，unrepeat</span></span><br><span class="line">        <span class="keyword">long</span> repeat,unrepeat;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            repeat = (<span class="number">2</span>*(k+m))%<span class="number">1000000007</span>;</span><br><span class="line">            unrepeat = (<span class="number">3</span>*m+<span class="number">2</span>*k)%<span class="number">1000000007</span>;</span><br><span class="line">            m = unrepeat;</span><br><span class="line">            k = repeat;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (unrepeat+repeat)%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>VM下使用Kali及其后续</title>
    <url>/archives/54abd342.html</url>
    <content><![CDATA[<h3 id="VM下kali的安装"><a href="#VM下kali的安装" class="headerlink" title="VM下kali的安装"></a>VM下kali的安装</h3><p>直接去kali官网下载对应VM文件即可<a href="https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/" target="_blank" rel="noopener">传送门</a>，下载完成以后，直接解压到某个文件夹，用VM打开即可。</p>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><a id="more"></a>

<p>成功打开以后，全是英文界面，我不是很喜欢。把他弄成中文界面。</p>
<ol>
<li><p>打开kali的浏览器，输入一些关键字搜索，会发现不能显示中文，于是去解决乱码问题。</p>
</li>
<li><p>新建一个root用户，输入如下：sudo passwd root ,之后按照英文提示输入，切到root</p>
</li>
<li><p>更新源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/apt/sources.list</span><br><span class="line"><span class="comment"># 编辑源文件</span></span><br><span class="line"><span class="comment"># 这里使用的是vi编辑器，打开后按键盘字母i一下，变成insert模式，可编辑模式，</span></span><br><span class="line"><span class="comment">#deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span></span><br><span class="line"><span class="comment">#deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span></span><br><span class="line"><span class="comment">#将这两行加入到文件末尾，然后按esc键一次，输入（:wq）保存并退出。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新源，并更新软件依赖，安装中文字体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get clean</span><br><span class="line"><span class="comment">#更新源并更新软件。</span></span><br><span class="line">dpkg-reconfigure locales</span><br><span class="line"><span class="comment">#进入图形界面，选中en_US.UTF-8 UTF-8和zh_CN.UTF-8 UTF-8（空格是选择，tab是切换，*是选中）并将en_US.UTF-8选为默认。</span></span><br><span class="line">apt-get install xfonts-intl-chinese</span><br><span class="line">apt-get install ttf-wqy-microhei</span><br><span class="line"><span class="comment"># 安装中文字体</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>完成以后重启，在终端输入reboot好像没啥用，手动在虚拟机里面重启。</p>
</li>
</ol>
<h3 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update <span class="comment">#更新系统 </span></span><br><span class="line">apt-get dist-upgrade <span class="comment">#升级系统 </span></span><br><span class="line">apt-get install fcitx fcitx-googlepinyin <span class="comment">#google拼音</span></span><br></pre></td></tr></table></figure>

<p>执行完毕后，搜索fcitx configuration，添加谷歌拼音即可。</p>
<h3 id="安装新的软件"><a href="#安装新的软件" class="headerlink" title="安装新的软件"></a>安装新的软件</h3><p>apt-get install xxxx，即可安装</p>
<p>apt-get remove xxxx，即可卸载</p>
<p>一般完成以后是打不开的，因此需要修改一些东西。</p>
<p>去/usr/share/applications/下找到xxxx.desktop文件，用文本编辑器打开编辑，在Exex后修改为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Exec=/usr/bin/xxxx %U --no-sandbox</span><br></pre></td></tr></table></figure>

<h3 id="window10-加kali双系统"><a href="#window10-加kali双系统" class="headerlink" title="window10 加kali双系统"></a>window10 加kali双系统</h3><p>正常安装，分区再安装。没错误最好</p>
<p>遇到未安装启动引导器，其原因可能是您选择了不安装或者您的特殊硬件体系尚不支持启动引导器，您需要手动启动/dev/sda3分区上的/vmlinuz内核，并且以root=/dev/sda3作为内核参数，记住这个出错。</p>
<p><img src="/archives/54abd342/1.jpg" alt></p>
<p>解决办法：进入到boot界面，找一下add boot options</p>
<p><img src="/archives/54abd342/2.jpg" alt></p>
<p>之后找到一个grubx64.efi文件，加入</p>
<p><img src="/archives/54abd342/3.jpg" alt></p>
<p>之后重启进入kali，就可看到黑框grub命令行界面了。输入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">linux /boot/vmlinuz-xxx-xxx root=/dev/sda3 nouveau.modeset=<span class="number">0</span></span><br><span class="line"><span class="comment">//解释，vmlinuz后面一串字符，输入/boot/vmlinuz后按tab自动填充即可</span></span><br><span class="line"><span class="comment">//root=/dev/sda3是当初出错的时候提醒你的</span></span><br><span class="line">initrd /boot/initrd.img-xxx-xxxx</span><br><span class="line"><span class="comment">//这个xxxx也是按tab填充</span></span><br><span class="line">boot</span><br><span class="line"><span class="comment">//重启会进入到kali了，美滋滋</span></span><br><span class="line"><span class="comment">//之后还有呢</span></span><br><span class="line">update-grub</span><br><span class="line"><span class="comment">//上面update-grub自动修复引导</span></span><br><span class="line"><span class="comment">//错误是因为独立显卡的问题，还需要修改一个文件</span></span><br><span class="line">vi /boot/grub/grub.cfg</span><br><span class="line"><span class="comment">//找到禁用N卡的参数，修改 quiet flash 为quiet nouveau.modeset=0</span></span><br><span class="line"><span class="comment">//大功告成。</span></span><br></pre></td></tr></table></figure>

<p><img src="/archives/54abd342/4.jpg" alt></p>
<h3 id="VM下Macos"><a href="#VM下Macos" class="headerlink" title="VM下Macos"></a>VM下Macos</h3><p>稍微有点复杂，需要安装一个解锁包，然后去下载一个cdr后缀文件即可。</p>
<p>之后正常安装。</p>
<h3 id="VM下xp安装"><a href="#VM下xp安装" class="headerlink" title="VM下xp安装"></a>VM下xp安装</h3><p>普通安装</p>
<h3 id="vm下王win7安装"><a href="#vm下王win7安装" class="headerlink" title="vm下王win7安装"></a>vm下王win7安装</h3><p>这个炒饭，下载两个gho镜像都不得行，下载了第三个才得行。如xp</p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title>QQ空间</title>
    <url>/archives/b66ffe92.html</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>现在21世纪，有人称之为大数据时代，谁有数据量大的数据，谁能够从海量数据中提取到有用信息，并能够将其转换为资本，谁就取得了互联网的地位。</p>
<a id="more"></a>

<p>互联网数据是由生活在网络上的每一个用户所产生的，用户在互联网上的活动会被记录下来，这就是数据，海量用户，有着海量数据。这些数据被利用，分析，与各种各样的广告联系在一起，进而把这些广告推送给用户，这些推送的广告都是用户的网络行为分析出的结果。</p>
<p>QQ上活跃这大量的用户，QQ空间里面记录了许多人的日常，这些就是数据。在日常使用QQ空间的时候，会偶尔点击给我们好友点赞的朋友，之后我们就能看到我们好友的好友的空间，依次类推，我们可以看到海量信息。</p>
<h2 id="过程中用到的算法"><a href="#过程中用到的算法" class="headerlink" title="过程中用到的算法"></a>过程中用到的算法</h2><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>一、 前言</p>
<p>布隆过滤器 (Bloom Filter)是由Burton Howard Bloom于1970年提出，用于判断一个元素是否在集合中。与课本上学的数据结构不同，它是一种<strong>概率型</strong>数据结构，所谓概率型，就是指在判重的时候，并<strong>不是完全一定确保</strong>某个数据在集合中，课本上的二分查找，哈希，都可以<strong>一定确定</strong>某个元素是否在集合中。</p>
<p>在爬虫的时候，数据发生重复，需要判重，判断该条数据是否加入到队列中。传统哈希表可用于判断元素是否在集合中，时间复杂度<code>O(1)</code>,空间复杂度<code>o(n)</code>，布隆过滤器牺牲了一点时间，空间复杂度大约是哈希表的$\frac{1}{4}$。</p>
<p>布隆过滤器也支持数据的插入。</p>
<p>二、算法过程</p>
<p>一个布隆过滤器是一个有m个bit位的数组，每一个bit位都初始化为0。并且定义有k个不同的hash 函数，每个都以随机的将元素均匀hash到m个不同位置中的一个。</p>
<p>在下面的介绍中n为元素数，m为布隆过滤器或哈希表的槽数，k为布隆过滤器hash 函数个数。</p>
<ol>
<li><p>往布隆过滤器增加一个元素：首先用k个hash 函数分别将该元素hash，得到k个数值，于布隆过滤器中将这k个数值对应的bit位置1。</p>
<p>举例：现在有3个哈希函数，$f1,f2,f3$，有一个8位qq号，布隆过滤器数组长度m为10。qq号先经过三个hash函数处理，假设分别得到1，3，7，然后就将布隆数组1，3，7位置1。</p>
</li>
</ol>
<ol start="2">
<li><p>判断布隆过滤器中是否含有某个元素：首先用k个hash函数分别将该元素hash得到k个数值。再判断这k个数值在布隆数组中的位置是否全1，若全位1则此元素在集合中，若其中任一位不为1，则此元素比不在集合中。</p>
<p>举例：现在有3个哈希函数，$f1,f2,f3$，有一个8位qq号，布隆过滤器数组长度m为10。需要查找是否含有这个qq号。该qq号先经过三个hash函数处理，假设分别得到1，3，7，然后查看布隆数组1，3，7位置是否全为1。</p>
</li>
<li><p>概率型数组结构的解释：</p>
<p>举例：现在有3个哈希函数，$f1,f2,f3$，有3个8位qq号，假设分别为$q1,q2,q3$，布隆过滤器数组长度m为10。三个qq号分别经过三个hash函数处理，假设依次得到的结果为</p>
<p>$q1:1，3，7$，</p>
<p>$q2:2，5，8$，</p>
<p>$q3:2，3，7$，</p>
<p>在将$q1,q2 $依次插入到布隆数组中后，查询$q3$，发现其三个位置均为1，于是得到了q3在布隆过滤器的错误。这就是概率型的解释。</p>
</li>
<li><p>避免上述错误：<br>增加hash函数个数k，增加hash范围m。当hash结果范围很大大，且hash结果独立，直接上感觉不太可能发生碰撞。有没有一种hash函数的感觉😁。</p>
</li>
<li><p>使用场景：</p>
<p>总结：数据量大，很大，在使用查询可以接受一定的查询错误，使用布隆过滤器</p>
<p>​            当数据量大小自己能够接受，且不接受误判，使用传统set，哈希表。 </p>
</li>
</ol>
<p>三、举例说明</p>
<p>以垃圾邮件过滤中黑白名单为例：假设现有1亿个email的黑名单，每个都拥有8 bytes的指纹信息，则能的数据量大小为</p>
<p>$$1GB=2^{10} MB=2^{20} KB=2^{30}Bytes=2^{33}bits\approx10^9Byte$$<br>需要的位数组大小为$$2^{8×8}bits=2^{31}GB\approx2×10^9GB$$</p>
<p>这个数据量对于位数组来说是太大了，且在邮箱里，邮箱数量相比较邮箱范围过于稀疏，而且还没有考虑到哈希表中的碰撞问题。</p>
<p><strong>若采用哈希表</strong>，由于大多数采用开放地址法来解决碰撞，而此时的查找时间复杂度为 ：$O(\frac{1}{1-\frac{n}{m}})$，当哈希表半满($\frac{n}{m}=\frac{1}{2}$)，则每次search需要探测2次，因此在保证效率的情况下哈希表的存储效率最好不超过50%。此时每个元素占8 bytes，总空间为：$\frac{10^8×8Byte}{1-0.5}=1.6GB$</p>
<p><strong>若采用布隆过滤器</strong>，取k=8。因为n为1亿，所以总共需要$8 × 10^8$被置位为1，在保证误判率低，选取合适的k，m，让空间利用率为50%，所以总空间为：$\frac{8×10^8bis}{50%}\approx200MB$，所需空间比上述哈希结构小得多，并且误判率在万分之一以下。</p>
<p>四、误判概率的证明和计算</p>
<p>假设布隆过滤器中的hash函数满足简单均匀哈希假设：每个元素都等概率地hash到m个槽中的任何一个，与其它元素被hash到哪个slot无关。</p>
<p>若m为bit数，则对某一特定bit位在一个元素由某特定hash函数插入时没有被置位为1的概率为：$1-\frac{1}{m}$，该结论算法导论有详细证明。</p>
<p>那么k个hash 函数中没有一个对其置位的概率为：$(1-\frac{1}{m})^k$。</p>
<p>如果插入了n个元素，但都未将其置位的概率为：$(1-\frac{1}{m})^{kn}$。</p>
<p>则此位被置位的概率为：$1-(1-\frac{1}{m})^{kn}$。</p>
<p>现在考虑查找阶段，若对应某个待查找元素的k bits全部置位为1，则可判定其在集合中。因此将某元素误判的概率为：$(1-(1-\frac{1}{m})^{kn})^k$。</p>
<p>从上式中可以看出，当m增大或n减小时，都会使得误判率减小，这也符合直觉。</p>
<p>根据小学二年级学过的极限公式:$\lim\limits_{x\to0} (1+x)^{\frac{1}{x}}=e$</p>
<p> $(1-(1-\frac{1}{m})^{kn})^k=(1-(1-\frac{1}{m})^{m×\frac{kn}{-m}})^k$~$(1-e^{-\frac{nk}{m}})^k$。</p>
<p>现在可以假设当给定m，和n的当k取何值时，可以将误判率降至最低。</p>
<p>假设$f(k)=(1-e^{-\frac{nk}{m}})^k$，设$b = e^{\frac{n}{m}}$,此时，$f(k)=(1-b^{-k})^k$，接下来求$f(k)$的最值：</p>
<p>$f(k)=(1-b^{-k})^k$，两边同时取对数$lnf(k)=kln(1-b^{-k})$</p>
<p>两边同时对k求导 $\frac{1}{f(k)}f’(k)=ln(1-b^{-k})+k\frac{b^{-k}lnb}{1-b^{-k}}=0$</p>
<p>解上述方程：$☞(1-b^{-k})ln(1-b^{-k})=-kb^{-k}lnb$</p>
<p>​                       $☞(1-b^{-k})ln(1-b^{-k})=b^{-k}lnb^{-k}$</p>
<p>​                       $☞(1-b^{-k})=b^{-k}$</p>
<p>​                       $☞b^{-k}=\frac{1}{2}$</p>
<p>​                        $☞e^{-\frac{kn}{m}}=\frac{1}{2}$</p>
<p>​                        $☞k = ln2\frac{m}{n}$</p>
<p>此时误判率$f(k)=(1-b^{-k})^k=(1-\frac{1}{2})^{k}=2^{-ln2\frac{m}{n}}\approx0.6185^{\frac{m}{n}}$</p>
<p>调节$\frac{m}{n}$的大小，即可降低误判率$f(k)$。</p>
<p>五、设计和应用布隆过滤器的方法</p>
<p>首先要先由用户决定要add的元素数n，希望的误差率P。其他参数需要计算。</p>
<p>首先要计算需要的内存大小m bits：$p = 2^{-ln2\frac{m}{n}}⇨m=-\frac{nlnp}{(ln2)^2}$</p>
<p>再由m，n得到hash函数的个数：$k = ln2\frac{m}{n}$</p>
<p>至此结束。</p>
<p><a href="https://www.cnblogs.com/allensun/archive/2011/02/16/1956532.html" target="_blank" rel="noopener">原文参考</a></p>
<h3 id="框架算法：BFS广度优先搜索"><a href="#框架算法：BFS广度优先搜索" class="headerlink" title="框架算法：BFS广度优先搜索"></a>框架算法：BFS广度优先搜索</h3><p>一、前言</p>
<p>人的社交可以抽象定义成一个网络图。</p>
<p><img src="/archives/b66ffe92/1.jpg" alt></p>
<p>以每一个个人为中心，向外扩充一圈即时自己的好友圈。好友圈会有交叠。</p>
<p>不断的以每个人为中心，向外扩充，就是整个网络图(社交遍历)。</p>
<h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>每个人的好友圈是不同的，你的好友情况在别人那里情况可能是不一样的。</p>
<p>个人只能看到自己的朋友圈，去看看别人的朋友圈，了解一下其他圈子动态，也是一件相当有趣的事。</p>
<p>经过一圈圈的扩充遍历，好友的动态内容逐渐不同。我一开始能够访问到的内容是像自己一样普通大学生的动态，日常，到中间是那些转发，非原创动态，到最后，就逐渐变成卖衣服，卖手机的。</p>
<p>个人解释：qq空间其实是可以限制访问的，那些开放qq空间的人，会有哪些人？一，不在意别人访问的，二,需要别人浏览，阅读，转发。三，为了利益。</p>
<p>这些数据都有些什么用呢？有这些人的qq号，qq号主发的动态，号主的资料卡信息，其实这里最真实的只有qq号，然后是动态，分析假的资料信息并没有什么意义。qq号没得分析，动态分析，只得大致去浏览了。告一段落吧。</p>
<p>qq空间里人间百态。那个80-90-00的人间百态。</p>
]]></content>
      <categories>
        <category>cv</category>
      </categories>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习</title>
    <url>/archives/83b461a0.html</url>
    <content><![CDATA[<h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><p>string的初始化</p>
<table>
<thead>
<tr>
<th>初始化方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>string s1</td>
<td>默认初始化，s1为一空串</td>
</tr>
<tr>
<td>string s2(s1)</td>
<td>s2是s1的一个副本，直接初始化</td>
</tr>
<tr>
<td>string s2=s1</td>
<td>等价s2(s1)，拷贝初始化</td>
</tr>
<tr>
<td>string s3(“value”)</td>
<td>s3是字面值”value”的副本，不包括最后的空字符</td>
</tr>
<tr>
<td>string s3 = “value”</td>
<td>等价于s3(“value”)</td>
</tr>
<tr>
<td>string s4(n,’c’)</td>
<td>用连续n个字符初始化字符串s4，直接初始化</td>
</tr>
</tbody></table>
<p>string 类对象上的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>os&lt;&lt;s</td>
<td>将s写到输出流os当中，返回os</td>
</tr>
<tr>
<td>is&gt;&gt;s</td>
<td>从is中读取字符串赋给s,字符串以空白分隔，返回is</td>
</tr>
<tr>
<td>getlin(is,s)</td>
<td>从is中读取一行赋给S，返回is</td>
</tr>
<tr>
<td>s.empty()</td>
<td>s为空返回true,否则返回false</td>
</tr>
<tr>
<td>s.size()</td>
<td>返回s中字符的个数，返回的类型为string::size_type</td>
</tr>
<tr>
<td>s[n]</td>
<td>返回s中第n个字符，位置n从0计起</td>
</tr>
<tr>
<td>s1+s2</td>
<td>返回s1和s2连接后的结果</td>
</tr>
<tr>
<td>s1=s2</td>
<td>用s2的副本代替si中原来的字符</td>
</tr>
<tr>
<td>s1!=s2</td>
<td>判断s1和s2中所含的字符是否一样</td>
</tr>
<tr>
<td>s1==s2</td>
<td>同上</td>
</tr>
<tr>
<td>s1(&lt;,&lt;=,&gt;,&gt;=)</td>
<td>字典序比较</td>
</tr>
</tbody></table>
<h2 id="模板vector"><a href="#模板vector" class="headerlink" title="模板vector"></a>模板vector</h2><p>vector&lt;的初始化&gt;</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>vector<T> v1</T></td>
<td>v1为空，默认初始化</td>
</tr>
<tr>
<td>vector<T> v2(v1)</T></td>
<td>v2包含v1的所有元素</td>
</tr>
<tr>
<td>vector<T>v2 = v1</T></td>
<td>等价于vector<T>v2(v1)</T></td>
</tr>
<tr>
<td>vector<T>v3(n,val)</T></td>
<td>初始化了含n个val的vector</td>
</tr>
<tr>
<td>vector<T>v4(n)</T></td>
<td>vector大小为n，可存n个T</td>
</tr>
<tr>
<td>vector<T>v5{a,b,c,…}</T></td>
<td>按a,b,c,…初始化，并且值也确定</td>
</tr>
<tr>
<td>vector<T>v6 = {a,b,c,…}</T></td>
<td>等价于vector<T>{a,b,c,…}</T></td>
</tr>
<tr>
<td>vector<T>v7(begin(arr),end(arr))</T></td>
<td>用数组arr初始化v7</td>
</tr>
</tbody></table>
<p>vector上的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>v.push_back(T)</td>
<td>向v的末尾添加元素T</td>
</tr>
<tr>
<td>v.size()</td>
<td>v中所含元素个数</td>
</tr>
<tr>
<td>v.empty()</td>
<td>v是否为空</td>
</tr>
<tr>
<td>支持类似数组操作按秩访问</td>
<td></td>
</tr>
</tbody></table>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>stack的初始化</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>stack<int> stack1;</int></td>
<td>初始化一个栈，默认为双端队列</td>
</tr>
<tr>
<td>stack&lt;int,vector<int>&gt;stack2;</int></td>
<td>变成向量</td>
</tr>
<tr>
<td>stack&lt;int,list<int>&gt; stack3</int></td>
<td>链表</td>
</tr>
</tbody></table>
<p>stack上常用操作</p>
<table>
<thead>
<tr>
<th>返回值 操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>bool empty()</td>
<td>判断栈是否为空</td>
</tr>
<tr>
<td>void pop()</td>
<td>弹出栈顶元素，</td>
</tr>
<tr>
<td>void push(const T&amp; el)</td>
<td>将元素el压入栈顶，constT&amp;表示类型</td>
</tr>
<tr>
<td>size_type size()</td>
<td>栈中元素数目</td>
</tr>
<tr>
<td>T&amp; top()</td>
<td>栈顶元素</td>
</tr>
</tbody></table>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组的初始化</p>
<table>
<thead>
<tr>
<th>int arr[10]</th>
<th>含有10个整数的数组</th>
</tr>
</thead>
<tbody><tr>
<td>int *arr[10]</td>
<td>含有10个整型指针的数组</td>
</tr>
<tr>
<td>int arr[3]={1,2,3}</td>
<td>显式初始化</td>
</tr>
</tbody></table>
<h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><p>为已存在的运算符赋予另一层含义</p>
<p>当一个对象被用作右值时候，使用是对象的值(内容)，当用作左值的时候，用的是对象的身份(在内存中的地址)。</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><table>
<thead>
<tr>
<th>&amp;</th>
<th>两个位置上均为1结果才是1</th>
</tr>
</thead>
<tbody><tr>
<td>|</td>
<td>两个位置上至少有一个为1结果才是1</td>
</tr>
<tr>
<td>^</td>
<td>两个位置是上有且只有一个为1结果才是1</td>
</tr>
</tbody></table>
<h2 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	program code;</span><br><span class="line">&#125;<span class="keyword">catch</span>(exception-declaration)&#123;</span><br><span class="line">	handle exception;</span><br><span class="line">&#125;<span class="keyword">catch</span>(exception-declaration)&#123;</span><br><span class="line">	handle exception;</span><br><span class="line">&#125;<span class="comment">//基本语法</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>hello-world</title>
    <url>/archives/b1d4025b.html</url>
    <content><![CDATA[<h1 id="长恨歌"><a href="#长恨歌" class="headerlink" title="长恨歌"></a>长恨歌</h1><h2 id="唐代：白居易"><a href="#唐代：白居易" class="headerlink" title="唐代：白居易"></a>唐代：白居易</h2><p>汉皇重色思倾国，御宇多年求不得。<br>杨家有女初长成，养在深闺人未识。<br>天生丽质难自弃，一朝选在君王侧。<br>回眸一笑百媚生，六宫粉黛无颜色。<br>春寒赐浴华清池，温泉水滑洗凝脂。<br>侍儿扶起娇无力，始是新承恩泽时。<br>云鬓花颜金步摇，芙蓉帐暖度春宵。<br>春宵苦短日高起，从此君王不早朝。</p>
<a id="more"></a>

<p>承欢侍宴无闲暇，春从春游夜专夜。<br>后宫佳丽三千人，三千宠爱在一身。<br>金屋妆成娇侍夜，玉楼宴罢醉和春。<br>姊妹弟兄皆列土，可怜光彩生门户。<br>遂令天下父母心，不重生男重生女。<br>骊宫高处入青云，仙乐风飘处处闻。<br>缓歌慢舞凝丝竹，尽日君王看不足。<br>渔阳鼙鼓动地来，惊破霓裳羽衣曲。</p>
<p>九重城阙烟尘生，千乘万骑西南行。<br>翠华摇摇行复止，西出都门百余里。<br>六军不发无奈何，宛转蛾眉马前死。<br>花钿委地无人收，翠翘金雀玉搔头。<br>君王掩面救不得，回看血泪相和流。<br>黄埃散漫风萧索，云栈萦纡登剑阁。<br>峨嵋山下少人行，旌旗无光日色薄。<br>蜀江水碧蜀山青，圣主朝朝暮暮情。</p>
<p>行宫见月伤心色，夜雨闻铃肠断声。<br>天旋地转回龙驭，到此踌躇不能去。<br>马嵬坡下泥土中，不见玉颜空死处。<br>君臣相顾尽沾衣，东望都门信马归。<br>归来池苑皆依旧，太液芙蓉未央柳。<br>芙蓉如面柳如眉，对此如何不泪垂。<br>春风桃李花开日，秋雨梧桐叶落时。<br>西宫南内多秋草，落叶满阶红不扫。(花开日 一作：花开夜；南内 一作：南苑)</p>
<p>梨园弟子白发新，椒房阿监青娥老。<br>夕殿萤飞思悄然，孤灯挑尽未成眠。<br>迟迟钟鼓初长夜，耿耿星河欲曙天。<br>鸳鸯瓦冷霜华重，翡翠衾寒谁与共。<br>悠悠生死别经年，魂魄不曾来入梦。<br>临邛道士鸿都客，能以精诚致魂魄。<br>为感君王辗转思，遂教方士殷勤觅。<br>排空驭气奔如电，升天入地求之遍。</p>
<p>上穷碧落下黄泉，两处茫茫皆不见。<br>忽闻海上有仙山，山在虚无缥渺间。<br>楼阁玲珑五云起，其中绰约多仙子。<br>中有一人字太真，雪肤花貌参差是。<br>金阙西厢叩玉扃，转教小玉报双成。<br>闻道汉家天子使，九华帐里梦魂惊。<br>揽衣推枕起徘徊，珠箔银屏迤逦开。<br>云鬓半偏新睡觉，花冠不整下堂来。</p>
<p>风吹仙袂飘飖举，犹似霓裳羽衣舞。<br>玉容寂寞泪阑干，梨花一枝春带雨。(阑 通：栏)<br>含情凝睇谢君王，一别音容两渺茫。<br>昭阳殿里恩爱绝，蓬莱宫中日月长。<br>回头下望人寰处，不见长安见尘雾。<br>惟将旧物表深情，钿合金钗寄将去。<br>钗留一股合一扇，钗擘黄金合分钿。<br>但教心似金钿坚，天上人间会相见。</p>
<p>临别殷勤重寄词，词中有誓两心知。<br>七月七日长生殿，夜半无人私语时。<br>在天愿作比翼鸟，在地愿为连理枝。<br>天长地久有时尽，此恨绵绵无绝期。</p>
]]></content>
  </entry>
</search>
